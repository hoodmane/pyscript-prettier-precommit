import { createRequire as __prettierCreateRequire } from "module";
import { fileURLToPath as __prettierFileUrlToPath } from "url";
import { dirname as __prettierDirname } from "path";
const require = __prettierCreateRequire(import.meta.url);
const __filename = __prettierFileUrlToPath(import.meta.url);
const __dirname = __prettierDirname(__filename);

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// node_modules/vnopts/node_modules/tslib/tslib.es6.js
var tslib_es6_exports = {};
__export(tslib_es6_exports, {
  __assign: () => __assign,
  __asyncDelegator: () => __asyncDelegator,
  __asyncGenerator: () => __asyncGenerator,
  __asyncValues: () => __asyncValues,
  __await: () => __await,
  __awaiter: () => __awaiter,
  __classPrivateFieldGet: () => __classPrivateFieldGet,
  __classPrivateFieldSet: () => __classPrivateFieldSet,
  __createBinding: () => __createBinding,
  __decorate: () => __decorate,
  __exportStar: () => __exportStar,
  __extends: () => __extends,
  __generator: () => __generator,
  __importDefault: () => __importDefault,
  __importStar: () => __importStar,
  __makeTemplateObject: () => __makeTemplateObject,
  __metadata: () => __metadata,
  __param: () => __param,
  __read: () => __read,
  __rest: () => __rest,
  __spread: () => __spread,
  __spreadArrays: () => __spreadArrays,
  __values: () => __values
});
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __createBinding(o, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  o[k2] = m[k];
}
function __exportStar(m, exports) {
  for (var p in m)
    if (p !== "default" && !exports.hasOwnProperty(p))
      exports[p] = m[p];
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n) {
    if (g[n])
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length)
      resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function(v) {
      return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve2, reject) {
        v = o[n](v), settle(resolve2, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve2, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve2({ value: v2, done: d });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod)
      if (Object.hasOwnProperty.call(mod, k))
        result[k] = mod[k];
  }
  result.default = mod;
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, privateMap) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return privateMap.get(receiver);
}
function __classPrivateFieldSet(receiver, privateMap, value) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to set private field on non-instance");
  }
  privateMap.set(receiver, value);
  return value;
}
var extendStatics, __assign;
var init_tslib_es6 = __esm({
  "node_modules/vnopts/node_modules/tslib/tslib.es6.js"() {
    extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (b2.hasOwnProperty(p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    __assign = function() {
      __assign = Object.assign || function __assign2(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
  }
});

// node_modules/vnopts/lib/descriptors/api.js
var require_api = __commonJS({
  "node_modules/vnopts/lib/descriptors/api.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.apiDescriptor = {
      key: (key) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(key) ? key : JSON.stringify(key),
      value(value) {
        if (value === null || typeof value !== "object") {
          return JSON.stringify(value);
        }
        if (Array.isArray(value)) {
          return `[${value.map((subValue) => exports.apiDescriptor.value(subValue)).join(", ")}]`;
        }
        const keys = Object.keys(value);
        return keys.length === 0 ? "{}" : `{ ${keys.map((key) => `${exports.apiDescriptor.key(key)}: ${exports.apiDescriptor.value(value[key])}`).join(", ")} }`;
      },
      pair: ({ key, value }) => exports.apiDescriptor.value({ [key]: value })
    };
  }
});

// node_modules/vnopts/lib/descriptors/index.js
var require_descriptors = __commonJS({
  "node_modules/vnopts/lib/descriptors/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_api(), exports);
  }
});

// node_modules/vnopts/node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS({
  "node_modules/vnopts/node_modules/escape-string-regexp/index.js"(exports, module) {
    "use strict";
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    module.exports = function(str) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      return str.replace(matchOperatorsRe, "\\$&");
    };
  }
});

// node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/color-name/index.js"(exports, module) {
    "use strict";
    module.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "node_modules/color-convert/conversions.js"(exports, module) {
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (key in cssKeywords) {
      if (cssKeywords.hasOwnProperty(key)) {
        reverseKeywords[cssKeywords[key]] = key;
      }
    }
    var key;
    var convert = module.exports = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    for (model in convert) {
      if (convert.hasOwnProperty(model)) {
        if (!("channels" in convert[model])) {
          throw new Error("missing channels property: " + model);
        }
        if (!("labels" in convert[model])) {
          throw new Error("missing channel labels property: " + model);
        }
        if (convert[model].labels.length !== convert[model].channels) {
          throw new Error("channel and label counts mismatch: " + model);
        }
        channels = convert[model].channels;
        labels = convert[model].labels;
        delete convert[model].channels;
        delete convert[model].labels;
        Object.defineProperty(convert[model], "channels", { value: channels });
        Object.defineProperty(convert[model], "labels", { value: labels });
      }
    }
    var channels;
    var labels;
    var model;
    convert.rgb.hsl = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var min = Math.min(r, g, b);
      var max = Math.max(r, g, b);
      var delta = max - min;
      var h;
      var s;
      var l;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      var rdif;
      var gdif;
      var bdif;
      var h;
      var s;
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var v = Math.max(r, g, b);
      var diff = v - Math.min(r, g, b);
      var diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      var r = rgb[0];
      var g = rgb[1];
      var b = rgb[2];
      var h = convert.rgb.hsl(rgb)[0];
      var w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var c;
      var m;
      var y;
      var k;
      k = Math.min(1 - r, 1 - g, 1 - b);
      c = (1 - r - k) / (1 - k) || 0;
      m = (1 - g - k) / (1 - k) || 0;
      y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
    }
    convert.rgb.keyword = function(rgb) {
      var reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      var currentClosestDistance = Infinity;
      var currentClosestKeyword;
      for (var keyword in cssKeywords) {
        if (cssKeywords.hasOwnProperty(keyword)) {
          var value = cssKeywords[keyword];
          var distance = comparativeDistance(rgb, value);
          if (distance < currentClosestDistance) {
            currentClosestDistance = distance;
            currentClosestKeyword = keyword;
          }
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
      var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      var xyz = convert.rgb.xyz(rgb);
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      var h = hsl[0] / 360;
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var t1;
      var t2;
      var t3;
      var rgb;
      var val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      t1 = 2 * l - t2;
      rgb = [0, 0, 0];
      for (var i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      var h = hsl[0];
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var smin = s;
      var lmin = Math.max(l, 0.01);
      var sv;
      var v;
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      v = (l + s) / 2;
      sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      var h = hsv[0] / 60;
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var hi = Math.floor(h) % 6;
      var f = h - Math.floor(h);
      var p = 255 * v * (1 - s);
      var q = 255 * v * (1 - s * f);
      var t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      var h = hsv[0];
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var vmin = Math.max(v, 0.01);
      var lmin;
      var sl;
      var l;
      l = (2 - s) * v;
      lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      var h = hwb[0] / 360;
      var wh = hwb[1] / 100;
      var bl = hwb[2] / 100;
      var ratio = wh + bl;
      var i;
      var v;
      var f;
      var n;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      i = Math.floor(6 * h);
      v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      n = wh + f * (v - wh);
      var r;
      var g;
      var b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      var c = cmyk[0] / 100;
      var m = cmyk[1] / 100;
      var y = cmyk[2] / 100;
      var k = cmyk[3] / 100;
      var r;
      var g;
      var b;
      r = 1 - Math.min(1, c * (1 - k) + k);
      g = 1 - Math.min(1, m * (1 - k) + k);
      b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      var x = xyz[0] / 100;
      var y = xyz[1] / 100;
      var z = xyz[2] / 100;
      var r;
      var g;
      var b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var x;
      var y;
      var z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      var y2 = Math.pow(y, 3);
      var x2 = Math.pow(x, 3);
      var z2 = Math.pow(z, 3);
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var hr;
      var h;
      var c;
      hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert.lch.lab = function(lch) {
      var l = lch[0];
      var c = lch[1];
      var h = lch[2];
      var a;
      var b;
      var hr;
      hr = h / 360 * 2 * Math.PI;
      a = c * Math.cos(hr);
      b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      var color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      var mult = (~~(args > 50) + 1) * 0.5;
      var r = (color & 1) * mult * 255;
      var g = (color >> 1 & 1) * mult * 255;
      var b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        var c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      var rem;
      var r = Math.floor(args / 36) / 5 * 255;
      var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      var b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      var colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map(function(char) {
          return char + char;
        }).join("");
      }
      var integer = parseInt(colorString, 16);
      var r = integer >> 16 & 255;
      var g = integer >> 8 & 255;
      var b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var max = Math.max(Math.max(r, g), b);
      var min = Math.min(Math.min(r, g), b);
      var chroma = max - min;
      var grayscale;
      var hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma + 4;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var c = 1;
      var f = 0;
      if (l < 0.5) {
        c = 2 * s * l;
      } else {
        c = 2 * s * (1 - l);
      }
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var c = s * v;
      var f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      var h = hcg[0] / 360;
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      var pure = [0, 0, 0];
      var hi = h % 1 * 6;
      var v = hi % 1;
      var w = 1 - v;
      var mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1 - c);
      var f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var l = g * (1 - c) + 0.5 * c;
      var s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      var w = hwb[1] / 100;
      var b = hwb[2] / 100;
      var v = 1 - b;
      var c = v - w;
      var g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = convert.gray.hsv = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      var val = Math.round(gray[0] / 100 * 255) & 255;
      var integer = (val << 16) + (val << 8) + val;
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/color-convert/route.js
var require_route = __commonJS({
  "node_modules/color-convert/route.js"(exports, module) {
    var conversions = require_conversions();
    function buildGraph() {
      var graph = {};
      var models = Object.keys(conversions);
      for (var len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      var graph = buildGraph();
      var queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        var current = queue.pop();
        var adjacents = Object.keys(conversions[current]);
        for (var len = adjacents.length, i = 0; i < len; i++) {
          var adjacent = adjacents[i];
          var node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      var path11 = [graph[toModel].parent, toModel];
      var fn = conversions[graph[toModel].parent][toModel];
      var cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path11.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path11;
      return fn;
    }
    module.exports = function(fromModel) {
      var graph = deriveBFS(fromModel);
      var conversion = {};
      var models = Object.keys(graph);
      for (var len = models.length, i = 0; i < len; i++) {
        var toModel = models[i];
        var node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "node_modules/color-convert/index.js"(exports, module) {
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        var result = fn(args);
        if (typeof result === "object") {
          for (var len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach(function(fromModel) {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      var routes = route(fromModel);
      var routeModels = Object.keys(routes);
      routeModels.forEach(function(toModel) {
        var fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module.exports = convert;
  }
});

// node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "node_modules/ansi-styles/index.js"(exports, module) {
    "use strict";
    var colorConvert = require_color_convert();
    var wrapAnsi16 = (fn, offset) => function() {
      const code = fn.apply(colorConvert, arguments);
      return `\x1B[${code + offset}m`;
    };
    var wrapAnsi256 = (fn, offset) => function() {
      const code = fn.apply(colorConvert, arguments);
      return `\x1B[${38 + offset};5;${code}m`;
    };
    var wrapAnsi16m = (fn, offset) => function() {
      const rgb = fn.apply(colorConvert, arguments);
      return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    function assembleStyles() {
      const codes2 = /* @__PURE__ */ new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          gray: [90, 39],
          // Bright color
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.grey = styles.color.gray;
      for (const groupName of Object.keys(styles)) {
        const group2 = styles[groupName];
        for (const styleName of Object.keys(group2)) {
          const style = group2[styleName];
          styles[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group2[styleName] = styles[styleName];
          codes2.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group2,
          enumerable: false
        });
        Object.defineProperty(styles, "codes", {
          value: codes2,
          enumerable: false
        });
      }
      const ansi2ansi = (n) => n;
      const rgb2rgb = (r, g, b) => [r, g, b];
      styles.color.close = "\x1B[39m";
      styles.bgColor.close = "\x1B[49m";
      styles.color.ansi = {
        ansi: wrapAnsi16(ansi2ansi, 0)
      };
      styles.color.ansi256 = {
        ansi256: wrapAnsi256(ansi2ansi, 0)
      };
      styles.color.ansi16m = {
        rgb: wrapAnsi16m(rgb2rgb, 0)
      };
      styles.bgColor.ansi = {
        ansi: wrapAnsi16(ansi2ansi, 10)
      };
      styles.bgColor.ansi256 = {
        ansi256: wrapAnsi256(ansi2ansi, 10)
      };
      styles.bgColor.ansi16m = {
        rgb: wrapAnsi16m(rgb2rgb, 10)
      };
      for (let key of Object.keys(colorConvert)) {
        if (typeof colorConvert[key] !== "object") {
          continue;
        }
        const suite = colorConvert[key];
        if (key === "ansi16") {
          key = "ansi";
        }
        if ("ansi16" in suite) {
          styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
          styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
        }
        if ("ansi256" in suite) {
          styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
          styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
        }
        if ("rgb" in suite) {
          styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
          styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
        }
      }
      return styles;
    }
    Object.defineProperty(module, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// node_modules/vnopts/node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/vnopts/node_modules/has-flag/index.js"(exports, module) {
    "use strict";
    module.exports = (flag, argv) => {
      argv = argv || process.argv;
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const pos = argv.indexOf(prefix + flag);
      const terminatorPos = argv.indexOf("--");
      return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
    };
  }
});

// node_modules/vnopts/node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/vnopts/node_modules/supports-color/index.js"(exports, module) {
    "use strict";
    var os = __require("os");
    var hasFlag = require_has_flag();
    var env = process.env;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
      forceColor = false;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = true;
    }
    if ("FORCE_COLOR" in env) {
      forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(stream) {
      if (forceColor === false) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (stream && !stream.isTTY && forceColor !== true) {
        return 0;
      }
      const min = forceColor ? 1 : 0;
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      if (env.TERM === "dumb") {
        return min;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream);
      return translateLevel(level);
    }
    module.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel(process.stdout),
      stderr: getSupportLevel(process.stderr)
    };
  }
});

// node_modules/vnopts/node_modules/chalk/templates.js
var require_templates = __commonJS({
  "node_modules/vnopts/node_modules/chalk/templates.js"(exports, module) {
    "use strict";
    var TEMPLATE_REGEX = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    var STRING_REGEX2 = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    var ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;
    var ESCAPES = /* @__PURE__ */ new Map([
      ["n", "\n"],
      ["r", "\r"],
      ["t", "	"],
      ["b", "\b"],
      ["f", "\f"],
      ["v", "\v"],
      ["0", "\0"],
      ["\\", "\\"],
      ["e", "\x1B"],
      ["a", "\x07"]
    ]);
    function unescape(c) {
      if (c[0] === "u" && c.length === 5 || c[0] === "x" && c.length === 3) {
        return String.fromCharCode(parseInt(c.slice(1), 16));
      }
      return ESCAPES.get(c) || c;
    }
    function parseArguments(name, args) {
      const results = [];
      const chunks = args.trim().split(/\s*,\s*/g);
      let matches;
      for (const chunk of chunks) {
        if (!isNaN(chunk)) {
          results.push(Number(chunk));
        } else if (matches = chunk.match(STRING_REGEX2)) {
          results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, chr) => escape ? unescape(escape) : chr));
        } else {
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
        }
      }
      return results;
    }
    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      const results = [];
      let matches;
      while ((matches = STYLE_REGEX.exec(style)) !== null) {
        const name = matches[1];
        if (matches[2]) {
          const args = parseArguments(name, matches[2]);
          results.push([name].concat(args));
        } else {
          results.push([name]);
        }
      }
      return results;
    }
    function buildStyle(chalk, styles) {
      const enabled = {};
      for (const layer of styles) {
        for (const style of layer.styles) {
          enabled[style[0]] = layer.inverse ? null : style.slice(1);
        }
      }
      let current = chalk;
      for (const styleName of Object.keys(enabled)) {
        if (Array.isArray(enabled[styleName])) {
          if (!(styleName in current)) {
            throw new Error(`Unknown Chalk style: ${styleName}`);
          }
          if (enabled[styleName].length > 0) {
            current = current[styleName].apply(current, enabled[styleName]);
          } else {
            current = current[styleName];
          }
        }
      }
      return current;
    }
    module.exports = (chalk, tmp) => {
      const styles = [];
      const chunks = [];
      let chunk = [];
      tmp.replace(TEMPLATE_REGEX, (m, escapeChar, inverse, style, close, chr) => {
        if (escapeChar) {
          chunk.push(unescape(escapeChar));
        } else if (style) {
          const str = chunk.join("");
          chunk = [];
          chunks.push(styles.length === 0 ? str : buildStyle(chalk, styles)(str));
          styles.push({ inverse, styles: parseStyle(style) });
        } else if (close) {
          if (styles.length === 0) {
            throw new Error("Found extraneous } in Chalk template literal");
          }
          chunks.push(buildStyle(chalk, styles)(chunk.join("")));
          chunk = [];
          styles.pop();
        } else {
          chunk.push(chr);
        }
      });
      chunks.push(chunk.join(""));
      if (styles.length > 0) {
        const errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMsg);
      }
      return chunks.join("");
    };
  }
});

// node_modules/vnopts/node_modules/chalk/index.js
var require_chalk = __commonJS({
  "node_modules/vnopts/node_modules/chalk/index.js"(exports, module) {
    "use strict";
    var escapeStringRegexp2 = require_escape_string_regexp();
    var ansiStyles = require_ansi_styles();
    var stdoutColor = require_supports_color().stdout;
    var template = require_templates();
    var isSimpleWindowsTerm = process.platform === "win32" && !(process.env.TERM || "").toLowerCase().startsWith("xterm");
    var levelMapping = ["ansi", "ansi", "ansi256", "ansi16m"];
    var skipModels = /* @__PURE__ */ new Set(["gray"]);
    var styles = /* @__PURE__ */ Object.create(null);
    function applyOptions(obj, options9) {
      options9 = options9 || {};
      const scLevel = stdoutColor ? stdoutColor.level : 0;
      obj.level = options9.level === void 0 ? scLevel : options9.level;
      obj.enabled = "enabled" in options9 ? options9.enabled : obj.level > 0;
    }
    function Chalk(options9) {
      if (!this || !(this instanceof Chalk) || this.template) {
        const chalk = {};
        applyOptions(chalk, options9);
        chalk.template = function() {
          const args = [].slice.call(arguments);
          return chalkTag.apply(null, [chalk.template].concat(args));
        };
        Object.setPrototypeOf(chalk, Chalk.prototype);
        Object.setPrototypeOf(chalk.template, chalk);
        chalk.template.constructor = Chalk;
        return chalk.template;
      }
      applyOptions(this, options9);
    }
    if (isSimpleWindowsTerm) {
      ansiStyles.blue.open = "\x1B[94m";
    }
    for (const key of Object.keys(ansiStyles)) {
      ansiStyles[key].closeRe = new RegExp(escapeStringRegexp2(ansiStyles[key].close), "g");
      styles[key] = {
        get() {
          const codes2 = ansiStyles[key];
          return build.call(this, this._styles ? this._styles.concat(codes2) : [codes2], this._empty, key);
        }
      };
    }
    styles.visible = {
      get() {
        return build.call(this, this._styles || [], true, "visible");
      }
    };
    ansiStyles.color.closeRe = new RegExp(escapeStringRegexp2(ansiStyles.color.close), "g");
    for (const model of Object.keys(ansiStyles.color.ansi)) {
      if (skipModels.has(model)) {
        continue;
      }
      styles[model] = {
        get() {
          const level = this.level;
          return function() {
            const open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);
            const codes2 = {
              open,
              close: ansiStyles.color.close,
              closeRe: ansiStyles.color.closeRe
            };
            return build.call(this, this._styles ? this._styles.concat(codes2) : [codes2], this._empty, model);
          };
        }
      };
    }
    ansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp2(ansiStyles.bgColor.close), "g");
    for (const model of Object.keys(ansiStyles.bgColor.ansi)) {
      if (skipModels.has(model)) {
        continue;
      }
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles[bgModel] = {
        get() {
          const level = this.level;
          return function() {
            const open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);
            const codes2 = {
              open,
              close: ansiStyles.bgColor.close,
              closeRe: ansiStyles.bgColor.closeRe
            };
            return build.call(this, this._styles ? this._styles.concat(codes2) : [codes2], this._empty, model);
          };
        }
      };
    }
    var proto = Object.defineProperties(() => {
    }, styles);
    function build(_styles, _empty, key) {
      const builder = function() {
        return applyStyle.apply(builder, arguments);
      };
      builder._styles = _styles;
      builder._empty = _empty;
      const self2 = this;
      Object.defineProperty(builder, "level", {
        enumerable: true,
        get() {
          return self2.level;
        },
        set(level) {
          self2.level = level;
        }
      });
      Object.defineProperty(builder, "enabled", {
        enumerable: true,
        get() {
          return self2.enabled;
        },
        set(enabled) {
          self2.enabled = enabled;
        }
      });
      builder.hasGrey = this.hasGrey || key === "gray" || key === "grey";
      builder.__proto__ = proto;
      return builder;
    }
    function applyStyle() {
      const args = arguments;
      const argsLen = args.length;
      let str = String(arguments[0]);
      if (argsLen === 0) {
        return "";
      }
      if (argsLen > 1) {
        for (let a = 1; a < argsLen; a++) {
          str += " " + args[a];
        }
      }
      if (!this.enabled || this.level <= 0 || !str) {
        return this._empty ? "" : str;
      }
      const originalDim = ansiStyles.dim.open;
      if (isSimpleWindowsTerm && this.hasGrey) {
        ansiStyles.dim.open = "";
      }
      for (const code of this._styles.slice().reverse()) {
        str = code.open + str.replace(code.closeRe, code.open) + code.close;
        str = str.replace(/\r?\n/g, `${code.close}$&${code.open}`);
      }
      ansiStyles.dim.open = originalDim;
      return str;
    }
    function chalkTag(chalk, strings) {
      if (!Array.isArray(strings)) {
        return [].slice.call(arguments, 1).join(" ");
      }
      const args = [].slice.call(arguments, 2);
      const parts = [strings.raw[0]];
      for (let i = 1; i < strings.length; i++) {
        parts.push(String(args[i - 1]).replace(/[{}\\]/g, "\\$&"));
        parts.push(String(strings.raw[i]));
      }
      return template(chalk, parts.join(""));
    }
    Object.defineProperties(Chalk.prototype, styles);
    module.exports = Chalk();
    module.exports.supportsColor = stdoutColor;
    module.exports.default = module.exports;
  }
});

// node_modules/vnopts/lib/handlers/deprecated/common.js
var require_common = __commonJS({
  "node_modules/vnopts/lib/handlers/deprecated/common.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var chalk_1 = require_chalk();
    exports.commonDeprecatedHandler = (keyOrPair, redirectTo, { descriptor }) => {
      const messages2 = [
        `${chalk_1.default.yellow(typeof keyOrPair === "string" ? descriptor.key(keyOrPair) : descriptor.pair(keyOrPair))} is deprecated`
      ];
      if (redirectTo) {
        messages2.push(`we now treat it as ${chalk_1.default.blue(typeof redirectTo === "string" ? descriptor.key(redirectTo) : descriptor.pair(redirectTo))}`);
      }
      return messages2.join("; ") + ".";
    };
  }
});

// node_modules/vnopts/lib/handlers/deprecated/index.js
var require_deprecated = __commonJS({
  "node_modules/vnopts/lib/handlers/deprecated/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_common(), exports);
  }
});

// node_modules/vnopts/lib/handlers/invalid/common.js
var require_common2 = __commonJS({
  "node_modules/vnopts/lib/handlers/invalid/common.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var chalk_1 = require_chalk();
    exports.commonInvalidHandler = (key, value, utils2) => [
      `Invalid ${chalk_1.default.red(utils2.descriptor.key(key))} value.`,
      `Expected ${chalk_1.default.blue(utils2.schemas[key].expected(utils2))},`,
      `but received ${chalk_1.default.red(utils2.descriptor.value(value))}.`
    ].join(" ");
  }
});

// node_modules/vnopts/lib/handlers/invalid/index.js
var require_invalid = __commonJS({
  "node_modules/vnopts/lib/handlers/invalid/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_common2(), exports);
  }
});

// node_modules/vnopts/node_modules/leven/index.js
var require_leven = __commonJS({
  "node_modules/vnopts/node_modules/leven/index.js"(exports, module) {
    "use strict";
    var arr = [];
    var charCodeCache = [];
    module.exports = function(a, b) {
      if (a === b) {
        return 0;
      }
      var swap = a;
      if (a.length > b.length) {
        a = b;
        b = swap;
      }
      var aLen = a.length;
      var bLen = b.length;
      if (aLen === 0) {
        return bLen;
      }
      if (bLen === 0) {
        return aLen;
      }
      while (aLen > 0 && a.charCodeAt(~-aLen) === b.charCodeAt(~-bLen)) {
        aLen--;
        bLen--;
      }
      if (aLen === 0) {
        return bLen;
      }
      var start = 0;
      while (start < aLen && a.charCodeAt(start) === b.charCodeAt(start)) {
        start++;
      }
      aLen -= start;
      bLen -= start;
      if (aLen === 0) {
        return bLen;
      }
      var bCharCode;
      var ret;
      var tmp;
      var tmp2;
      var i = 0;
      var j = 0;
      while (i < aLen) {
        charCodeCache[start + i] = a.charCodeAt(start + i);
        arr[i] = ++i;
      }
      while (j < bLen) {
        bCharCode = b.charCodeAt(start + j);
        tmp = j++;
        ret = j;
        for (i = 0; i < aLen; i++) {
          tmp2 = bCharCode === charCodeCache[start + i] ? tmp : tmp + 1;
          tmp = arr[i];
          ret = arr[i] = tmp > ret ? tmp2 > ret ? ret + 1 : tmp2 : tmp2 > tmp ? tmp + 1 : tmp2;
        }
      }
      return ret;
    };
  }
});

// node_modules/vnopts/lib/handlers/unknown/leven.js
var require_leven2 = __commonJS({
  "node_modules/vnopts/lib/handlers/unknown/leven.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var chalk_1 = require_chalk();
    var leven = require_leven();
    exports.levenUnknownHandler = (key, value, { descriptor, logger, schemas }) => {
      const messages2 = [
        `Ignored unknown option ${chalk_1.default.yellow(descriptor.pair({ key, value }))}.`
      ];
      const suggestion = Object.keys(schemas).sort().find((knownKey) => leven(key, knownKey) < 3);
      if (suggestion) {
        messages2.push(`Did you mean ${chalk_1.default.blue(descriptor.key(suggestion))}?`);
      }
      logger.warn(messages2.join(" "));
    };
  }
});

// node_modules/vnopts/lib/handlers/unknown/index.js
var require_unknown = __commonJS({
  "node_modules/vnopts/lib/handlers/unknown/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_leven2(), exports);
  }
});

// node_modules/vnopts/lib/handlers/index.js
var require_handlers = __commonJS({
  "node_modules/vnopts/lib/handlers/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_deprecated(), exports);
    tslib_1.__exportStar(require_invalid(), exports);
    tslib_1.__exportStar(require_unknown(), exports);
  }
});

// node_modules/vnopts/lib/schema.js
var require_schema = __commonJS({
  "node_modules/vnopts/lib/schema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var HANDLER_KEYS = [
      "default",
      "expected",
      "validate",
      "deprecated",
      "forward",
      "redirect",
      "overlap",
      "preprocess",
      "postprocess"
    ];
    function createSchema(SchemaConstructor, parameters) {
      const schema = new SchemaConstructor(parameters);
      const subSchema = Object.create(schema);
      for (const handlerKey of HANDLER_KEYS) {
        if (handlerKey in parameters) {
          subSchema[handlerKey] = normalizeHandler(parameters[handlerKey], schema, Schema.prototype[handlerKey].length);
        }
      }
      return subSchema;
    }
    exports.createSchema = createSchema;
    var Schema = class {
      constructor(parameters) {
        this.name = parameters.name;
      }
      static create(parameters) {
        return createSchema(this, parameters);
      }
      default(_utils) {
        return void 0;
      }
      // istanbul ignore next: this is actually an abstract method but we need a placeholder to get `function.length`
      expected(_utils) {
        return "nothing";
      }
      // istanbul ignore next: this is actually an abstract method but we need a placeholder to get `function.length`
      validate(_value, _utils) {
        return false;
      }
      deprecated(_value, _utils) {
        return false;
      }
      forward(_value, _utils) {
        return void 0;
      }
      redirect(_value, _utils) {
        return void 0;
      }
      overlap(currentValue, _newValue, _utils) {
        return currentValue;
      }
      preprocess(value, _utils) {
        return value;
      }
      postprocess(value, _utils) {
        return value;
      }
    };
    exports.Schema = Schema;
    function normalizeHandler(handler, superSchema, handlerArgumentsLength) {
      return typeof handler === "function" ? (...args) => handler(...args.slice(0, handlerArgumentsLength - 1), superSchema, ...args.slice(handlerArgumentsLength - 1)) : () => handler;
    }
  }
});

// node_modules/vnopts/lib/schemas/alias.js
var require_alias = __commonJS({
  "node_modules/vnopts/lib/schemas/alias.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var schema_1 = require_schema();
    var AliasSchema = class extends schema_1.Schema {
      constructor(parameters) {
        super(parameters);
        this._sourceName = parameters.sourceName;
      }
      expected(utils2) {
        return utils2.schemas[this._sourceName].expected(utils2);
      }
      validate(value, utils2) {
        return utils2.schemas[this._sourceName].validate(value, utils2);
      }
      redirect(_value, _utils) {
        return this._sourceName;
      }
    };
    exports.AliasSchema = AliasSchema;
  }
});

// node_modules/vnopts/lib/schemas/any.js
var require_any = __commonJS({
  "node_modules/vnopts/lib/schemas/any.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var schema_1 = require_schema();
    var AnySchema = class extends schema_1.Schema {
      expected() {
        return "anything";
      }
      validate() {
        return true;
      }
    };
    exports.AnySchema = AnySchema;
  }
});

// node_modules/vnopts/lib/schemas/array.js
var require_array = __commonJS({
  "node_modules/vnopts/lib/schemas/array.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var schema_1 = require_schema();
    var ArraySchema = class extends schema_1.Schema {
      constructor(_a) {
        var { valueSchema, name = valueSchema.name } = _a, handlers = tslib_1.__rest(_a, ["valueSchema", "name"]);
        super(Object.assign({}, handlers, { name }));
        this._valueSchema = valueSchema;
      }
      expected(utils2) {
        return `an array of ${this._valueSchema.expected(utils2)}`;
      }
      validate(value, utils2) {
        if (!Array.isArray(value)) {
          return false;
        }
        const invalidValues = [];
        for (const subValue of value) {
          const subValidateResult = utils2.normalizeValidateResult(this._valueSchema.validate(subValue, utils2), subValue);
          if (subValidateResult !== true) {
            invalidValues.push(subValidateResult.value);
          }
        }
        return invalidValues.length === 0 ? true : { value: invalidValues };
      }
      deprecated(value, utils2) {
        const deprecatedResult = [];
        for (const subValue of value) {
          const subDeprecatedResult = utils2.normalizeDeprecatedResult(this._valueSchema.deprecated(subValue, utils2), subValue);
          if (subDeprecatedResult !== false) {
            deprecatedResult.push(...subDeprecatedResult.map(({ value: deprecatedValue }) => ({
              value: [deprecatedValue]
            })));
          }
        }
        return deprecatedResult;
      }
      forward(value, utils2) {
        const forwardResult = [];
        for (const subValue of value) {
          const subForwardResult = utils2.normalizeForwardResult(this._valueSchema.forward(subValue, utils2), subValue);
          forwardResult.push(...subForwardResult.map(wrapTransferResult));
        }
        return forwardResult;
      }
      redirect(value, utils2) {
        const remain = [];
        const redirect = [];
        for (const subValue of value) {
          const subRedirectResult = utils2.normalizeRedirectResult(this._valueSchema.redirect(subValue, utils2), subValue);
          if ("remain" in subRedirectResult) {
            remain.push(subRedirectResult.remain);
          }
          redirect.push(...subRedirectResult.redirect.map(wrapTransferResult));
        }
        return remain.length === 0 ? { redirect } : { redirect, remain };
      }
      overlap(currentValue, newValue) {
        return currentValue.concat(newValue);
      }
    };
    exports.ArraySchema = ArraySchema;
    function wrapTransferResult({ from, to }) {
      return { from: [from], to };
    }
  }
});

// node_modules/vnopts/lib/schemas/boolean.js
var require_boolean = __commonJS({
  "node_modules/vnopts/lib/schemas/boolean.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var schema_1 = require_schema();
    var BooleanSchema = class extends schema_1.Schema {
      expected() {
        return "true or false";
      }
      validate(value) {
        return typeof value === "boolean";
      }
    };
    exports.BooleanSchema = BooleanSchema;
  }
});

// node_modules/vnopts/lib/utils.js
var require_utils = __commonJS({
  "node_modules/vnopts/lib/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function recordFromArray(array, mainKey) {
      const record = /* @__PURE__ */ Object.create(null);
      for (const value of array) {
        const key = value[mainKey];
        if (record[key]) {
          throw new Error(`Duplicate ${mainKey} ${JSON.stringify(key)}`);
        }
        record[key] = value;
      }
      return record;
    }
    exports.recordFromArray = recordFromArray;
    function mapFromArray(array, mainKey) {
      const map = /* @__PURE__ */ new Map();
      for (const value of array) {
        const key = value[mainKey];
        if (map.has(key)) {
          throw new Error(`Duplicate ${mainKey} ${JSON.stringify(key)}`);
        }
        map.set(key, value);
      }
      return map;
    }
    exports.mapFromArray = mapFromArray;
    function createAutoChecklist() {
      const map = /* @__PURE__ */ Object.create(null);
      return (id) => {
        const idString = JSON.stringify(id);
        if (map[idString]) {
          return true;
        }
        map[idString] = true;
        return false;
      };
    }
    exports.createAutoChecklist = createAutoChecklist;
    function partition2(array, predicate) {
      const trueArray = [];
      const falseArray = [];
      for (const value of array) {
        if (predicate(value)) {
          trueArray.push(value);
        } else {
          falseArray.push(value);
        }
      }
      return [trueArray, falseArray];
    }
    exports.partition = partition2;
    function isInt(value) {
      return value === Math.floor(value);
    }
    exports.isInt = isInt;
    function comparePrimitive(a, b) {
      if (a === b) {
        return 0;
      }
      const typeofA = typeof a;
      const typeofB = typeof b;
      const orders = [
        "undefined",
        "object",
        "boolean",
        "number",
        "string"
      ];
      if (typeofA !== typeofB) {
        return orders.indexOf(typeofA) - orders.indexOf(typeofB);
      }
      if (typeofA !== "string") {
        return Number(a) - Number(b);
      }
      return a.localeCompare(b);
    }
    exports.comparePrimitive = comparePrimitive;
    function normalizeDefaultResult(result) {
      return result === void 0 ? {} : result;
    }
    exports.normalizeDefaultResult = normalizeDefaultResult;
    function normalizeValidateResult(result, value) {
      return result === true ? true : result === false ? { value } : result;
    }
    exports.normalizeValidateResult = normalizeValidateResult;
    function normalizeDeprecatedResult(result, value, doNotNormalizeTrue = false) {
      return result === false ? false : result === true ? doNotNormalizeTrue ? true : [{ value }] : "value" in result ? [result] : result.length === 0 ? false : result;
    }
    exports.normalizeDeprecatedResult = normalizeDeprecatedResult;
    function normalizeTransferResult(result, value) {
      return typeof result === "string" || "key" in result ? { from: value, to: result } : "from" in result ? { from: result.from, to: result.to } : { from: value, to: result.to };
    }
    exports.normalizeTransferResult = normalizeTransferResult;
    function normalizeForwardResult(result, value) {
      return result === void 0 ? [] : Array.isArray(result) ? result.map((transferResult) => normalizeTransferResult(transferResult, value)) : [normalizeTransferResult(result, value)];
    }
    exports.normalizeForwardResult = normalizeForwardResult;
    function normalizeRedirectResult(result, value) {
      const redirect = normalizeForwardResult(typeof result === "object" && "redirect" in result ? result.redirect : result, value);
      return redirect.length === 0 ? { remain: value, redirect } : typeof result === "object" && "remain" in result ? { remain: result.remain, redirect } : { redirect };
    }
    exports.normalizeRedirectResult = normalizeRedirectResult;
  }
});

// node_modules/vnopts/lib/schemas/choice.js
var require_choice = __commonJS({
  "node_modules/vnopts/lib/schemas/choice.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var schema_1 = require_schema();
    var utils_1 = require_utils();
    var ChoiceSchema = class extends schema_1.Schema {
      constructor(parameters) {
        super(parameters);
        this._choices = utils_1.mapFromArray(parameters.choices.map((choice) => choice && typeof choice === "object" ? choice : { value: choice }), "value");
      }
      expected({ descriptor }) {
        const choiceValues = Array.from(this._choices.keys()).map((value) => this._choices.get(value)).filter((choiceInfo) => !choiceInfo.deprecated).map((choiceInfo) => choiceInfo.value).sort(utils_1.comparePrimitive).map(descriptor.value);
        const head = choiceValues.slice(0, -2);
        const tail = choiceValues.slice(-2);
        return head.concat(tail.join(" or ")).join(", ");
      }
      validate(value) {
        return this._choices.has(value);
      }
      deprecated(value) {
        const choiceInfo = this._choices.get(value);
        return choiceInfo && choiceInfo.deprecated ? { value } : false;
      }
      forward(value) {
        const choiceInfo = this._choices.get(value);
        return choiceInfo ? choiceInfo.forward : void 0;
      }
      redirect(value) {
        const choiceInfo = this._choices.get(value);
        return choiceInfo ? choiceInfo.redirect : void 0;
      }
    };
    exports.ChoiceSchema = ChoiceSchema;
  }
});

// node_modules/vnopts/lib/schemas/number.js
var require_number = __commonJS({
  "node_modules/vnopts/lib/schemas/number.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var schema_1 = require_schema();
    var NumberSchema = class extends schema_1.Schema {
      expected() {
        return "a number";
      }
      validate(value, _utils) {
        return typeof value === "number";
      }
    };
    exports.NumberSchema = NumberSchema;
  }
});

// node_modules/vnopts/lib/schemas/integer.js
var require_integer = __commonJS({
  "node_modules/vnopts/lib/schemas/integer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils();
    var number_1 = require_number();
    var IntegerSchema = class extends number_1.NumberSchema {
      expected() {
        return "an integer";
      }
      validate(value, utils2) {
        return utils2.normalizeValidateResult(super.validate(value, utils2), value) === true && utils_1.isInt(value);
      }
    };
    exports.IntegerSchema = IntegerSchema;
  }
});

// node_modules/vnopts/lib/schemas/string.js
var require_string = __commonJS({
  "node_modules/vnopts/lib/schemas/string.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var schema_1 = require_schema();
    var StringSchema = class extends schema_1.Schema {
      expected() {
        return "a string";
      }
      validate(value) {
        return typeof value === "string";
      }
    };
    exports.StringSchema = StringSchema;
  }
});

// node_modules/vnopts/lib/schemas/index.js
var require_schemas = __commonJS({
  "node_modules/vnopts/lib/schemas/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_alias(), exports);
    tslib_1.__exportStar(require_any(), exports);
    tslib_1.__exportStar(require_array(), exports);
    tslib_1.__exportStar(require_boolean(), exports);
    tslib_1.__exportStar(require_choice(), exports);
    tslib_1.__exportStar(require_integer(), exports);
    tslib_1.__exportStar(require_number(), exports);
    tslib_1.__exportStar(require_string(), exports);
  }
});

// node_modules/vnopts/lib/defaults.js
var require_defaults = __commonJS({
  "node_modules/vnopts/lib/defaults.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var api_1 = require_api();
    var common_1 = require_common();
    var invalid_1 = require_invalid();
    var leven_1 = require_leven2();
    exports.defaultDescriptor = api_1.apiDescriptor;
    exports.defaultUnknownHandler = leven_1.levenUnknownHandler;
    exports.defaultInvalidHandler = invalid_1.commonInvalidHandler;
    exports.defaultDeprecatedHandler = common_1.commonDeprecatedHandler;
  }
});

// node_modules/vnopts/lib/normalize.js
var require_normalize = __commonJS({
  "node_modules/vnopts/lib/normalize.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var defaults_1 = require_defaults();
    var utils_1 = require_utils();
    exports.normalize = (options9, schemas, opts) => new Normalizer(schemas, opts).normalize(options9);
    var Normalizer = class {
      constructor(schemas, opts) {
        const { logger = console, descriptor = defaults_1.defaultDescriptor, unknown = defaults_1.defaultUnknownHandler, invalid = defaults_1.defaultInvalidHandler, deprecated = defaults_1.defaultDeprecatedHandler } = opts || {};
        this._utils = {
          descriptor,
          logger: (
            /* istanbul ignore next */
            logger || { warn: () => {
            } }
          ),
          schemas: utils_1.recordFromArray(schemas, "name"),
          normalizeDefaultResult: utils_1.normalizeDefaultResult,
          normalizeDeprecatedResult: utils_1.normalizeDeprecatedResult,
          normalizeForwardResult: utils_1.normalizeForwardResult,
          normalizeRedirectResult: utils_1.normalizeRedirectResult,
          normalizeValidateResult: utils_1.normalizeValidateResult
        };
        this._unknownHandler = unknown;
        this._invalidHandler = invalid;
        this._deprecatedHandler = deprecated;
        this.cleanHistory();
      }
      cleanHistory() {
        this._hasDeprecationWarned = utils_1.createAutoChecklist();
      }
      normalize(options9) {
        const normalized = {};
        const restOptionsArray = [options9];
        const applyNormalization = () => {
          while (restOptionsArray.length !== 0) {
            const currentOptions = restOptionsArray.shift();
            const transferredOptionsArray = this._applyNormalization(currentOptions, normalized);
            restOptionsArray.push(...transferredOptionsArray);
          }
        };
        applyNormalization();
        for (const key of Object.keys(this._utils.schemas)) {
          const schema = this._utils.schemas[key];
          if (!(key in normalized)) {
            const defaultResult = utils_1.normalizeDefaultResult(schema.default(this._utils));
            if ("value" in defaultResult) {
              restOptionsArray.push({ [key]: defaultResult.value });
            }
          }
        }
        applyNormalization();
        for (const key of Object.keys(this._utils.schemas)) {
          const schema = this._utils.schemas[key];
          if (key in normalized) {
            normalized[key] = schema.postprocess(normalized[key], this._utils);
          }
        }
        return normalized;
      }
      _applyNormalization(options9, normalized) {
        const transferredOptionsArray = [];
        const [knownOptionNames, unknownOptionNames] = utils_1.partition(Object.keys(options9), (key) => key in this._utils.schemas);
        for (const key of knownOptionNames) {
          const schema = this._utils.schemas[key];
          const value = schema.preprocess(options9[key], this._utils);
          const validateResult = utils_1.normalizeValidateResult(schema.validate(value, this._utils), value);
          if (validateResult !== true) {
            const { value: invalidValue } = validateResult;
            const errorMessageOrError = this._invalidHandler(key, invalidValue, this._utils);
            throw typeof errorMessageOrError === "string" ? new Error(errorMessageOrError) : (
              /* istanbul ignore next*/
              errorMessageOrError
            );
          }
          const appendTransferredOptions = ({ from, to }) => {
            transferredOptionsArray.push(typeof to === "string" ? { [to]: from } : { [to.key]: to.value });
          };
          const warnDeprecated = ({ value: currentValue, redirectTo }) => {
            const deprecatedResult = utils_1.normalizeDeprecatedResult(
              schema.deprecated(currentValue, this._utils),
              value,
              /* doNotNormalizeTrue */
              true
            );
            if (deprecatedResult === false) {
              return;
            }
            if (deprecatedResult === true) {
              if (!this._hasDeprecationWarned(key)) {
                this._utils.logger.warn(this._deprecatedHandler(key, redirectTo, this._utils));
              }
            } else {
              for (const { value: deprecatedValue } of deprecatedResult) {
                const pair = { key, value: deprecatedValue };
                if (!this._hasDeprecationWarned(pair)) {
                  const redirectToPair = typeof redirectTo === "string" ? { key: redirectTo, value: deprecatedValue } : redirectTo;
                  this._utils.logger.warn(this._deprecatedHandler(pair, redirectToPair, this._utils));
                }
              }
            }
          };
          const forwardResult = utils_1.normalizeForwardResult(schema.forward(value, this._utils), value);
          forwardResult.forEach(appendTransferredOptions);
          const redirectResult = utils_1.normalizeRedirectResult(schema.redirect(value, this._utils), value);
          redirectResult.redirect.forEach(appendTransferredOptions);
          if ("remain" in redirectResult) {
            const remainingValue = redirectResult.remain;
            normalized[key] = key in normalized ? schema.overlap(normalized[key], remainingValue, this._utils) : remainingValue;
            warnDeprecated({ value: remainingValue });
          }
          for (const { from, to } of redirectResult.redirect) {
            warnDeprecated({ value: from, redirectTo: to });
          }
        }
        for (const key of unknownOptionNames) {
          const value = options9[key];
          const unknownResult = this._unknownHandler(key, value, this._utils);
          if (unknownResult) {
            for (const unknownKey of Object.keys(unknownResult)) {
              const unknownOption = { [unknownKey]: unknownResult[unknownKey] };
              if (unknownKey in this._utils.schemas) {
                transferredOptionsArray.push(unknownOption);
              } else {
                Object.assign(normalized, unknownOption);
              }
            }
          }
        }
        return transferredOptionsArray;
      }
    };
    exports.Normalizer = Normalizer;
  }
});

// node_modules/vnopts/lib/index.js
var require_lib = __commonJS({
  "node_modules/vnopts/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_descriptors(), exports);
    tslib_1.__exportStar(require_handlers(), exports);
    tslib_1.__exportStar(require_schemas(), exports);
    tslib_1.__exportStar(require_normalize(), exports);
    tslib_1.__exportStar(require_schema(), exports);
  }
});

// node_modules/fast-glob/out/utils/array.js
var require_array2 = __commonJS({
  "node_modules/fast-glob/out/utils/array.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.splitWhen = exports.flatten = void 0;
    function flatten(items) {
      return items.reduce((collection, item) => [].concat(collection, item), []);
    }
    exports.flatten = flatten;
    function splitWhen(items, predicate) {
      const result = [[]];
      let groupIndex = 0;
      for (const item of items) {
        if (predicate(item)) {
          groupIndex++;
          result[groupIndex] = [];
        } else {
          result[groupIndex].push(item);
        }
      }
      return result;
    }
    exports.splitWhen = splitWhen;
  }
});

// node_modules/fast-glob/out/utils/errno.js
var require_errno = __commonJS({
  "node_modules/fast-glob/out/utils/errno.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isEnoentCodeError = void 0;
    function isEnoentCodeError(error) {
      return error.code === "ENOENT";
    }
    exports.isEnoentCodeError = isEnoentCodeError;
  }
});

// node_modules/fast-glob/out/utils/fs.js
var require_fs = __commonJS({
  "node_modules/fast-glob/out/utils/fs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createDirentFromStats = void 0;
    var DirentFromStats = class {
      constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    function createDirentFromStats(name, stats) {
      return new DirentFromStats(name, stats);
    }
    exports.createDirentFromStats = createDirentFromStats;
  }
});

// node_modules/fast-glob/out/utils/path.js
var require_path = __commonJS({
  "node_modules/fast-glob/out/utils/path.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.removeLeadingDotSegment = exports.escape = exports.makeAbsolute = exports.unixify = void 0;
    var path11 = __require("path");
    var LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2;
    var UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\())/g;
    function unixify(filepath) {
      return filepath.replace(/\\/g, "/");
    }
    exports.unixify = unixify;
    function makeAbsolute(cwd, filepath) {
      return path11.resolve(cwd, filepath);
    }
    exports.makeAbsolute = makeAbsolute;
    function escape(pattern) {
      return pattern.replace(UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
    }
    exports.escape = escape;
    function removeLeadingDotSegment(entry) {
      if (entry.charAt(0) === ".") {
        const secondCharactery = entry.charAt(1);
        if (secondCharactery === "/" || secondCharactery === "\\") {
          return entry.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);
        }
      }
      return entry;
    }
    exports.removeLeadingDotSegment = removeLeadingDotSegment;
  }
});

// node_modules/is-extglob/index.js
var require_is_extglob = __commonJS({
  "node_modules/is-extglob/index.js"(exports, module) {
    module.exports = function isExtglob(str) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      var match;
      while (match = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
        if (match[2])
          return true;
        str = str.slice(match.index + match[0].length);
      }
      return false;
    };
  }
});

// node_modules/is-glob/index.js
var require_is_glob = __commonJS({
  "node_modules/is-glob/index.js"(exports, module) {
    var isExtglob = require_is_extglob();
    var chars = { "{": "}", "(": ")", "[": "]" };
    var strictCheck = function(str) {
      if (str[0] === "!") {
        return true;
      }
      var index = 0;
      var pipeIndex = -2;
      var closeSquareIndex = -2;
      var closeCurlyIndex = -2;
      var closeParenIndex = -2;
      var backSlashIndex = -2;
      while (index < str.length) {
        if (str[index] === "*") {
          return true;
        }
        if (str[index + 1] === "?" && /[\].+)]/.test(str[index])) {
          return true;
        }
        if (closeSquareIndex !== -1 && str[index] === "[" && str[index + 1] !== "]") {
          if (closeSquareIndex < index) {
            closeSquareIndex = str.indexOf("]", index);
          }
          if (closeSquareIndex > index) {
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
          }
        }
        if (closeCurlyIndex !== -1 && str[index] === "{" && str[index + 1] !== "}") {
          closeCurlyIndex = str.indexOf("}", index);
          if (closeCurlyIndex > index) {
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
              return true;
            }
          }
        }
        if (closeParenIndex !== -1 && str[index] === "(" && str[index + 1] === "?" && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ")") {
          closeParenIndex = str.indexOf(")", index);
          if (closeParenIndex > index) {
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
              return true;
            }
          }
        }
        if (pipeIndex !== -1 && str[index] === "(" && str[index + 1] !== "|") {
          if (pipeIndex < index) {
            pipeIndex = str.indexOf("|", index);
          }
          if (pipeIndex !== -1 && str[pipeIndex + 1] !== ")") {
            closeParenIndex = str.indexOf(")", pipeIndex);
            if (closeParenIndex > pipeIndex) {
              backSlashIndex = str.indexOf("\\", pipeIndex);
              if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
                return true;
              }
            }
          }
        }
        if (str[index] === "\\") {
          var open = str[index + 1];
          index += 2;
          var close = chars[open];
          if (close) {
            var n = str.indexOf(close, index);
            if (n !== -1) {
              index = n + 1;
            }
          }
          if (str[index] === "!") {
            return true;
          }
        } else {
          index++;
        }
      }
      return false;
    };
    var relaxedCheck = function(str) {
      if (str[0] === "!") {
        return true;
      }
      var index = 0;
      while (index < str.length) {
        if (/[*?{}()[\]]/.test(str[index])) {
          return true;
        }
        if (str[index] === "\\") {
          var open = str[index + 1];
          index += 2;
          var close = chars[open];
          if (close) {
            var n = str.indexOf(close, index);
            if (n !== -1) {
              index = n + 1;
            }
          }
          if (str[index] === "!") {
            return true;
          }
        } else {
          index++;
        }
      }
      return false;
    };
    module.exports = function isGlob(str, options9) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      if (isExtglob(str)) {
        return true;
      }
      var check2 = strictCheck;
      if (options9 && options9.strict === false) {
        check2 = relaxedCheck;
      }
      return check2(str);
    };
  }
});

// node_modules/glob-parent/index.js
var require_glob_parent = __commonJS({
  "node_modules/glob-parent/index.js"(exports, module) {
    "use strict";
    var isGlob = require_is_glob();
    var pathPosixDirname = __require("path").posix.dirname;
    var isWin32 = __require("os").platform() === "win32";
    var slash2 = "/";
    var backslash = /\\/g;
    var enclosure = /[\{\[].*[\}\]]$/;
    var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
    var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
    module.exports = function globParent(str, opts) {
      var options9 = Object.assign({ flipBackslashes: true }, opts);
      if (options9.flipBackslashes && isWin32 && str.indexOf(slash2) < 0) {
        str = str.replace(backslash, slash2);
      }
      if (enclosure.test(str)) {
        str += slash2;
      }
      str += "a";
      do {
        str = pathPosixDirname(str);
      } while (isGlob(str) || globby.test(str));
      return str.replace(escaped, "$1");
    };
  }
});

// node_modules/braces/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/braces/lib/utils.js"(exports) {
    "use strict";
    exports.isInteger = (num) => {
      if (typeof num === "number") {
        return Number.isInteger(num);
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isInteger(Number(num));
      }
      return false;
    };
    exports.find = (node, type) => node.nodes.find((node2) => node2.type === type);
    exports.exceedsLimit = (min, max, step = 1, limit) => {
      if (limit === false)
        return false;
      if (!exports.isInteger(min) || !exports.isInteger(max))
        return false;
      return (Number(max) - Number(min)) / Number(step) >= limit;
    };
    exports.escapeNode = (block, n = 0, type) => {
      let node = block.nodes[n];
      if (!node)
        return;
      if (type && node.type === type || node.type === "open" || node.type === "close") {
        if (node.escaped !== true) {
          node.value = "\\" + node.value;
          node.escaped = true;
        }
      }
    };
    exports.encloseBrace = (node) => {
      if (node.type !== "brace")
        return false;
      if (node.commas >> 0 + node.ranges >> 0 === 0) {
        node.invalid = true;
        return true;
      }
      return false;
    };
    exports.isInvalidBrace = (block) => {
      if (block.type !== "brace")
        return false;
      if (block.invalid === true || block.dollar)
        return true;
      if (block.commas >> 0 + block.ranges >> 0 === 0) {
        block.invalid = true;
        return true;
      }
      if (block.open !== true || block.close !== true) {
        block.invalid = true;
        return true;
      }
      return false;
    };
    exports.isOpenOrClose = (node) => {
      if (node.type === "open" || node.type === "close") {
        return true;
      }
      return node.open === true || node.close === true;
    };
    exports.reduce = (nodes) => nodes.reduce((acc, node) => {
      if (node.type === "text")
        acc.push(node.value);
      if (node.type === "range")
        node.type = "text";
      return acc;
    }, []);
    exports.flatten = (...args) => {
      const result = [];
      const flat = (arr) => {
        for (let i = 0; i < arr.length; i++) {
          let ele = arr[i];
          Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);
        }
        return result;
      };
      flat(args);
      return result;
    };
  }
});

// node_modules/braces/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/braces/lib/stringify.js"(exports, module) {
    "use strict";
    var utils2 = require_utils2();
    module.exports = (ast, options9 = {}) => {
      let stringify2 = (node, parent = {}) => {
        let invalidBlock = options9.escapeInvalid && utils2.isInvalidBrace(parent);
        let invalidNode = node.invalid === true && options9.escapeInvalid === true;
        let output = "";
        if (node.value) {
          if ((invalidBlock || invalidNode) && utils2.isOpenOrClose(node)) {
            return "\\" + node.value;
          }
          return node.value;
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes) {
          for (let child of node.nodes) {
            output += stringify2(child);
          }
        }
        return output;
      };
      return stringify2(ast);
    };
  }
});

// node_modules/is-number/index.js
var require_is_number = __commonJS({
  "node_modules/is-number/index.js"(exports, module) {
    "use strict";
    module.exports = function(num) {
      if (typeof num === "number") {
        return num - num === 0;
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
      }
      return false;
    };
  }
});

// node_modules/to-regex-range/index.js
var require_to_regex_range = __commonJS({
  "node_modules/to-regex-range/index.js"(exports, module) {
    "use strict";
    var isNumber = require_is_number();
    var toRegexRange = (min, max, options9) => {
      if (isNumber(min) === false) {
        throw new TypeError("toRegexRange: expected the first argument to be a number");
      }
      if (max === void 0 || min === max) {
        return String(min);
      }
      if (isNumber(max) === false) {
        throw new TypeError("toRegexRange: expected the second argument to be a number.");
      }
      let opts = { relaxZeros: true, ...options9 };
      if (typeof opts.strictZeros === "boolean") {
        opts.relaxZeros = opts.strictZeros === false;
      }
      let relax = String(opts.relaxZeros);
      let shorthand = String(opts.shorthand);
      let capture = String(opts.capture);
      let wrap = String(opts.wrap);
      let cacheKey = min + ":" + max + "=" + relax + shorthand + capture + wrap;
      if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
        return toRegexRange.cache[cacheKey].result;
      }
      let a = Math.min(min, max);
      let b = Math.max(min, max);
      if (Math.abs(a - b) === 1) {
        let result = min + "|" + max;
        if (opts.capture) {
          return `(${result})`;
        }
        if (opts.wrap === false) {
          return result;
        }
        return `(?:${result})`;
      }
      let isPadded = hasPadding(min) || hasPadding(max);
      let state = { min, max, a, b };
      let positives = [];
      let negatives = [];
      if (isPadded) {
        state.isPadded = isPadded;
        state.maxLen = String(state.max).length;
      }
      if (a < 0) {
        let newMin = b < 0 ? Math.abs(b) : 1;
        negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
        a = state.a = 0;
      }
      if (b >= 0) {
        positives = splitToPatterns(a, b, state, opts);
      }
      state.negatives = negatives;
      state.positives = positives;
      state.result = collatePatterns(negatives, positives, opts);
      if (opts.capture === true) {
        state.result = `(${state.result})`;
      } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
        state.result = `(?:${state.result})`;
      }
      toRegexRange.cache[cacheKey] = state;
      return state.result;
    };
    function collatePatterns(neg, pos, options9) {
      let onlyNegative = filterPatterns(neg, pos, "-", false, options9) || [];
      let onlyPositive = filterPatterns(pos, neg, "", false, options9) || [];
      let intersected = filterPatterns(neg, pos, "-?", true, options9) || [];
      let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
      return subpatterns.join("|");
    }
    function splitToRanges(min, max) {
      let nines = 1;
      let zeros = 1;
      let stop = countNines(min, nines);
      let stops = /* @__PURE__ */ new Set([max]);
      while (min <= stop && stop <= max) {
        stops.add(stop);
        nines += 1;
        stop = countNines(min, nines);
      }
      stop = countZeros(max + 1, zeros) - 1;
      while (min < stop && stop <= max) {
        stops.add(stop);
        zeros += 1;
        stop = countZeros(max + 1, zeros) - 1;
      }
      stops = [...stops];
      stops.sort(compare);
      return stops;
    }
    function rangeToPattern(start, stop, options9) {
      if (start === stop) {
        return { pattern: start, count: [], digits: 0 };
      }
      let zipped = zip(start, stop);
      let digits = zipped.length;
      let pattern = "";
      let count = 0;
      for (let i = 0; i < digits; i++) {
        let [startDigit, stopDigit] = zipped[i];
        if (startDigit === stopDigit) {
          pattern += startDigit;
        } else if (startDigit !== "0" || stopDigit !== "9") {
          pattern += toCharacterClass(startDigit, stopDigit, options9);
        } else {
          count++;
        }
      }
      if (count) {
        pattern += options9.shorthand === true ? "\\d" : "[0-9]";
      }
      return { pattern, count: [count], digits };
    }
    function splitToPatterns(min, max, tok, options9) {
      let ranges = splitToRanges(min, max);
      let tokens = [];
      let start = min;
      let prev;
      for (let i = 0; i < ranges.length; i++) {
        let max2 = ranges[i];
        let obj = rangeToPattern(String(start), String(max2), options9);
        let zeros = "";
        if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
          if (prev.count.length > 1) {
            prev.count.pop();
          }
          prev.count.push(obj.count[0]);
          prev.string = prev.pattern + toQuantifier(prev.count);
          start = max2 + 1;
          continue;
        }
        if (tok.isPadded) {
          zeros = padZeros(max2, tok, options9);
        }
        obj.string = zeros + obj.pattern + toQuantifier(obj.count);
        tokens.push(obj);
        start = max2 + 1;
        prev = obj;
      }
      return tokens;
    }
    function filterPatterns(arr, comparison, prefix, intersection, options9) {
      let result = [];
      for (let ele of arr) {
        let { string } = ele;
        if (!intersection && !contains(comparison, "string", string)) {
          result.push(prefix + string);
        }
        if (intersection && contains(comparison, "string", string)) {
          result.push(prefix + string);
        }
      }
      return result;
    }
    function zip(a, b) {
      let arr = [];
      for (let i = 0; i < a.length; i++)
        arr.push([a[i], b[i]]);
      return arr;
    }
    function compare(a, b) {
      return a > b ? 1 : b > a ? -1 : 0;
    }
    function contains(arr, key, val) {
      return arr.some((ele) => ele[key] === val);
    }
    function countNines(min, len) {
      return Number(String(min).slice(0, -len) + "9".repeat(len));
    }
    function countZeros(integer, zeros) {
      return integer - integer % Math.pow(10, zeros);
    }
    function toQuantifier(digits) {
      let [start = 0, stop = ""] = digits;
      if (stop || start > 1) {
        return `{${start + (stop ? "," + stop : "")}}`;
      }
      return "";
    }
    function toCharacterClass(a, b, options9) {
      return `[${a}${b - a === 1 ? "" : "-"}${b}]`;
    }
    function hasPadding(str) {
      return /^-?(0+)\d/.test(str);
    }
    function padZeros(value, tok, options9) {
      if (!tok.isPadded) {
        return value;
      }
      let diff = Math.abs(tok.maxLen - String(value).length);
      let relax = options9.relaxZeros !== false;
      switch (diff) {
        case 0:
          return "";
        case 1:
          return relax ? "0?" : "0";
        case 2:
          return relax ? "0{0,2}" : "00";
        default: {
          return relax ? `0{0,${diff}}` : `0{${diff}}`;
        }
      }
    }
    toRegexRange.cache = {};
    toRegexRange.clearCache = () => toRegexRange.cache = {};
    module.exports = toRegexRange;
  }
});

// node_modules/fill-range/index.js
var require_fill_range = __commonJS({
  "node_modules/fill-range/index.js"(exports, module) {
    "use strict";
    var util = __require("util");
    var toRegexRange = require_to_regex_range();
    var isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    var transform2 = (toNumber) => {
      return (value) => toNumber === true ? Number(value) : String(value);
    };
    var isValidValue = (value) => {
      return typeof value === "number" || typeof value === "string" && value !== "";
    };
    var isNumber = (num) => Number.isInteger(+num);
    var zeros = (input) => {
      let value = `${input}`;
      let index = -1;
      if (value[0] === "-")
        value = value.slice(1);
      if (value === "0")
        return false;
      while (value[++index] === "0")
        ;
      return index > 0;
    };
    var stringify2 = (start, end, options9) => {
      if (typeof start === "string" || typeof end === "string") {
        return true;
      }
      return options9.stringify === true;
    };
    var pad = (input, maxLength, toNumber) => {
      if (maxLength > 0) {
        let dash = input[0] === "-" ? "-" : "";
        if (dash)
          input = input.slice(1);
        input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
      }
      if (toNumber === false) {
        return String(input);
      }
      return input;
    };
    var toMaxLen = (input, maxLength) => {
      let negative = input[0] === "-" ? "-" : "";
      if (negative) {
        input = input.slice(1);
        maxLength--;
      }
      while (input.length < maxLength)
        input = "0" + input;
      return negative ? "-" + input : input;
    };
    var toSequence = (parts, options9) => {
      parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      let prefix = options9.capture ? "" : "?:";
      let positives = "";
      let negatives = "";
      let result;
      if (parts.positives.length) {
        positives = parts.positives.join("|");
      }
      if (parts.negatives.length) {
        negatives = `-(${prefix}${parts.negatives.join("|")})`;
      }
      if (positives && negatives) {
        result = `${positives}|${negatives}`;
      } else {
        result = positives || negatives;
      }
      if (options9.wrap) {
        return `(${prefix}${result})`;
      }
      return result;
    };
    var toRange = (a, b, isNumbers, options9) => {
      if (isNumbers) {
        return toRegexRange(a, b, { wrap: false, ...options9 });
      }
      let start = String.fromCharCode(a);
      if (a === b)
        return start;
      let stop = String.fromCharCode(b);
      return `[${start}-${stop}]`;
    };
    var toRegex = (start, end, options9) => {
      if (Array.isArray(start)) {
        let wrap = options9.wrap === true;
        let prefix = options9.capture ? "" : "?:";
        return wrap ? `(${prefix}${start.join("|")})` : start.join("|");
      }
      return toRegexRange(start, end, options9);
    };
    var rangeError = (...args) => {
      return new RangeError("Invalid range arguments: " + util.inspect(...args));
    };
    var invalidRange = (start, end, options9) => {
      if (options9.strictRanges === true)
        throw rangeError([start, end]);
      return [];
    };
    var invalidStep = (step, options9) => {
      if (options9.strictRanges === true) {
        throw new TypeError(`Expected step "${step}" to be a number`);
      }
      return [];
    };
    var fillNumbers = (start, end, step = 1, options9 = {}) => {
      let a = Number(start);
      let b = Number(end);
      if (!Number.isInteger(a) || !Number.isInteger(b)) {
        if (options9.strictRanges === true)
          throw rangeError([start, end]);
        return [];
      }
      if (a === 0)
        a = 0;
      if (b === 0)
        b = 0;
      let descending = a > b;
      let startString = String(start);
      let endString = String(end);
      let stepString = String(step);
      step = Math.max(Math.abs(step), 1);
      let padded = zeros(startString) || zeros(endString) || zeros(stepString);
      let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
      let toNumber = padded === false && stringify2(start, end, options9) === false;
      let format3 = options9.transform || transform2(toNumber);
      if (options9.toRegex && step === 1) {
        return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options9);
      }
      let parts = { negatives: [], positives: [] };
      let push = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
      let range = [];
      let index = 0;
      while (descending ? a >= b : a <= b) {
        if (options9.toRegex === true && step > 1) {
          push(a);
        } else {
          range.push(pad(format3(a, index), maxLen, toNumber));
        }
        a = descending ? a - step : a + step;
        index++;
      }
      if (options9.toRegex === true) {
        return step > 1 ? toSequence(parts, options9) : toRegex(range, null, { wrap: false, ...options9 });
      }
      return range;
    };
    var fillLetters = (start, end, step = 1, options9 = {}) => {
      if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
        return invalidRange(start, end, options9);
      }
      let format3 = options9.transform || ((val) => String.fromCharCode(val));
      let a = `${start}`.charCodeAt(0);
      let b = `${end}`.charCodeAt(0);
      let descending = a > b;
      let min = Math.min(a, b);
      let max = Math.max(a, b);
      if (options9.toRegex && step === 1) {
        return toRange(min, max, false, options9);
      }
      let range = [];
      let index = 0;
      while (descending ? a >= b : a <= b) {
        range.push(format3(a, index));
        a = descending ? a - step : a + step;
        index++;
      }
      if (options9.toRegex === true) {
        return toRegex(range, null, { wrap: false, options: options9 });
      }
      return range;
    };
    var fill2 = (start, end, step, options9 = {}) => {
      if (end == null && isValidValue(start)) {
        return [start];
      }
      if (!isValidValue(start) || !isValidValue(end)) {
        return invalidRange(start, end, options9);
      }
      if (typeof step === "function") {
        return fill2(start, end, 1, { transform: step });
      }
      if (isObject(step)) {
        return fill2(start, end, 0, step);
      }
      let opts = { ...options9 };
      if (opts.capture === true)
        opts.wrap = true;
      step = step || opts.step || 1;
      if (!isNumber(step)) {
        if (step != null && !isObject(step))
          return invalidStep(step, opts);
        return fill2(start, end, 1, step);
      }
      if (isNumber(start) && isNumber(end)) {
        return fillNumbers(start, end, step, opts);
      }
      return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
    };
    module.exports = fill2;
  }
});

// node_modules/braces/lib/compile.js
var require_compile = __commonJS({
  "node_modules/braces/lib/compile.js"(exports, module) {
    "use strict";
    var fill2 = require_fill_range();
    var utils2 = require_utils2();
    var compile = (ast, options9 = {}) => {
      let walk = (node, parent = {}) => {
        let invalidBlock = utils2.isInvalidBrace(parent);
        let invalidNode = node.invalid === true && options9.escapeInvalid === true;
        let invalid = invalidBlock === true || invalidNode === true;
        let prefix = options9.escapeInvalid === true ? "\\" : "";
        let output = "";
        if (node.isOpen === true) {
          return prefix + node.value;
        }
        if (node.isClose === true) {
          return prefix + node.value;
        }
        if (node.type === "open") {
          return invalid ? prefix + node.value : "(";
        }
        if (node.type === "close") {
          return invalid ? prefix + node.value : ")";
        }
        if (node.type === "comma") {
          return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes && node.ranges > 0) {
          let args = utils2.reduce(node.nodes);
          let range = fill2(...args, { ...options9, wrap: false, toRegex: true });
          if (range.length !== 0) {
            return args.length > 1 && range.length > 1 ? `(${range})` : range;
          }
        }
        if (node.nodes) {
          for (let child of node.nodes) {
            output += walk(child, node);
          }
        }
        return output;
      };
      return walk(ast);
    };
    module.exports = compile;
  }
});

// node_modules/braces/lib/expand.js
var require_expand = __commonJS({
  "node_modules/braces/lib/expand.js"(exports, module) {
    "use strict";
    var fill2 = require_fill_range();
    var stringify2 = require_stringify();
    var utils2 = require_utils2();
    var append = (queue = "", stash = "", enclose = false) => {
      let result = [];
      queue = [].concat(queue);
      stash = [].concat(stash);
      if (!stash.length)
        return queue;
      if (!queue.length) {
        return enclose ? utils2.flatten(stash).map((ele) => `{${ele}}`) : stash;
      }
      for (let item of queue) {
        if (Array.isArray(item)) {
          for (let value of item) {
            result.push(append(value, stash, enclose));
          }
        } else {
          for (let ele of stash) {
            if (enclose === true && typeof ele === "string")
              ele = `{${ele}}`;
            result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
          }
        }
      }
      return utils2.flatten(result);
    };
    var expand = (ast, options9 = {}) => {
      let rangeLimit = options9.rangeLimit === void 0 ? 1e3 : options9.rangeLimit;
      let walk = (node, parent = {}) => {
        node.queue = [];
        let p = parent;
        let q = parent.queue;
        while (p.type !== "brace" && p.type !== "root" && p.parent) {
          p = p.parent;
          q = p.queue;
        }
        if (node.invalid || node.dollar) {
          q.push(append(q.pop(), stringify2(node, options9)));
          return;
        }
        if (node.type === "brace" && node.invalid !== true && node.nodes.length === 2) {
          q.push(append(q.pop(), ["{}"]));
          return;
        }
        if (node.nodes && node.ranges > 0) {
          let args = utils2.reduce(node.nodes);
          if (utils2.exceedsLimit(...args, options9.step, rangeLimit)) {
            throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
          }
          let range = fill2(...args, options9);
          if (range.length === 0) {
            range = stringify2(node, options9);
          }
          q.push(append(q.pop(), range));
          node.nodes = [];
          return;
        }
        let enclose = utils2.encloseBrace(node);
        let queue = node.queue;
        let block = node;
        while (block.type !== "brace" && block.type !== "root" && block.parent) {
          block = block.parent;
          queue = block.queue;
        }
        for (let i = 0; i < node.nodes.length; i++) {
          let child = node.nodes[i];
          if (child.type === "comma" && node.type === "brace") {
            if (i === 1)
              queue.push("");
            queue.push("");
            continue;
          }
          if (child.type === "close") {
            q.push(append(q.pop(), queue, enclose));
            continue;
          }
          if (child.value && child.type !== "open") {
            queue.push(append(queue.pop(), child.value));
            continue;
          }
          if (child.nodes) {
            walk(child, node);
          }
        }
        return queue;
      };
      return utils2.flatten(walk(ast));
    };
    module.exports = expand;
  }
});

// node_modules/braces/lib/constants.js
var require_constants = __commonJS({
  "node_modules/braces/lib/constants.js"(exports, module) {
    "use strict";
    module.exports = {
      MAX_LENGTH: 1024 * 64,
      // Digits
      CHAR_0: "0",
      /* 0 */
      CHAR_9: "9",
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: "A",
      /* A */
      CHAR_LOWERCASE_A: "a",
      /* a */
      CHAR_UPPERCASE_Z: "Z",
      /* Z */
      CHAR_LOWERCASE_Z: "z",
      /* z */
      CHAR_LEFT_PARENTHESES: "(",
      /* ( */
      CHAR_RIGHT_PARENTHESES: ")",
      /* ) */
      CHAR_ASTERISK: "*",
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: "&",
      /* & */
      CHAR_AT: "@",
      /* @ */
      CHAR_BACKSLASH: "\\",
      /* \ */
      CHAR_BACKTICK: "`",
      /* ` */
      CHAR_CARRIAGE_RETURN: "\r",
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: "^",
      /* ^ */
      CHAR_COLON: ":",
      /* : */
      CHAR_COMMA: ",",
      /* , */
      CHAR_DOLLAR: "$",
      /* . */
      CHAR_DOT: ".",
      /* . */
      CHAR_DOUBLE_QUOTE: '"',
      /* " */
      CHAR_EQUAL: "=",
      /* = */
      CHAR_EXCLAMATION_MARK: "!",
      /* ! */
      CHAR_FORM_FEED: "\f",
      /* \f */
      CHAR_FORWARD_SLASH: "/",
      /* / */
      CHAR_HASH: "#",
      /* # */
      CHAR_HYPHEN_MINUS: "-",
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: "<",
      /* < */
      CHAR_LEFT_CURLY_BRACE: "{",
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: "[",
      /* [ */
      CHAR_LINE_FEED: "\n",
      /* \n */
      CHAR_NO_BREAK_SPACE: "\xA0",
      /* \u00A0 */
      CHAR_PERCENT: "%",
      /* % */
      CHAR_PLUS: "+",
      /* + */
      CHAR_QUESTION_MARK: "?",
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: ">",
      /* > */
      CHAR_RIGHT_CURLY_BRACE: "}",
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: "]",
      /* ] */
      CHAR_SEMICOLON: ";",
      /* ; */
      CHAR_SINGLE_QUOTE: "'",
      /* ' */
      CHAR_SPACE: " ",
      /*   */
      CHAR_TAB: "	",
      /* \t */
      CHAR_UNDERSCORE: "_",
      /* _ */
      CHAR_VERTICAL_LINE: "|",
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
      /* \uFEFF */
    };
  }
});

// node_modules/braces/lib/parse.js
var require_parse = __commonJS({
  "node_modules/braces/lib/parse.js"(exports, module) {
    "use strict";
    var stringify2 = require_stringify();
    var {
      MAX_LENGTH,
      CHAR_BACKSLASH,
      /* \ */
      CHAR_BACKTICK,
      /* ` */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_RIGHT_SQUARE_BRACKET,
      /* ] */
      CHAR_DOUBLE_QUOTE,
      /* " */
      CHAR_SINGLE_QUOTE,
      /* ' */
      CHAR_NO_BREAK_SPACE,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE
    } = require_constants();
    var parse4 = (input, options9 = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      let opts = options9 || {};
      let max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      if (input.length > max) {
        throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
      }
      let ast = { type: "root", input, nodes: [] };
      let stack = [ast];
      let block = ast;
      let prev = ast;
      let brackets = 0;
      let length = input.length;
      let index = 0;
      let depth = 0;
      let value;
      let memo = {};
      const advance = () => input[index++];
      const push = (node) => {
        if (node.type === "text" && prev.type === "dot") {
          prev.type = "text";
        }
        if (prev && prev.type === "text" && node.type === "text") {
          prev.value += node.value;
          return;
        }
        block.nodes.push(node);
        node.parent = block;
        node.prev = prev;
        prev = node;
        return node;
      };
      push({ type: "bos" });
      while (index < length) {
        block = stack[stack.length - 1];
        value = advance();
        if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
          continue;
        }
        if (value === CHAR_BACKSLASH) {
          push({ type: "text", value: (options9.keepEscaping ? value : "") + advance() });
          continue;
        }
        if (value === CHAR_RIGHT_SQUARE_BRACKET) {
          push({ type: "text", value: "\\" + value });
          continue;
        }
        if (value === CHAR_LEFT_SQUARE_BRACKET) {
          brackets++;
          let closed = true;
          let next;
          while (index < length && (next = advance())) {
            value += next;
            if (next === CHAR_LEFT_SQUARE_BRACKET) {
              brackets++;
              continue;
            }
            if (next === CHAR_BACKSLASH) {
              value += advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              brackets--;
              if (brackets === 0) {
                break;
              }
            }
          }
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_PARENTHESES) {
          block = push({ type: "paren", nodes: [] });
          stack.push(block);
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_RIGHT_PARENTHESES) {
          if (block.type !== "paren") {
            push({ type: "text", value });
            continue;
          }
          block = stack.pop();
          push({ type: "text", value });
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
          let open = value;
          let next;
          if (options9.keepQuotes !== true) {
            value = "";
          }
          while (index < length && (next = advance())) {
            if (next === CHAR_BACKSLASH) {
              value += next + advance();
              continue;
            }
            if (next === open) {
              if (options9.keepQuotes === true)
                value += next;
              break;
            }
            value += next;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_CURLY_BRACE) {
          depth++;
          let dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
          let brace = {
            type: "brace",
            open: true,
            close: false,
            dollar,
            depth,
            commas: 0,
            ranges: 0,
            nodes: []
          };
          block = push(brace);
          stack.push(block);
          push({ type: "open", value });
          continue;
        }
        if (value === CHAR_RIGHT_CURLY_BRACE) {
          if (block.type !== "brace") {
            push({ type: "text", value });
            continue;
          }
          let type = "close";
          block = stack.pop();
          block.close = true;
          push({ type, value });
          depth--;
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_COMMA && depth > 0) {
          if (block.ranges > 0) {
            block.ranges = 0;
            let open = block.nodes.shift();
            block.nodes = [open, { type: "text", value: stringify2(block) }];
          }
          push({ type: "comma", value });
          block.commas++;
          continue;
        }
        if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
          let siblings = block.nodes;
          if (depth === 0 || siblings.length === 0) {
            push({ type: "text", value });
            continue;
          }
          if (prev.type === "dot") {
            block.range = [];
            prev.value += value;
            prev.type = "range";
            if (block.nodes.length !== 3 && block.nodes.length !== 5) {
              block.invalid = true;
              block.ranges = 0;
              prev.type = "text";
              continue;
            }
            block.ranges++;
            block.args = [];
            continue;
          }
          if (prev.type === "range") {
            siblings.pop();
            let before = siblings[siblings.length - 1];
            before.value += prev.value + value;
            prev = before;
            block.ranges--;
            continue;
          }
          push({ type: "dot", value });
          continue;
        }
        push({ type: "text", value });
      }
      do {
        block = stack.pop();
        if (block.type !== "root") {
          block.nodes.forEach((node) => {
            if (!node.nodes) {
              if (node.type === "open")
                node.isOpen = true;
              if (node.type === "close")
                node.isClose = true;
              if (!node.nodes)
                node.type = "text";
              node.invalid = true;
            }
          });
          let parent = stack[stack.length - 1];
          let index2 = parent.nodes.indexOf(block);
          parent.nodes.splice(index2, 1, ...block.nodes);
        }
      } while (stack.length > 0);
      push({ type: "eos" });
      return ast;
    };
    module.exports = parse4;
  }
});

// node_modules/braces/index.js
var require_braces = __commonJS({
  "node_modules/braces/index.js"(exports, module) {
    "use strict";
    var stringify2 = require_stringify();
    var compile = require_compile();
    var expand = require_expand();
    var parse4 = require_parse();
    var braces = (input, options9 = {}) => {
      let output = [];
      if (Array.isArray(input)) {
        for (let pattern of input) {
          let result = braces.create(pattern, options9);
          if (Array.isArray(result)) {
            output.push(...result);
          } else {
            output.push(result);
          }
        }
      } else {
        output = [].concat(braces.create(input, options9));
      }
      if (options9 && options9.expand === true && options9.nodupes === true) {
        output = [...new Set(output)];
      }
      return output;
    };
    braces.parse = (input, options9 = {}) => parse4(input, options9);
    braces.stringify = (input, options9 = {}) => {
      if (typeof input === "string") {
        return stringify2(braces.parse(input, options9), options9);
      }
      return stringify2(input, options9);
    };
    braces.compile = (input, options9 = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options9);
      }
      return compile(input, options9);
    };
    braces.expand = (input, options9 = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options9);
      }
      let result = expand(input, options9);
      if (options9.noempty === true) {
        result = result.filter(Boolean);
      }
      if (options9.nodupes === true) {
        result = [...new Set(result)];
      }
      return result;
    };
    braces.create = (input, options9 = {}) => {
      if (input === "" || input.length < 3) {
        return [input];
      }
      return options9.expand !== true ? braces.compile(input, options9) : braces.expand(input, options9);
    };
    module.exports = braces;
  }
});

// node_modules/picomatch/lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/picomatch/lib/constants.js"(exports, module) {
    "use strict";
    var path11 = __require("path");
    var WIN_SLASH = "\\\\/";
    var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    var DOT_LITERAL = "\\.";
    var PLUS_LITERAL = "\\+";
    var QMARK_LITERAL = "\\?";
    var SLASH_LITERAL = "\\/";
    var ONE_CHAR = "(?=.)";
    var QMARK = "[^/]";
    var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    var NO_DOT = `(?!${DOT_LITERAL})`;
    var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    var STAR = `${QMARK}*?`;
    var POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    };
    var WINDOWS_CHARS = {
      ...POSIX_CHARS,
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
    };
    var POSIX_REGEX_SOURCE = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    module.exports = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE,
      // regular expressions
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      // Replace globs with equivalent patterns to reduce parsing time.
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      // Digits
      CHAR_0: 48,
      /* 0 */
      CHAR_9: 57,
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: 65,
      /* A */
      CHAR_LOWERCASE_A: 97,
      /* a */
      CHAR_UPPERCASE_Z: 90,
      /* Z */
      CHAR_LOWERCASE_Z: 122,
      /* z */
      CHAR_LEFT_PARENTHESES: 40,
      /* ( */
      CHAR_RIGHT_PARENTHESES: 41,
      /* ) */
      CHAR_ASTERISK: 42,
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: 38,
      /* & */
      CHAR_AT: 64,
      /* @ */
      CHAR_BACKWARD_SLASH: 92,
      /* \ */
      CHAR_CARRIAGE_RETURN: 13,
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: 94,
      /* ^ */
      CHAR_COLON: 58,
      /* : */
      CHAR_COMMA: 44,
      /* , */
      CHAR_DOT: 46,
      /* . */
      CHAR_DOUBLE_QUOTE: 34,
      /* " */
      CHAR_EQUAL: 61,
      /* = */
      CHAR_EXCLAMATION_MARK: 33,
      /* ! */
      CHAR_FORM_FEED: 12,
      /* \f */
      CHAR_FORWARD_SLASH: 47,
      /* / */
      CHAR_GRAVE_ACCENT: 96,
      /* ` */
      CHAR_HASH: 35,
      /* # */
      CHAR_HYPHEN_MINUS: 45,
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: 60,
      /* < */
      CHAR_LEFT_CURLY_BRACE: 123,
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: 91,
      /* [ */
      CHAR_LINE_FEED: 10,
      /* \n */
      CHAR_NO_BREAK_SPACE: 160,
      /* \u00A0 */
      CHAR_PERCENT: 37,
      /* % */
      CHAR_PLUS: 43,
      /* + */
      CHAR_QUESTION_MARK: 63,
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      /* > */
      CHAR_RIGHT_CURLY_BRACE: 125,
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      /* ] */
      CHAR_SEMICOLON: 59,
      /* ; */
      CHAR_SINGLE_QUOTE: 39,
      /* ' */
      CHAR_SPACE: 32,
      /*   */
      CHAR_TAB: 9,
      /* \t */
      CHAR_UNDERSCORE: 95,
      /* _ */
      CHAR_VERTICAL_LINE: 124,
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      /* \uFEFF */
      SEP: path11.sep,
      /**
       * Create EXTGLOB_CHARS
       */
      extglobChars(chars) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      /**
       * Create GLOB_CHARS
       */
      globChars(win32) {
        return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
  }
});

// node_modules/picomatch/lib/utils.js
var require_utils3 = __commonJS({
  "node_modules/picomatch/lib/utils.js"(exports) {
    "use strict";
    var path11 = __require("path");
    var win32 = process.platform === "win32";
    var {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = require_constants2();
    exports.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    exports.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
    exports.isRegexChar = (str) => str.length === 1 && exports.hasRegexChars(str);
    exports.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
    exports.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
    exports.removeBackslashes = (str) => {
      return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
        return match === "\\" ? "" : match;
      });
    };
    exports.supportsLookbehinds = () => {
      const segs = process.version.slice(1).split(".").map(Number);
      if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
        return true;
      }
      return false;
    };
    exports.isWindows = (options9) => {
      if (options9 && typeof options9.windows === "boolean") {
        return options9.windows;
      }
      return win32 === true || path11.sep === "\\";
    };
    exports.escapeLast = (input, char, lastIdx) => {
      const idx = input.lastIndexOf(char, lastIdx);
      if (idx === -1)
        return input;
      if (input[idx - 1] === "\\")
        return exports.escapeLast(input, char, idx - 1);
      return `${input.slice(0, idx)}\\${input.slice(idx)}`;
    };
    exports.removePrefix = (input, state = {}) => {
      let output = input;
      if (output.startsWith("./")) {
        output = output.slice(2);
        state.prefix = "./";
      }
      return output;
    };
    exports.wrapOutput = (input, state = {}, options9 = {}) => {
      const prepend = options9.contains ? "" : "^";
      const append = options9.contains ? "" : "$";
      let output = `${prepend}(?:${input})${append}`;
      if (state.negated === true) {
        output = `(?:^(?!${output}).*$)`;
      }
      return output;
    };
  }
});

// node_modules/picomatch/lib/scan.js
var require_scan = __commonJS({
  "node_modules/picomatch/lib/scan.js"(exports, module) {
    "use strict";
    var utils2 = require_utils3();
    var {
      CHAR_ASTERISK,
      /* * */
      CHAR_AT,
      /* @ */
      CHAR_BACKWARD_SLASH,
      /* \ */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_EXCLAMATION_MARK,
      /* ! */
      CHAR_FORWARD_SLASH,
      /* / */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_PLUS,
      /* + */
      CHAR_QUESTION_MARK,
      /* ? */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_RIGHT_SQUARE_BRACKET
      /* ] */
    } = require_constants2();
    var isPathSeparator = (code) => {
      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
    };
    var depth = (token) => {
      if (token.isPrefix !== true) {
        token.depth = token.isGlobstar ? Infinity : 1;
      }
    };
    var scan = (input, options9) => {
      const opts = options9 || {};
      const length = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str = input;
      let index = -1;
      let start = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob = false;
      let isExtglob = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces = 0;
      let prev;
      let code;
      let token = { value: "", depth: 0, isGlob: false };
      const eos = () => index >= length;
      const peek = () => str.charCodeAt(index + 1);
      const advance = () => {
        prev = code;
        return str.charCodeAt(++index);
      };
      while (index < length) {
        code = advance();
        let next;
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          code = advance();
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braces++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE) {
              braces--;
              if (braces === 0) {
                braceEscaped = false;
                isBrace = token.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH) {
          slashes.push(index);
          tokens.push(token);
          token = { value: "", depth: 0, isGlob: false };
          if (finished === true)
            continue;
          if (prev === CHAR_DOT && index === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            isExtglob = token.isExtglob = true;
            finished = true;
            if (code === CHAR_EXCLAMATION_MARK && index === start) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_BACKWARD_SLASH) {
                  backslashes = token.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  isGlob = token.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK)
            isGlobstar = token.isGlobstar = true;
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
          while (eos() !== true && (next = advance())) {
            if (next === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token.isBracket = true;
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
          negated = token.negated = true;
          start++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
          isGlob = token.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_LEFT_PARENTHESES) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
      }
      let base = str;
      let prefix = "";
      let glob = "";
      if (start > 0) {
        prefix = str.slice(0, start);
        str = str.slice(start);
        lastIndex -= start;
      }
      if (base && isGlob === true && lastIndex > 0) {
        base = str.slice(0, lastIndex);
        glob = str.slice(lastIndex);
      } else if (isGlob === true) {
        base = "";
        glob = str;
      } else {
        base = str;
      }
      if (base && base !== "" && base !== "/" && base !== str) {
        if (isPathSeparator(base.charCodeAt(base.length - 1))) {
          base = base.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob)
          glob = utils2.removeBackslashes(glob);
        if (base && backslashes === true) {
          base = utils2.removeBackslashes(base);
        }
      }
      const state = {
        prefix,
        input,
        start,
        base,
        glob,
        isBrace,
        isBracket,
        isGlob,
        isExtglob,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator(code)) {
          tokens.push(token);
        }
        state.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n = prevIndex ? prevIndex + 1 : start;
          const i = slashes[idx];
          const value = input.slice(n, i);
          if (opts.tokens) {
            if (idx === 0 && start !== 0) {
              tokens[idx].isPrefix = true;
              tokens[idx].value = prefix;
            } else {
              tokens[idx].value = value;
            }
            depth(tokens[idx]);
            state.maxDepth += tokens[idx].depth;
          }
          if (idx !== 0 || value !== "") {
            parts.push(value);
          }
          prevIndex = i;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value = input.slice(prevIndex + 1);
          parts.push(value);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value;
            depth(tokens[tokens.length - 1]);
            state.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state.slashes = slashes;
        state.parts = parts;
      }
      return state;
    };
    module.exports = scan;
  }
});

// node_modules/picomatch/lib/parse.js
var require_parse2 = __commonJS({
  "node_modules/picomatch/lib/parse.js"(exports, module) {
    "use strict";
    var constants = require_constants2();
    var utils2 = require_utils3();
    var {
      MAX_LENGTH,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants;
    var expandRange = (args, options9) => {
      if (typeof options9.expandRange === "function") {
        return options9.expandRange(...args, options9);
      }
      args.sort();
      const value = `[${args.join("-")}]`;
      try {
        new RegExp(value);
      } catch (ex) {
        return args.map((v) => utils2.escapeRegex(v)).join("..");
      }
      return value;
    };
    var syntaxError = (type, char) => {
      return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    var parse4 = (input, options9) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS[input] || input;
      const opts = { ...options9 };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      let len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      const bos = { type: "bos", value: "", output: opts.prepend || "" };
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const win32 = utils2.isWindows(options9);
      const PLATFORM_CHARS = constants.globChars(win32);
      const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL,
        PLUS_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT;
      const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
      let star = opts.bash === true ? globstar(opts) : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils2.removePrefix(input, state);
      len = input.length;
      const extglobs = [];
      const braces = [];
      const stack = [];
      let prev = bos;
      let value;
      const eos = () => state.index === len - 1;
      const peek = state.peek = (n = 1) => input[state.index + n];
      const advance = state.advance = () => input[++state.index] || "";
      const remaining = () => input.slice(state.index + 1);
      const consume = (value2 = "", num = 0) => {
        state.consumed += value2;
        state.index += num;
      };
      const append = (token) => {
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
      };
      const negate = () => {
        let count = 1;
        while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
          advance();
          state.start++;
          count++;
        }
        if (count % 2 === 0) {
          return false;
        }
        state.negated = true;
        state.start++;
        return true;
      };
      const increment = (type) => {
        state[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state[type]--;
        stack.pop();
      };
      const push = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star;
            state.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output)
          append(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.value += tok.value;
          prev.output = (prev.output || "") + tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value2) => {
        const token = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? "(" : "") + token.open;
        increment("parens");
        push({ type, value: value2, output: state.output ? "" : ONE_CHAR });
        push({ type: "paren", extglob: true, value: advance(), output });
        extglobs.push(token);
      };
      const extglobClose = (token) => {
        let output = token.close + (opts.capture ? ")" : "");
        let rest;
        if (token.type === "negate") {
          let extglobStar = star;
          if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
            output = token.close = `)$))${extglobStar}`;
          }
          if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
            const expression = parse4(rest, { ...options9, fastpaths: false }).output;
            output = token.close = `)${expression})${extglobStar})`;
          }
          if (token.prev.type === "bos") {
            state.negatedExtglob = true;
          }
        }
        push({ type: "paren", extglob: true, value, output });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
          if (first === "\\") {
            backslashes = true;
            return m;
          }
          if (first === "?") {
            if (esc) {
              return esc + first + (rest ? QMARK.repeat(rest.length) : "");
            }
            if (index === 0) {
              return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
            }
            return QMARK.repeat(chars.length);
          }
          if (first === ".") {
            return DOT_LITERAL.repeat(chars.length);
          }
          if (first === "*") {
            if (esc) {
              return esc + first + (rest ? star : "");
            }
            return star;
          }
          return esc ? m : `\\${m}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m) => {
              return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
            });
          }
        }
        if (output === input && opts.contains === true) {
          state.output = input;
          return state;
        }
        state.output = utils2.wrapOutput(output, state, options9);
        return state;
      }
      while (!eos()) {
        value = advance();
        if (value === "\0") {
          continue;
        }
        if (value === "\\") {
          const next = peek();
          if (next === "/" && opts.bash !== true) {
            continue;
          }
          if (next === "." || next === ";") {
            continue;
          }
          if (!next) {
            value += "\\";
            push({ type: "text", value });
            continue;
          }
          const match = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match && match[0].length > 2) {
            slashes = match[0].length;
            state.index += slashes;
            if (slashes % 2 !== 0) {
              value += "\\";
            }
          }
          if (opts.unescape === true) {
            value = advance();
          } else {
            value += advance();
          }
          if (state.brackets === 0) {
            push({ type: "text", value });
            continue;
          }
        }
        if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest2 = prev.value.slice(idx + 2);
                const posix = POSIX_REGEX_SOURCE[rest2];
                if (posix) {
                  prev.value = pre + posix;
                  state.backtrack = true;
                  advance();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR;
                  }
                  continue;
                }
              }
            }
          }
          if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
            value = `\\${value}`;
          }
          if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
            value = `\\${value}`;
          }
          if (opts.posix === true && value === "!" && prev.value === "[") {
            value = "^";
          }
          prev.value += value;
          append({ value });
          continue;
        }
        if (state.quotes === 1 && value !== '"') {
          value = utils2.escapeRegex(value);
          prev.value += value;
          append({ value });
          continue;
        }
        if (value === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push({ type: "text", value });
          }
          continue;
        }
        if (value === "(") {
          increment("parens");
          push({ type: "paren", value });
          continue;
        }
        if (value === ")") {
          if (state.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push({ type: "paren", value, output: state.parens ? ")" : "\\)" });
          decrement("parens");
          continue;
        }
        if (value === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("closing", "]"));
            }
            value = `\\${value}`;
          } else {
            increment("brackets");
          }
          push({ type: "bracket", value });
          continue;
        }
        if (value === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "["));
            }
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value = `/${value}`;
          }
          prev.value += value;
          append({ value });
          if (opts.literalBrackets === false || utils2.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped = utils2.escapeRegex(prev.value);
          state.output = state.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state.output += escaped;
            prev.value = escaped;
            continue;
          }
          prev.value = `(${capture}${escaped}|${prev.value})`;
          state.output += prev.value;
          continue;
        }
        if (value === "{" && opts.nobrace !== true) {
          increment("braces");
          const open = {
            type: "brace",
            value,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces.push(open);
          push(open);
          continue;
        }
        if (value === "}") {
          const brace = braces[braces.length - 1];
          if (opts.nobrace === true || !brace) {
            push({ type: "text", value, output: value });
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range = [];
            for (let i = arr.length - 1; i >= 0; i--) {
              tokens.pop();
              if (arr[i].type === "brace") {
                break;
              }
              if (arr[i].type !== "dots") {
                range.unshift(arr[i].value);
              }
            }
            output = expandRange(range, opts);
            state.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out = state.output.slice(0, brace.outputIndex);
            const toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value = output = "\\}";
            state.output = out;
            for (const t of toks) {
              state.output += t.output || t.value;
            }
          }
          push({ type: "brace", value, output });
          decrement("braces");
          braces.pop();
          continue;
        }
        if (value === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === ",") {
          let output = value;
          const brace = braces[braces.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push({ type: "comma", value, output });
          continue;
        }
        if (value === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1;
            state.consumed = "";
            state.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push({ type: "slash", value, output: SLASH_LITERAL });
          continue;
        }
        if (value === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            if (prev.value === ".")
              prev.output = DOT_LITERAL;
            const brace = braces[braces.length - 1];
            prev.type = "dots";
            prev.output += value;
            prev.value += value;
            brace.dots = true;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push({ type: "text", value, output: DOT_LITERAL });
            continue;
          }
          push({ type: "dot", value, output: DOT_LITERAL });
          continue;
        }
        if (value === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("qmark", value);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek();
            let output = value;
            if (next === "<" && !utils2.supportsLookbehinds()) {
              throw new Error("Node.js v10 or higher is required for regex lookbehinds");
            }
            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value}`;
            }
            push({ type: "text", value, output });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push({ type: "qmark", value, output: QMARK_NO_DOT });
            continue;
          }
          push({ type: "qmark", value, output: QMARK });
          continue;
        }
        if (value === "!") {
          if (opts.noextglob !== true && peek() === "(") {
            if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
              extglobOpen("negate", value);
              continue;
            }
          }
          if (opts.nonegate !== true && state.index === 0) {
            negate();
            continue;
          }
        }
        if (value === "+") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("plus", value);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push({ type: "plus", value, output: PLUS_LITERAL });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push({ type: "plus", value });
            continue;
          }
          push({ type: "plus", value: PLUS_LITERAL });
          continue;
        }
        if (value === "@") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            push({ type: "at", extglob: true, value, output: "" });
            continue;
          }
          push({ type: "text", value });
          continue;
        }
        if (value !== "*") {
          if (value === "$" || value === "^") {
            value = `\\${value}`;
          }
          const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          if (match) {
            value += match[0];
            state.index += match[0].length;
          }
          push({ type: "text", value });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value;
          prev.output = star;
          state.backtrack = true;
          state.globstar = true;
          consume(value);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
          extglobOpen("star", value);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
            push({ type: "star", value, output: "" });
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
            push({ type: "star", value, output: "" });
            continue;
          }
          while (rest.slice(0, 3) === "/**") {
            const after = input[state.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest = rest.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value;
            prev.output = globstar(opts);
            state.output = prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value;
            state.globstar = true;
            state.output += prior.output + prev.output;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
            prev.value += value;
            state.output += prior.output + prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar";
            prev.value += value;
            prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
            state.output = prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value;
          state.output += prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }
        const token = { type: "star", value, output: star };
        if (opts.bash === true) {
          token.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token.output = nodot + token.output;
          }
          push(token);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token.output = value;
          push(token);
          continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state.output += NO_DOT_SLASH;
            prev.output += NO_DOT_SLASH;
          } else if (opts.dot === true) {
            state.output += NO_DOTS_SLASH;
            prev.output += NO_DOTS_SLASH;
          } else {
            state.output += nodot;
            prev.output += nodot;
          }
          if (peek() !== "*") {
            state.output += ONE_CHAR;
            prev.output += ONE_CHAR;
          }
        }
        push(token);
      }
      while (state.brackets > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "]"));
        state.output = utils2.escapeLast(state.output, "[");
        decrement("brackets");
      }
      while (state.parens > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", ")"));
        state.output = utils2.escapeLast(state.output, "(");
        decrement("parens");
      }
      while (state.braces > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "}"));
        state.output = utils2.escapeLast(state.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
      }
      if (state.backtrack === true) {
        state.output = "";
        for (const token of state.tokens) {
          state.output += token.output != null ? token.output : token.value;
          if (token.suffix) {
            state.output += token.suffix;
          }
        }
      }
      return state;
    };
    parse4.fastpaths = (input, options9) => {
      const opts = { ...options9 };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      const len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      input = REPLACEMENTS[input] || input;
      const win32 = utils2.isWindows(options9);
      const {
        DOT_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOTS_SLASH,
        STAR,
        START_ANCHOR
      } = constants.globChars(win32);
      const nodot = opts.dot ? NO_DOTS : NO_DOT;
      const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
      const capture = opts.capture ? "" : "?:";
      const state = { negated: false, prefix: "" };
      let star = opts.bash === true ? ".*?" : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true)
          return star;
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const create = (str) => {
        switch (str) {
          case "*":
            return `${nodot}${ONE_CHAR}${star}`;
          case ".*":
            return `${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*.*":
            return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*/*":
            return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
          default: {
            const match = /^(.*?)\.(\w+)$/.exec(str);
            if (!match)
              return;
            const source2 = create(match[1]);
            if (!source2)
              return;
            return source2 + DOT_LITERAL + match[2];
          }
        }
      };
      const output = utils2.removePrefix(input, state);
      let source = create(output);
      if (source && opts.strictSlashes !== true) {
        source += `${SLASH_LITERAL}?`;
      }
      return source;
    };
    module.exports = parse4;
  }
});

// node_modules/picomatch/lib/picomatch.js
var require_picomatch = __commonJS({
  "node_modules/picomatch/lib/picomatch.js"(exports, module) {
    "use strict";
    var path11 = __require("path");
    var scan = require_scan();
    var parse4 = require_parse2();
    var utils2 = require_utils3();
    var constants = require_constants2();
    var isObject = (val) => val && typeof val === "object" && !Array.isArray(val);
    var picomatch = (glob, options9, returnState = false) => {
      if (Array.isArray(glob)) {
        const fns = glob.map((input) => picomatch(input, options9, returnState));
        const arrayMatcher = (str) => {
          for (const isMatch of fns) {
            const state2 = isMatch(str);
            if (state2)
              return state2;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject(glob) && glob.tokens && glob.input;
      if (glob === "" || typeof glob !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options9 || {};
      const posix = utils2.isWindows(options9);
      const regex = isState ? picomatch.compileRe(glob, options9) : picomatch.makeRe(glob, options9, false, true);
      const state = regex.state;
      delete regex.state;
      let isIgnored2 = () => false;
      if (opts.ignore) {
        const ignoreOpts = { ...options9, ignore: null, onMatch: null, onResult: null };
        isIgnored2 = picomatch(opts.ignore, ignoreOpts, returnState);
      }
      const matcher = (input, returnObject = false) => {
        const { isMatch, match, output } = picomatch.test(input, regex, options9, { glob, posix });
        const result = { glob, state, regex, posix, input, output, match, isMatch };
        if (typeof opts.onResult === "function") {
          opts.onResult(result);
        }
        if (isMatch === false) {
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (isIgnored2(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result);
          }
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result);
        }
        return returnObject ? result : true;
      };
      if (returnState) {
        matcher.state = state;
      }
      return matcher;
    };
    picomatch.test = (input, regex, options9, { glob, posix } = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return { isMatch: false, output: "" };
      }
      const opts = options9 || {};
      const format3 = opts.format || (posix ? utils2.toPosixSlashes : null);
      let match = input === glob;
      let output = match && format3 ? format3(input) : input;
      if (match === false) {
        output = format3 ? format3(input) : input;
        match = output === glob;
      }
      if (match === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match = picomatch.matchBase(input, regex, options9, posix);
        } else {
          match = regex.exec(output);
        }
      }
      return { isMatch: Boolean(match), match, output };
    };
    picomatch.matchBase = (input, glob, options9, posix = utils2.isWindows(options9)) => {
      const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options9);
      return regex.test(path11.basename(input));
    };
    picomatch.isMatch = (str, patterns, options9) => picomatch(patterns, options9)(str);
    picomatch.parse = (pattern, options9) => {
      if (Array.isArray(pattern))
        return pattern.map((p) => picomatch.parse(p, options9));
      return parse4(pattern, { ...options9, fastpaths: false });
    };
    picomatch.scan = (input, options9) => scan(input, options9);
    picomatch.compileRe = (state, options9, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state.output;
      }
      const opts = options9 || {};
      const prepend = opts.contains ? "" : "^";
      const append = opts.contains ? "" : "$";
      let source = `${prepend}(?:${state.output})${append}`;
      if (state && state.negated === true) {
        source = `^(?!${source}).*$`;
      }
      const regex = picomatch.toRegex(source, options9);
      if (returnState === true) {
        regex.state = state;
      }
      return regex;
    };
    picomatch.makeRe = (input, options9 = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = { negated: false, fastpaths: true };
      if (options9.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse4.fastpaths(input, options9);
      }
      if (!parsed.output) {
        parsed = parse4(input, options9);
      }
      return picomatch.compileRe(parsed, options9, returnOutput, returnState);
    };
    picomatch.toRegex = (source, options9) => {
      try {
        const opts = options9 || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options9 && options9.debug === true)
          throw err;
        return /$^/;
      }
    };
    picomatch.constants = constants;
    module.exports = picomatch;
  }
});

// node_modules/picomatch/index.js
var require_picomatch2 = __commonJS({
  "node_modules/picomatch/index.js"(exports, module) {
    "use strict";
    module.exports = require_picomatch();
  }
});

// node_modules/micromatch/index.js
var require_micromatch = __commonJS({
  "node_modules/micromatch/index.js"(exports, module) {
    "use strict";
    var util = __require("util");
    var braces = require_braces();
    var picomatch = require_picomatch2();
    var utils2 = require_utils3();
    var isEmptyString = (val) => val === "" || val === "./";
    var micromatch2 = (list, patterns, options9) => {
      patterns = [].concat(patterns);
      list = [].concat(list);
      let omit = /* @__PURE__ */ new Set();
      let keep = /* @__PURE__ */ new Set();
      let items = /* @__PURE__ */ new Set();
      let negatives = 0;
      let onResult = (state) => {
        items.add(state.output);
        if (options9 && options9.onResult) {
          options9.onResult(state);
        }
      };
      for (let i = 0; i < patterns.length; i++) {
        let isMatch = picomatch(String(patterns[i]), { ...options9, onResult }, true);
        let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
        if (negated)
          negatives++;
        for (let item of list) {
          let matched = isMatch(item, true);
          let match = negated ? !matched.isMatch : matched.isMatch;
          if (!match)
            continue;
          if (negated) {
            omit.add(matched.output);
          } else {
            omit.delete(matched.output);
            keep.add(matched.output);
          }
        }
      }
      let result = negatives === patterns.length ? [...items] : [...keep];
      let matches = result.filter((item) => !omit.has(item));
      if (options9 && matches.length === 0) {
        if (options9.failglob === true) {
          throw new Error(`No matches found for "${patterns.join(", ")}"`);
        }
        if (options9.nonull === true || options9.nullglob === true) {
          return options9.unescape ? patterns.map((p) => p.replace(/\\/g, "")) : patterns;
        }
      }
      return matches;
    };
    micromatch2.match = micromatch2;
    micromatch2.matcher = (pattern, options9) => picomatch(pattern, options9);
    micromatch2.isMatch = (str, patterns, options9) => picomatch(patterns, options9)(str);
    micromatch2.any = micromatch2.isMatch;
    micromatch2.not = (list, patterns, options9 = {}) => {
      patterns = [].concat(patterns).map(String);
      let result = /* @__PURE__ */ new Set();
      let items = [];
      let onResult = (state) => {
        if (options9.onResult)
          options9.onResult(state);
        items.push(state.output);
      };
      let matches = new Set(micromatch2(list, patterns, { ...options9, onResult }));
      for (let item of items) {
        if (!matches.has(item)) {
          result.add(item);
        }
      }
      return [...result];
    };
    micromatch2.contains = (str, pattern, options9) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
      }
      if (Array.isArray(pattern)) {
        return pattern.some((p) => micromatch2.contains(str, p, options9));
      }
      if (typeof pattern === "string") {
        if (isEmptyString(str) || isEmptyString(pattern)) {
          return false;
        }
        if (str.includes(pattern) || str.startsWith("./") && str.slice(2).includes(pattern)) {
          return true;
        }
      }
      return micromatch2.isMatch(str, pattern, { ...options9, contains: true });
    };
    micromatch2.matchKeys = (obj, patterns, options9) => {
      if (!utils2.isObject(obj)) {
        throw new TypeError("Expected the first argument to be an object");
      }
      let keys = micromatch2(Object.keys(obj), patterns, options9);
      let res = {};
      for (let key of keys)
        res[key] = obj[key];
      return res;
    };
    micromatch2.some = (list, patterns, options9) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options9);
        if (items.some((item) => isMatch(item))) {
          return true;
        }
      }
      return false;
    };
    micromatch2.every = (list, patterns, options9) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options9);
        if (!items.every((item) => isMatch(item))) {
          return false;
        }
      }
      return true;
    };
    micromatch2.all = (str, patterns, options9) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
      }
      return [].concat(patterns).every((p) => picomatch(p, options9)(str));
    };
    micromatch2.capture = (glob, input, options9) => {
      let posix = utils2.isWindows(options9);
      let regex = picomatch.makeRe(String(glob), { ...options9, capture: true });
      let match = regex.exec(posix ? utils2.toPosixSlashes(input) : input);
      if (match) {
        return match.slice(1).map((v) => v === void 0 ? "" : v);
      }
    };
    micromatch2.makeRe = (...args) => picomatch.makeRe(...args);
    micromatch2.scan = (...args) => picomatch.scan(...args);
    micromatch2.parse = (patterns, options9) => {
      let res = [];
      for (let pattern of [].concat(patterns || [])) {
        for (let str of braces(String(pattern), options9)) {
          res.push(picomatch.parse(str, options9));
        }
      }
      return res;
    };
    micromatch2.braces = (pattern, options9) => {
      if (typeof pattern !== "string")
        throw new TypeError("Expected a string");
      if (options9 && options9.nobrace === true || !/\{.*\}/.test(pattern)) {
        return [pattern];
      }
      return braces(pattern, options9);
    };
    micromatch2.braceExpand = (pattern, options9) => {
      if (typeof pattern !== "string")
        throw new TypeError("Expected a string");
      return micromatch2.braces(pattern, { ...options9, expand: true });
    };
    module.exports = micromatch2;
  }
});

// node_modules/fast-glob/out/utils/pattern.js
var require_pattern = __commonJS({
  "node_modules/fast-glob/out/utils/pattern.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.matchAny = exports.convertPatternsToRe = exports.makeRe = exports.getPatternParts = exports.expandBraceExpansion = exports.expandPatternsWithBraceExpansion = exports.isAffectDepthOfReadingPattern = exports.endsWithSlashGlobStar = exports.hasGlobStar = exports.getBaseDirectory = exports.isPatternRelatedToParentDirectory = exports.getPatternsOutsideCurrentDirectory = exports.getPatternsInsideCurrentDirectory = exports.getPositivePatterns = exports.getNegativePatterns = exports.isPositivePattern = exports.isNegativePattern = exports.convertToNegativePattern = exports.convertToPositivePattern = exports.isDynamicPattern = exports.isStaticPattern = void 0;
    var path11 = __require("path");
    var globParent = require_glob_parent();
    var micromatch2 = require_micromatch();
    var GLOBSTAR = "**";
    var ESCAPE_SYMBOL = "\\";
    var COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;
    var REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[[^[]*]/;
    var REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\([^(]*\|[^|]*\)/;
    var GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\([^(]*\)/;
    var BRACE_EXPANSION_SEPARATORS_RE = /,|\.\./;
    function isStaticPattern(pattern, options9 = {}) {
      return !isDynamicPattern(pattern, options9);
    }
    exports.isStaticPattern = isStaticPattern;
    function isDynamicPattern(pattern, options9 = {}) {
      if (pattern === "") {
        return false;
      }
      if (options9.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {
        return true;
      }
      if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {
        return true;
      }
      if (options9.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {
        return true;
      }
      if (options9.braceExpansion !== false && hasBraceExpansion(pattern)) {
        return true;
      }
      return false;
    }
    exports.isDynamicPattern = isDynamicPattern;
    function hasBraceExpansion(pattern) {
      const openingBraceIndex = pattern.indexOf("{");
      if (openingBraceIndex === -1) {
        return false;
      }
      const closingBraceIndex = pattern.indexOf("}", openingBraceIndex + 1);
      if (closingBraceIndex === -1) {
        return false;
      }
      const braceContent = pattern.slice(openingBraceIndex, closingBraceIndex);
      return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);
    }
    function convertToPositivePattern(pattern) {
      return isNegativePattern(pattern) ? pattern.slice(1) : pattern;
    }
    exports.convertToPositivePattern = convertToPositivePattern;
    function convertToNegativePattern(pattern) {
      return "!" + pattern;
    }
    exports.convertToNegativePattern = convertToNegativePattern;
    function isNegativePattern(pattern) {
      return pattern.startsWith("!") && pattern[1] !== "(";
    }
    exports.isNegativePattern = isNegativePattern;
    function isPositivePattern(pattern) {
      return !isNegativePattern(pattern);
    }
    exports.isPositivePattern = isPositivePattern;
    function getNegativePatterns(patterns) {
      return patterns.filter(isNegativePattern);
    }
    exports.getNegativePatterns = getNegativePatterns;
    function getPositivePatterns(patterns) {
      return patterns.filter(isPositivePattern);
    }
    exports.getPositivePatterns = getPositivePatterns;
    function getPatternsInsideCurrentDirectory(patterns) {
      return patterns.filter((pattern) => !isPatternRelatedToParentDirectory(pattern));
    }
    exports.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;
    function getPatternsOutsideCurrentDirectory(patterns) {
      return patterns.filter(isPatternRelatedToParentDirectory);
    }
    exports.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;
    function isPatternRelatedToParentDirectory(pattern) {
      return pattern.startsWith("..") || pattern.startsWith("./..");
    }
    exports.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;
    function getBaseDirectory(pattern) {
      return globParent(pattern, { flipBackslashes: false });
    }
    exports.getBaseDirectory = getBaseDirectory;
    function hasGlobStar(pattern) {
      return pattern.includes(GLOBSTAR);
    }
    exports.hasGlobStar = hasGlobStar;
    function endsWithSlashGlobStar(pattern) {
      return pattern.endsWith("/" + GLOBSTAR);
    }
    exports.endsWithSlashGlobStar = endsWithSlashGlobStar;
    function isAffectDepthOfReadingPattern(pattern) {
      const basename = path11.basename(pattern);
      return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);
    }
    exports.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;
    function expandPatternsWithBraceExpansion(patterns) {
      return patterns.reduce((collection, pattern) => {
        return collection.concat(expandBraceExpansion(pattern));
      }, []);
    }
    exports.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;
    function expandBraceExpansion(pattern) {
      return micromatch2.braces(pattern, {
        expand: true,
        nodupes: true
      });
    }
    exports.expandBraceExpansion = expandBraceExpansion;
    function getPatternParts(pattern, options9) {
      let { parts } = micromatch2.scan(pattern, Object.assign(Object.assign({}, options9), { parts: true }));
      if (parts.length === 0) {
        parts = [pattern];
      }
      if (parts[0].startsWith("/")) {
        parts[0] = parts[0].slice(1);
        parts.unshift("");
      }
      return parts;
    }
    exports.getPatternParts = getPatternParts;
    function makeRe(pattern, options9) {
      return micromatch2.makeRe(pattern, options9);
    }
    exports.makeRe = makeRe;
    function convertPatternsToRe(patterns, options9) {
      return patterns.map((pattern) => makeRe(pattern, options9));
    }
    exports.convertPatternsToRe = convertPatternsToRe;
    function matchAny(entry, patternsRe) {
      return patternsRe.some((patternRe) => patternRe.test(entry));
    }
    exports.matchAny = matchAny;
  }
});

// node_modules/merge2/index.js
var require_merge2 = __commonJS({
  "node_modules/merge2/index.js"(exports, module) {
    "use strict";
    var Stream = __require("stream");
    var PassThrough = Stream.PassThrough;
    var slice = Array.prototype.slice;
    module.exports = merge2;
    function merge2() {
      const streamsQueue = [];
      const args = slice.call(arguments);
      let merging = false;
      let options9 = args[args.length - 1];
      if (options9 && !Array.isArray(options9) && options9.pipe == null) {
        args.pop();
      } else {
        options9 = {};
      }
      const doEnd = options9.end !== false;
      const doPipeError = options9.pipeError === true;
      if (options9.objectMode == null) {
        options9.objectMode = true;
      }
      if (options9.highWaterMark == null) {
        options9.highWaterMark = 64 * 1024;
      }
      const mergedStream = PassThrough(options9);
      function addStream() {
        for (let i = 0, len = arguments.length; i < len; i++) {
          streamsQueue.push(pauseStreams(arguments[i], options9));
        }
        mergeStream();
        return this;
      }
      function mergeStream() {
        if (merging) {
          return;
        }
        merging = true;
        let streams = streamsQueue.shift();
        if (!streams) {
          process.nextTick(endStream);
          return;
        }
        if (!Array.isArray(streams)) {
          streams = [streams];
        }
        let pipesCount = streams.length + 1;
        function next() {
          if (--pipesCount > 0) {
            return;
          }
          merging = false;
          mergeStream();
        }
        function pipe(stream) {
          function onend() {
            stream.removeListener("merge2UnpipeEnd", onend);
            stream.removeListener("end", onend);
            if (doPipeError) {
              stream.removeListener("error", onerror);
            }
            next();
          }
          function onerror(err) {
            mergedStream.emit("error", err);
          }
          if (stream._readableState.endEmitted) {
            return next();
          }
          stream.on("merge2UnpipeEnd", onend);
          stream.on("end", onend);
          if (doPipeError) {
            stream.on("error", onerror);
          }
          stream.pipe(mergedStream, { end: false });
          stream.resume();
        }
        for (let i = 0; i < streams.length; i++) {
          pipe(streams[i]);
        }
        next();
      }
      function endStream() {
        merging = false;
        mergedStream.emit("queueDrain");
        if (doEnd) {
          mergedStream.end();
        }
      }
      mergedStream.setMaxListeners(0);
      mergedStream.add = addStream;
      mergedStream.on("unpipe", function(stream) {
        stream.emit("merge2UnpipeEnd");
      });
      if (args.length) {
        addStream.apply(null, args);
      }
      return mergedStream;
    }
    function pauseStreams(streams, options9) {
      if (!Array.isArray(streams)) {
        if (!streams._readableState && streams.pipe) {
          streams = streams.pipe(PassThrough(options9));
        }
        if (!streams._readableState || !streams.pause || !streams.pipe) {
          throw new Error("Only readable stream can be merged.");
        }
        streams.pause();
      } else {
        for (let i = 0, len = streams.length; i < len; i++) {
          streams[i] = pauseStreams(streams[i], options9);
        }
      }
      return streams;
    }
  }
});

// node_modules/fast-glob/out/utils/stream.js
var require_stream = __commonJS({
  "node_modules/fast-glob/out/utils/stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.merge = void 0;
    var merge2 = require_merge2();
    function merge(streams) {
      const mergedStream = merge2(streams);
      streams.forEach((stream) => {
        stream.once("error", (error) => mergedStream.emit("error", error));
      });
      mergedStream.once("close", () => propagateCloseEventToSources(streams));
      mergedStream.once("end", () => propagateCloseEventToSources(streams));
      return mergedStream;
    }
    exports.merge = merge;
    function propagateCloseEventToSources(streams) {
      streams.forEach((stream) => stream.emit("close"));
    }
  }
});

// node_modules/fast-glob/out/utils/string.js
var require_string2 = __commonJS({
  "node_modules/fast-glob/out/utils/string.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isEmpty = exports.isString = void 0;
    function isString(input) {
      return typeof input === "string";
    }
    exports.isString = isString;
    function isEmpty(input) {
      return input === "";
    }
    exports.isEmpty = isEmpty;
  }
});

// node_modules/fast-glob/out/utils/index.js
var require_utils4 = __commonJS({
  "node_modules/fast-glob/out/utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.string = exports.stream = exports.pattern = exports.path = exports.fs = exports.errno = exports.array = void 0;
    var array = require_array2();
    exports.array = array;
    var errno = require_errno();
    exports.errno = errno;
    var fs6 = require_fs();
    exports.fs = fs6;
    var path11 = require_path();
    exports.path = path11;
    var pattern = require_pattern();
    exports.pattern = pattern;
    var stream = require_stream();
    exports.stream = stream;
    var string = require_string2();
    exports.string = string;
  }
});

// node_modules/fast-glob/out/managers/tasks.js
var require_tasks = __commonJS({
  "node_modules/fast-glob/out/managers/tasks.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertPatternGroupToTask = exports.convertPatternGroupsToTasks = exports.groupPatternsByBaseDirectory = exports.getNegativePatternsAsPositive = exports.getPositivePatterns = exports.convertPatternsToTasks = exports.generate = void 0;
    var utils2 = require_utils4();
    function generate(patterns, settings) {
      const positivePatterns = getPositivePatterns(patterns);
      const negativePatterns = getNegativePatternsAsPositive(patterns, settings.ignore);
      const staticPatterns = positivePatterns.filter((pattern) => utils2.pattern.isStaticPattern(pattern, settings));
      const dynamicPatterns = positivePatterns.filter((pattern) => utils2.pattern.isDynamicPattern(pattern, settings));
      const staticTasks = convertPatternsToTasks(
        staticPatterns,
        negativePatterns,
        /* dynamic */
        false
      );
      const dynamicTasks = convertPatternsToTasks(
        dynamicPatterns,
        negativePatterns,
        /* dynamic */
        true
      );
      return staticTasks.concat(dynamicTasks);
    }
    exports.generate = generate;
    function convertPatternsToTasks(positive, negative, dynamic) {
      const tasks = [];
      const patternsOutsideCurrentDirectory = utils2.pattern.getPatternsOutsideCurrentDirectory(positive);
      const patternsInsideCurrentDirectory = utils2.pattern.getPatternsInsideCurrentDirectory(positive);
      const outsideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsOutsideCurrentDirectory);
      const insideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsInsideCurrentDirectory);
      tasks.push(...convertPatternGroupsToTasks(outsideCurrentDirectoryGroup, negative, dynamic));
      if ("." in insideCurrentDirectoryGroup) {
        tasks.push(convertPatternGroupToTask(".", patternsInsideCurrentDirectory, negative, dynamic));
      } else {
        tasks.push(...convertPatternGroupsToTasks(insideCurrentDirectoryGroup, negative, dynamic));
      }
      return tasks;
    }
    exports.convertPatternsToTasks = convertPatternsToTasks;
    function getPositivePatterns(patterns) {
      return utils2.pattern.getPositivePatterns(patterns);
    }
    exports.getPositivePatterns = getPositivePatterns;
    function getNegativePatternsAsPositive(patterns, ignore) {
      const negative = utils2.pattern.getNegativePatterns(patterns).concat(ignore);
      const positive = negative.map(utils2.pattern.convertToPositivePattern);
      return positive;
    }
    exports.getNegativePatternsAsPositive = getNegativePatternsAsPositive;
    function groupPatternsByBaseDirectory(patterns) {
      const group2 = {};
      return patterns.reduce((collection, pattern) => {
        const base = utils2.pattern.getBaseDirectory(pattern);
        if (base in collection) {
          collection[base].push(pattern);
        } else {
          collection[base] = [pattern];
        }
        return collection;
      }, group2);
    }
    exports.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;
    function convertPatternGroupsToTasks(positive, negative, dynamic) {
      return Object.keys(positive).map((base) => {
        return convertPatternGroupToTask(base, positive[base], negative, dynamic);
      });
    }
    exports.convertPatternGroupsToTasks = convertPatternGroupsToTasks;
    function convertPatternGroupToTask(base, positive, negative, dynamic) {
      return {
        dynamic,
        positive,
        negative,
        base,
        patterns: [].concat(positive, negative.map(utils2.pattern.convertToNegativePattern))
      };
    }
    exports.convertPatternGroupToTask = convertPatternGroupToTask;
  }
});

// node_modules/fast-glob/out/managers/patterns.js
var require_patterns = __commonJS({
  "node_modules/fast-glob/out/managers/patterns.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.removeDuplicateSlashes = exports.transform = void 0;
    var DOUBLE_SLASH_RE = /(?!^)\/{2,}/g;
    function transform2(patterns) {
      return patterns.map((pattern) => removeDuplicateSlashes(pattern));
    }
    exports.transform = transform2;
    function removeDuplicateSlashes(pattern) {
      return pattern.replace(DOUBLE_SLASH_RE, "/");
    }
    exports.removeDuplicateSlashes = removeDuplicateSlashes;
  }
});

// node_modules/@nodelib/fs.stat/out/providers/async.js
var require_async = __commonJS({
  "node_modules/@nodelib/fs.stat/out/providers/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.read = void 0;
    function read2(path11, settings, callback) {
      settings.fs.lstat(path11, (lstatError, lstat) => {
        if (lstatError !== null) {
          callFailureCallback(callback, lstatError);
          return;
        }
        if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
          callSuccessCallback(callback, lstat);
          return;
        }
        settings.fs.stat(path11, (statError, stat) => {
          if (statError !== null) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              callFailureCallback(callback, statError);
              return;
            }
            callSuccessCallback(callback, lstat);
            return;
          }
          if (settings.markSymbolicLink) {
            stat.isSymbolicLink = () => true;
          }
          callSuccessCallback(callback, stat);
        });
      });
    }
    exports.read = read2;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, result) {
      callback(null, result);
    }
  }
});

// node_modules/@nodelib/fs.stat/out/providers/sync.js
var require_sync = __commonJS({
  "node_modules/@nodelib/fs.stat/out/providers/sync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.read = void 0;
    function read2(path11, settings) {
      const lstat = settings.fs.lstatSync(path11);
      if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
        return lstat;
      }
      try {
        const stat = settings.fs.statSync(path11);
        if (settings.markSymbolicLink) {
          stat.isSymbolicLink = () => true;
        }
        return stat;
      } catch (error) {
        if (!settings.throwErrorOnBrokenSymbolicLink) {
          return lstat;
        }
        throw error;
      }
    }
    exports.read = read2;
  }
});

// node_modules/@nodelib/fs.stat/out/adapters/fs.js
var require_fs2 = __commonJS({
  "node_modules/@nodelib/fs.stat/out/adapters/fs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = void 0;
    var fs6 = __require("fs");
    exports.FILE_SYSTEM_ADAPTER = {
      lstat: fs6.lstat,
      stat: fs6.stat,
      lstatSync: fs6.lstatSync,
      statSync: fs6.statSync
    };
    function createFileSystemAdapter(fsMethods) {
      if (fsMethods === void 0) {
        return exports.FILE_SYSTEM_ADAPTER;
      }
      return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);
    }
    exports.createFileSystemAdapter = createFileSystemAdapter;
  }
});

// node_modules/@nodelib/fs.stat/out/settings.js
var require_settings = __commonJS({
  "node_modules/@nodelib/fs.stat/out/settings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var fs6 = require_fs2();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);
        this.fs = fs6.createFileSystemAdapter(this._options.fs);
        this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
      }
      _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
      }
    };
    exports.default = Settings;
  }
});

// node_modules/@nodelib/fs.stat/out/index.js
var require_out = __commonJS({
  "node_modules/@nodelib/fs.stat/out/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.statSync = exports.stat = exports.Settings = void 0;
    var async = require_async();
    var sync = require_sync();
    var settings_1 = require_settings();
    exports.Settings = settings_1.default;
    function stat(path11, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        async.read(path11, getSettings(), optionsOrSettingsOrCallback);
        return;
      }
      async.read(path11, getSettings(optionsOrSettingsOrCallback), callback);
    }
    exports.stat = stat;
    function statSync2(path11, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      return sync.read(path11, settings);
    }
    exports.statSync = statSync2;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  }
});

// node_modules/queue-microtask/index.js
var require_queue_microtask = __commonJS({
  "node_modules/queue-microtask/index.js"(exports, module) {
    var promise;
    module.exports = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : global) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
      throw err;
    }, 0));
  }
});

// node_modules/run-parallel/index.js
var require_run_parallel = __commonJS({
  "node_modules/run-parallel/index.js"(exports, module) {
    module.exports = runParallel;
    var queueMicrotask2 = require_queue_microtask();
    function runParallel(tasks, cb) {
      let results, pending, keys;
      let isSync = true;
      if (Array.isArray(tasks)) {
        results = [];
        pending = tasks.length;
      } else {
        keys = Object.keys(tasks);
        results = {};
        pending = keys.length;
      }
      function done(err) {
        function end() {
          if (cb)
            cb(err, results);
          cb = null;
        }
        if (isSync)
          queueMicrotask2(end);
        else
          end();
      }
      function each(i, err, result) {
        results[i] = result;
        if (--pending === 0 || err) {
          done(err);
        }
      }
      if (!pending) {
        done(null);
      } else if (keys) {
        keys.forEach(function(key) {
          tasks[key](function(err, result) {
            each(key, err, result);
          });
        });
      } else {
        tasks.forEach(function(task, i) {
          task(function(err, result) {
            each(i, err, result);
          });
        });
      }
      isSync = false;
    }
  }
});

// node_modules/@nodelib/fs.scandir/out/constants.js
var require_constants3 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;
    var NODE_PROCESS_VERSION_PARTS = process.versions.node.split(".");
    if (NODE_PROCESS_VERSION_PARTS[0] === void 0 || NODE_PROCESS_VERSION_PARTS[1] === void 0) {
      throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`);
    }
    var MAJOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);
    var MINOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);
    var SUPPORTED_MAJOR_VERSION = 10;
    var SUPPORTED_MINOR_VERSION = 10;
    var IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;
    var IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;
    exports.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;
  }
});

// node_modules/@nodelib/fs.scandir/out/utils/fs.js
var require_fs3 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/utils/fs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createDirentFromStats = void 0;
    var DirentFromStats = class {
      constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    function createDirentFromStats(name, stats) {
      return new DirentFromStats(name, stats);
    }
    exports.createDirentFromStats = createDirentFromStats;
  }
});

// node_modules/@nodelib/fs.scandir/out/utils/index.js
var require_utils5 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fs = void 0;
    var fs6 = require_fs3();
    exports.fs = fs6;
  }
});

// node_modules/@nodelib/fs.scandir/out/providers/common.js
var require_common3 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/providers/common.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.joinPathSegments = void 0;
    function joinPathSegments(a, b, separator) {
      if (a.endsWith(separator)) {
        return a + b;
      }
      return a + separator + b;
    }
    exports.joinPathSegments = joinPathSegments;
  }
});

// node_modules/@nodelib/fs.scandir/out/providers/async.js
var require_async2 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/providers/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.readdir = exports.readdirWithFileTypes = exports.read = void 0;
    var fsStat = require_out();
    var rpl = require_run_parallel();
    var constants_1 = require_constants3();
    var utils2 = require_utils5();
    var common = require_common3();
    function read2(directory, settings, callback) {
      if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        readdirWithFileTypes(directory, settings, callback);
        return;
      }
      readdir(directory, settings, callback);
    }
    exports.read = read2;
    function readdirWithFileTypes(directory, settings, callback) {
      settings.fs.readdir(directory, { withFileTypes: true }, (readdirError, dirents) => {
        if (readdirError !== null) {
          callFailureCallback(callback, readdirError);
          return;
        }
        const entries = dirents.map((dirent) => ({
          dirent,
          name: dirent.name,
          path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        }));
        if (!settings.followSymbolicLinks) {
          callSuccessCallback(callback, entries);
          return;
        }
        const tasks = entries.map((entry) => makeRplTaskEntry(entry, settings));
        rpl(tasks, (rplError, rplEntries) => {
          if (rplError !== null) {
            callFailureCallback(callback, rplError);
            return;
          }
          callSuccessCallback(callback, rplEntries);
        });
      });
    }
    exports.readdirWithFileTypes = readdirWithFileTypes;
    function makeRplTaskEntry(entry, settings) {
      return (done) => {
        if (!entry.dirent.isSymbolicLink()) {
          done(null, entry);
          return;
        }
        settings.fs.stat(entry.path, (statError, stats) => {
          if (statError !== null) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              done(statError);
              return;
            }
            done(null, entry);
            return;
          }
          entry.dirent = utils2.fs.createDirentFromStats(entry.name, stats);
          done(null, entry);
        });
      };
    }
    function readdir(directory, settings, callback) {
      settings.fs.readdir(directory, (readdirError, names) => {
        if (readdirError !== null) {
          callFailureCallback(callback, readdirError);
          return;
        }
        const tasks = names.map((name) => {
          const path11 = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);
          return (done) => {
            fsStat.stat(path11, settings.fsStatSettings, (error, stats) => {
              if (error !== null) {
                done(error);
                return;
              }
              const entry = {
                name,
                path: path11,
                dirent: utils2.fs.createDirentFromStats(name, stats)
              };
              if (settings.stats) {
                entry.stats = stats;
              }
              done(null, entry);
            });
          };
        });
        rpl(tasks, (rplError, entries) => {
          if (rplError !== null) {
            callFailureCallback(callback, rplError);
            return;
          }
          callSuccessCallback(callback, entries);
        });
      });
    }
    exports.readdir = readdir;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, result) {
      callback(null, result);
    }
  }
});

// node_modules/@nodelib/fs.scandir/out/providers/sync.js
var require_sync2 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/providers/sync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.readdir = exports.readdirWithFileTypes = exports.read = void 0;
    var fsStat = require_out();
    var constants_1 = require_constants3();
    var utils2 = require_utils5();
    var common = require_common3();
    function read2(directory, settings) {
      if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        return readdirWithFileTypes(directory, settings);
      }
      return readdir(directory, settings);
    }
    exports.read = read2;
    function readdirWithFileTypes(directory, settings) {
      const dirents = settings.fs.readdirSync(directory, { withFileTypes: true });
      return dirents.map((dirent) => {
        const entry = {
          dirent,
          name: dirent.name,
          path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        };
        if (entry.dirent.isSymbolicLink() && settings.followSymbolicLinks) {
          try {
            const stats = settings.fs.statSync(entry.path);
            entry.dirent = utils2.fs.createDirentFromStats(entry.name, stats);
          } catch (error) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              throw error;
            }
          }
        }
        return entry;
      });
    }
    exports.readdirWithFileTypes = readdirWithFileTypes;
    function readdir(directory, settings) {
      const names = settings.fs.readdirSync(directory);
      return names.map((name) => {
        const entryPath = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);
        const stats = fsStat.statSync(entryPath, settings.fsStatSettings);
        const entry = {
          name,
          path: entryPath,
          dirent: utils2.fs.createDirentFromStats(name, stats)
        };
        if (settings.stats) {
          entry.stats = stats;
        }
        return entry;
      });
    }
    exports.readdir = readdir;
  }
});

// node_modules/@nodelib/fs.scandir/out/adapters/fs.js
var require_fs4 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/adapters/fs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = void 0;
    var fs6 = __require("fs");
    exports.FILE_SYSTEM_ADAPTER = {
      lstat: fs6.lstat,
      stat: fs6.stat,
      lstatSync: fs6.lstatSync,
      statSync: fs6.statSync,
      readdir: fs6.readdir,
      readdirSync: fs6.readdirSync
    };
    function createFileSystemAdapter(fsMethods) {
      if (fsMethods === void 0) {
        return exports.FILE_SYSTEM_ADAPTER;
      }
      return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);
    }
    exports.createFileSystemAdapter = createFileSystemAdapter;
  }
});

// node_modules/@nodelib/fs.scandir/out/settings.js
var require_settings2 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/settings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var path11 = __require("path");
    var fsStat = require_out();
    var fs6 = require_fs4();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);
        this.fs = fs6.createFileSystemAdapter(this._options.fs);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path11.sep);
        this.stats = this._getValue(this._options.stats, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
        this.fsStatSettings = new fsStat.Settings({
          followSymbolicLink: this.followSymbolicLinks,
          fs: this.fs,
          throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
      }
    };
    exports.default = Settings;
  }
});

// node_modules/@nodelib/fs.scandir/out/index.js
var require_out2 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Settings = exports.scandirSync = exports.scandir = void 0;
    var async = require_async2();
    var sync = require_sync2();
    var settings_1 = require_settings2();
    exports.Settings = settings_1.default;
    function scandir(path11, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        async.read(path11, getSettings(), optionsOrSettingsOrCallback);
        return;
      }
      async.read(path11, getSettings(optionsOrSettingsOrCallback), callback);
    }
    exports.scandir = scandir;
    function scandirSync(path11, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      return sync.read(path11, settings);
    }
    exports.scandirSync = scandirSync;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  }
});

// node_modules/reusify/reusify.js
var require_reusify = __commonJS({
  "node_modules/reusify/reusify.js"(exports, module) {
    "use strict";
    function reusify(Constructor) {
      var head = new Constructor();
      var tail = head;
      function get() {
        var current = head;
        if (current.next) {
          head = current.next;
        } else {
          head = new Constructor();
          tail = head;
        }
        current.next = null;
        return current;
      }
      function release(obj) {
        tail.next = obj;
        tail = obj;
      }
      return {
        get,
        release
      };
    }
    module.exports = reusify;
  }
});

// node_modules/fastq/queue.js
var require_queue = __commonJS({
  "node_modules/fastq/queue.js"(exports, module) {
    "use strict";
    var reusify = require_reusify();
    function fastqueue(context, worker, concurrency) {
      if (typeof context === "function") {
        concurrency = worker;
        worker = context;
        context = null;
      }
      if (concurrency < 1) {
        throw new Error("fastqueue concurrency must be greater than 1");
      }
      var cache = reusify(Task);
      var queueHead = null;
      var queueTail = null;
      var _running = 0;
      var errorHandler = null;
      var self2 = {
        push,
        drain: noop,
        saturated: noop,
        pause,
        paused: false,
        concurrency,
        running,
        resume,
        idle,
        length,
        getQueue,
        unshift,
        empty: noop,
        kill,
        killAndDrain,
        error
      };
      return self2;
      function running() {
        return _running;
      }
      function pause() {
        self2.paused = true;
      }
      function length() {
        var current = queueHead;
        var counter = 0;
        while (current) {
          current = current.next;
          counter++;
        }
        return counter;
      }
      function getQueue() {
        var current = queueHead;
        var tasks = [];
        while (current) {
          tasks.push(current.value);
          current = current.next;
        }
        return tasks;
      }
      function resume() {
        if (!self2.paused)
          return;
        self2.paused = false;
        for (var i = 0; i < self2.concurrency; i++) {
          _running++;
          release();
        }
      }
      function idle() {
        return _running === 0 && self2.length() === 0;
      }
      function push(value, done) {
        var current = cache.get();
        current.context = context;
        current.release = release;
        current.value = value;
        current.callback = done || noop;
        current.errorHandler = errorHandler;
        if (_running === self2.concurrency || self2.paused) {
          if (queueTail) {
            queueTail.next = current;
            queueTail = current;
          } else {
            queueHead = current;
            queueTail = current;
            self2.saturated();
          }
        } else {
          _running++;
          worker.call(context, current.value, current.worked);
        }
      }
      function unshift(value, done) {
        var current = cache.get();
        current.context = context;
        current.release = release;
        current.value = value;
        current.callback = done || noop;
        if (_running === self2.concurrency || self2.paused) {
          if (queueHead) {
            current.next = queueHead;
            queueHead = current;
          } else {
            queueHead = current;
            queueTail = current;
            self2.saturated();
          }
        } else {
          _running++;
          worker.call(context, current.value, current.worked);
        }
      }
      function release(holder) {
        if (holder) {
          cache.release(holder);
        }
        var next = queueHead;
        if (next) {
          if (!self2.paused) {
            if (queueTail === queueHead) {
              queueTail = null;
            }
            queueHead = next.next;
            next.next = null;
            worker.call(context, next.value, next.worked);
            if (queueTail === null) {
              self2.empty();
            }
          } else {
            _running--;
          }
        } else if (--_running === 0) {
          self2.drain();
        }
      }
      function kill() {
        queueHead = null;
        queueTail = null;
        self2.drain = noop;
      }
      function killAndDrain() {
        queueHead = null;
        queueTail = null;
        self2.drain();
        self2.drain = noop;
      }
      function error(handler) {
        errorHandler = handler;
      }
    }
    function noop() {
    }
    function Task() {
      this.value = null;
      this.callback = noop;
      this.next = null;
      this.release = noop;
      this.context = null;
      this.errorHandler = null;
      var self2 = this;
      this.worked = function worked(err, result) {
        var callback = self2.callback;
        var errorHandler = self2.errorHandler;
        var val = self2.value;
        self2.value = null;
        self2.callback = noop;
        if (self2.errorHandler) {
          errorHandler(err, val);
        }
        callback.call(self2.context, err, result);
        self2.release(self2);
      };
    }
    function queueAsPromised(context, worker, concurrency) {
      if (typeof context === "function") {
        concurrency = worker;
        worker = context;
        context = null;
      }
      function asyncWrapper(arg, cb) {
        worker.call(this, arg).then(function(res) {
          cb(null, res);
        }, cb);
      }
      var queue = fastqueue(context, asyncWrapper, concurrency);
      var pushCb = queue.push;
      var unshiftCb = queue.unshift;
      queue.push = push;
      queue.unshift = unshift;
      queue.drained = drained;
      return queue;
      function push(value) {
        var p = new Promise(function(resolve2, reject) {
          pushCb(value, function(err, result) {
            if (err) {
              reject(err);
              return;
            }
            resolve2(result);
          });
        });
        p.catch(noop);
        return p;
      }
      function unshift(value) {
        var p = new Promise(function(resolve2, reject) {
          unshiftCb(value, function(err, result) {
            if (err) {
              reject(err);
              return;
            }
            resolve2(result);
          });
        });
        p.catch(noop);
        return p;
      }
      function drained() {
        var previousDrain = queue.drain;
        var p = new Promise(function(resolve2) {
          queue.drain = function() {
            previousDrain();
            resolve2();
          };
        });
        return p;
      }
    }
    module.exports = fastqueue;
    module.exports.promise = queueAsPromised;
  }
});

// node_modules/@nodelib/fs.walk/out/readers/common.js
var require_common4 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/readers/common.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.joinPathSegments = exports.replacePathSegmentSeparator = exports.isAppliedFilter = exports.isFatalError = void 0;
    function isFatalError(settings, error) {
      if (settings.errorFilter === null) {
        return true;
      }
      return !settings.errorFilter(error);
    }
    exports.isFatalError = isFatalError;
    function isAppliedFilter(filter, value) {
      return filter === null || filter(value);
    }
    exports.isAppliedFilter = isAppliedFilter;
    function replacePathSegmentSeparator(filepath, separator) {
      return filepath.split(/[/\\]/).join(separator);
    }
    exports.replacePathSegmentSeparator = replacePathSegmentSeparator;
    function joinPathSegments(a, b, separator) {
      if (a === "") {
        return b;
      }
      if (a.endsWith(separator)) {
        return a + b;
      }
      return a + separator + b;
    }
    exports.joinPathSegments = joinPathSegments;
  }
});

// node_modules/@nodelib/fs.walk/out/readers/reader.js
var require_reader = __commonJS({
  "node_modules/@nodelib/fs.walk/out/readers/reader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var common = require_common4();
    var Reader = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._root = common.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);
      }
    };
    exports.default = Reader;
  }
});

// node_modules/@nodelib/fs.walk/out/readers/async.js
var require_async3 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/readers/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var events_1 = __require("events");
    var fsScandir = require_out2();
    var fastq = require_queue();
    var common = require_common4();
    var reader_1 = require_reader();
    var AsyncReader = class extends reader_1.default {
      constructor(_root, _settings) {
        super(_root, _settings);
        this._settings = _settings;
        this._scandir = fsScandir.scandir;
        this._emitter = new events_1.EventEmitter();
        this._queue = fastq(this._worker.bind(this), this._settings.concurrency);
        this._isFatalError = false;
        this._isDestroyed = false;
        this._queue.drain = () => {
          if (!this._isFatalError) {
            this._emitter.emit("end");
          }
        };
      }
      read() {
        this._isFatalError = false;
        this._isDestroyed = false;
        setImmediate(() => {
          this._pushToQueue(this._root, this._settings.basePath);
        });
        return this._emitter;
      }
      get isDestroyed() {
        return this._isDestroyed;
      }
      destroy() {
        if (this._isDestroyed) {
          throw new Error("The reader is already destroyed");
        }
        this._isDestroyed = true;
        this._queue.killAndDrain();
      }
      onEntry(callback) {
        this._emitter.on("entry", callback);
      }
      onError(callback) {
        this._emitter.once("error", callback);
      }
      onEnd(callback) {
        this._emitter.once("end", callback);
      }
      _pushToQueue(directory, base) {
        const queueItem = { directory, base };
        this._queue.push(queueItem, (error) => {
          if (error !== null) {
            this._handleError(error);
          }
        });
      }
      _worker(item, done) {
        this._scandir(item.directory, this._settings.fsScandirSettings, (error, entries) => {
          if (error !== null) {
            done(error, void 0);
            return;
          }
          for (const entry of entries) {
            this._handleEntry(entry, item.base);
          }
          done(null, void 0);
        });
      }
      _handleError(error) {
        if (this._isDestroyed || !common.isFatalError(this._settings, error)) {
          return;
        }
        this._isFatalError = true;
        this._isDestroyed = true;
        this._emitter.emit("error", error);
      }
      _handleEntry(entry, base) {
        if (this._isDestroyed || this._isFatalError) {
          return;
        }
        const fullpath = entry.path;
        if (base !== void 0) {
          entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
          this._emitEntry(entry);
        }
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
          this._pushToQueue(fullpath, base === void 0 ? void 0 : entry.path);
        }
      }
      _emitEntry(entry) {
        this._emitter.emit("entry", entry);
      }
    };
    exports.default = AsyncReader;
  }
});

// node_modules/@nodelib/fs.walk/out/providers/async.js
var require_async4 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/providers/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var async_1 = require_async3();
    var AsyncProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._storage = [];
      }
      read(callback) {
        this._reader.onError((error) => {
          callFailureCallback(callback, error);
        });
        this._reader.onEntry((entry) => {
          this._storage.push(entry);
        });
        this._reader.onEnd(() => {
          callSuccessCallback(callback, this._storage);
        });
        this._reader.read();
      }
    };
    exports.default = AsyncProvider;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, entries) {
      callback(null, entries);
    }
  }
});

// node_modules/@nodelib/fs.walk/out/providers/stream.js
var require_stream2 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/providers/stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var stream_1 = __require("stream");
    var async_1 = require_async3();
    var StreamProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._stream = new stream_1.Readable({
          objectMode: true,
          read: () => {
          },
          destroy: () => {
            if (!this._reader.isDestroyed) {
              this._reader.destroy();
            }
          }
        });
      }
      read() {
        this._reader.onError((error) => {
          this._stream.emit("error", error);
        });
        this._reader.onEntry((entry) => {
          this._stream.push(entry);
        });
        this._reader.onEnd(() => {
          this._stream.push(null);
        });
        this._reader.read();
        return this._stream;
      }
    };
    exports.default = StreamProvider;
  }
});

// node_modules/@nodelib/fs.walk/out/readers/sync.js
var require_sync3 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/readers/sync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var fsScandir = require_out2();
    var common = require_common4();
    var reader_1 = require_reader();
    var SyncReader = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._scandir = fsScandir.scandirSync;
        this._storage = [];
        this._queue = /* @__PURE__ */ new Set();
      }
      read() {
        this._pushToQueue(this._root, this._settings.basePath);
        this._handleQueue();
        return this._storage;
      }
      _pushToQueue(directory, base) {
        this._queue.add({ directory, base });
      }
      _handleQueue() {
        for (const item of this._queue.values()) {
          this._handleDirectory(item.directory, item.base);
        }
      }
      _handleDirectory(directory, base) {
        try {
          const entries = this._scandir(directory, this._settings.fsScandirSettings);
          for (const entry of entries) {
            this._handleEntry(entry, base);
          }
        } catch (error) {
          this._handleError(error);
        }
      }
      _handleError(error) {
        if (!common.isFatalError(this._settings, error)) {
          return;
        }
        throw error;
      }
      _handleEntry(entry, base) {
        const fullpath = entry.path;
        if (base !== void 0) {
          entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
          this._pushToStorage(entry);
        }
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
          this._pushToQueue(fullpath, base === void 0 ? void 0 : entry.path);
        }
      }
      _pushToStorage(entry) {
        this._storage.push(entry);
      }
    };
    exports.default = SyncReader;
  }
});

// node_modules/@nodelib/fs.walk/out/providers/sync.js
var require_sync4 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/providers/sync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var sync_1 = require_sync3();
    var SyncProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new sync_1.default(this._root, this._settings);
      }
      read() {
        return this._reader.read();
      }
    };
    exports.default = SyncProvider;
  }
});

// node_modules/@nodelib/fs.walk/out/settings.js
var require_settings3 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/settings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var path11 = __require("path");
    var fsScandir = require_out2();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.basePath = this._getValue(this._options.basePath, void 0);
        this.concurrency = this._getValue(this._options.concurrency, Number.POSITIVE_INFINITY);
        this.deepFilter = this._getValue(this._options.deepFilter, null);
        this.entryFilter = this._getValue(this._options.entryFilter, null);
        this.errorFilter = this._getValue(this._options.errorFilter, null);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path11.sep);
        this.fsScandirSettings = new fsScandir.Settings({
          followSymbolicLinks: this._options.followSymbolicLinks,
          fs: this._options.fs,
          pathSegmentSeparator: this._options.pathSegmentSeparator,
          stats: this._options.stats,
          throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
      }
    };
    exports.default = Settings;
  }
});

// node_modules/@nodelib/fs.walk/out/index.js
var require_out3 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Settings = exports.walkStream = exports.walkSync = exports.walk = void 0;
    var async_1 = require_async4();
    var stream_1 = require_stream2();
    var sync_1 = require_sync4();
    var settings_1 = require_settings3();
    exports.Settings = settings_1.default;
    function walk(directory, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        new async_1.default(directory, getSettings()).read(optionsOrSettingsOrCallback);
        return;
      }
      new async_1.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);
    }
    exports.walk = walk;
    function walkSync(directory, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      const provider = new sync_1.default(directory, settings);
      return provider.read();
    }
    exports.walkSync = walkSync;
    function walkStream(directory, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      const provider = new stream_1.default(directory, settings);
      return provider.read();
    }
    exports.walkStream = walkStream;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  }
});

// node_modules/fast-glob/out/readers/reader.js
var require_reader2 = __commonJS({
  "node_modules/fast-glob/out/readers/reader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var path11 = __require("path");
    var fsStat = require_out();
    var utils2 = require_utils4();
    var Reader = class {
      constructor(_settings) {
        this._settings = _settings;
        this._fsStatSettings = new fsStat.Settings({
          followSymbolicLink: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
        });
      }
      _getFullEntryPath(filepath) {
        return path11.resolve(this._settings.cwd, filepath);
      }
      _makeEntry(stats, pattern) {
        const entry = {
          name: pattern,
          path: pattern,
          dirent: utils2.fs.createDirentFromStats(pattern, stats)
        };
        if (this._settings.stats) {
          entry.stats = stats;
        }
        return entry;
      }
      _isFatalError(error) {
        return !utils2.errno.isEnoentCodeError(error) && !this._settings.suppressErrors;
      }
    };
    exports.default = Reader;
  }
});

// node_modules/fast-glob/out/readers/stream.js
var require_stream3 = __commonJS({
  "node_modules/fast-glob/out/readers/stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var stream_1 = __require("stream");
    var fsStat = require_out();
    var fsWalk = require_out3();
    var reader_1 = require_reader2();
    var ReaderStream = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkStream = fsWalk.walkStream;
        this._stat = fsStat.stat;
      }
      dynamic(root, options9) {
        return this._walkStream(root, options9);
      }
      static(patterns, options9) {
        const filepaths = patterns.map(this._getFullEntryPath, this);
        const stream = new stream_1.PassThrough({ objectMode: true });
        stream._write = (index, _enc, done) => {
          return this._getEntry(filepaths[index], patterns[index], options9).then((entry) => {
            if (entry !== null && options9.entryFilter(entry)) {
              stream.push(entry);
            }
            if (index === filepaths.length - 1) {
              stream.end();
            }
            done();
          }).catch(done);
        };
        for (let i = 0; i < filepaths.length; i++) {
          stream.write(i);
        }
        return stream;
      }
      _getEntry(filepath, pattern, options9) {
        return this._getStat(filepath).then((stats) => this._makeEntry(stats, pattern)).catch((error) => {
          if (options9.errorFilter(error)) {
            return null;
          }
          throw error;
        });
      }
      _getStat(filepath) {
        return new Promise((resolve2, reject) => {
          this._stat(filepath, this._fsStatSettings, (error, stats) => {
            return error === null ? resolve2(stats) : reject(error);
          });
        });
      }
    };
    exports.default = ReaderStream;
  }
});

// node_modules/fast-glob/out/readers/async.js
var require_async5 = __commonJS({
  "node_modules/fast-glob/out/readers/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var fsWalk = require_out3();
    var reader_1 = require_reader2();
    var stream_1 = require_stream3();
    var ReaderAsync = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkAsync = fsWalk.walk;
        this._readerStream = new stream_1.default(this._settings);
      }
      dynamic(root, options9) {
        return new Promise((resolve2, reject) => {
          this._walkAsync(root, options9, (error, entries) => {
            if (error === null) {
              resolve2(entries);
            } else {
              reject(error);
            }
          });
        });
      }
      async static(patterns, options9) {
        const entries = [];
        const stream = this._readerStream.static(patterns, options9);
        return new Promise((resolve2, reject) => {
          stream.once("error", reject);
          stream.on("data", (entry) => entries.push(entry));
          stream.once("end", () => resolve2(entries));
        });
      }
    };
    exports.default = ReaderAsync;
  }
});

// node_modules/fast-glob/out/providers/matchers/matcher.js
var require_matcher = __commonJS({
  "node_modules/fast-glob/out/providers/matchers/matcher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils2 = require_utils4();
    var Matcher = class {
      constructor(_patterns, _settings, _micromatchOptions) {
        this._patterns = _patterns;
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this._storage = [];
        this._fillStorage();
      }
      _fillStorage() {
        const patterns = utils2.pattern.expandPatternsWithBraceExpansion(this._patterns);
        for (const pattern of patterns) {
          const segments = this._getPatternSegments(pattern);
          const sections = this._splitSegmentsIntoSections(segments);
          this._storage.push({
            complete: sections.length <= 1,
            pattern,
            segments,
            sections
          });
        }
      }
      _getPatternSegments(pattern) {
        const parts = utils2.pattern.getPatternParts(pattern, this._micromatchOptions);
        return parts.map((part) => {
          const dynamic = utils2.pattern.isDynamicPattern(part, this._settings);
          if (!dynamic) {
            return {
              dynamic: false,
              pattern: part
            };
          }
          return {
            dynamic: true,
            pattern: part,
            patternRe: utils2.pattern.makeRe(part, this._micromatchOptions)
          };
        });
      }
      _splitSegmentsIntoSections(segments) {
        return utils2.array.splitWhen(segments, (segment) => segment.dynamic && utils2.pattern.hasGlobStar(segment.pattern));
      }
    };
    exports.default = Matcher;
  }
});

// node_modules/fast-glob/out/providers/matchers/partial.js
var require_partial = __commonJS({
  "node_modules/fast-glob/out/providers/matchers/partial.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var matcher_1 = require_matcher();
    var PartialMatcher = class extends matcher_1.default {
      match(filepath) {
        const parts = filepath.split("/");
        const levels = parts.length;
        const patterns = this._storage.filter((info) => !info.complete || info.segments.length > levels);
        for (const pattern of patterns) {
          const section = pattern.sections[0];
          if (!pattern.complete && levels > section.length) {
            return true;
          }
          const match = parts.every((part, index) => {
            const segment = pattern.segments[index];
            if (segment.dynamic && segment.patternRe.test(part)) {
              return true;
            }
            if (!segment.dynamic && segment.pattern === part) {
              return true;
            }
            return false;
          });
          if (match) {
            return true;
          }
        }
        return false;
      }
    };
    exports.default = PartialMatcher;
  }
});

// node_modules/fast-glob/out/providers/filters/deep.js
var require_deep = __commonJS({
  "node_modules/fast-glob/out/providers/filters/deep.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils2 = require_utils4();
    var partial_1 = require_partial();
    var DeepFilter = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
      }
      getFilter(basePath, positive, negative) {
        const matcher = this._getMatcher(positive);
        const negativeRe = this._getNegativePatternsRe(negative);
        return (entry) => this._filter(basePath, entry, matcher, negativeRe);
      }
      _getMatcher(patterns) {
        return new partial_1.default(patterns, this._settings, this._micromatchOptions);
      }
      _getNegativePatternsRe(patterns) {
        const affectDepthOfReadingPatterns = patterns.filter(utils2.pattern.isAffectDepthOfReadingPattern);
        return utils2.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);
      }
      _filter(basePath, entry, matcher, negativeRe) {
        if (this._isSkippedByDeep(basePath, entry.path)) {
          return false;
        }
        if (this._isSkippedSymbolicLink(entry)) {
          return false;
        }
        const filepath = utils2.path.removeLeadingDotSegment(entry.path);
        if (this._isSkippedByPositivePatterns(filepath, matcher)) {
          return false;
        }
        return this._isSkippedByNegativePatterns(filepath, negativeRe);
      }
      _isSkippedByDeep(basePath, entryPath) {
        if (this._settings.deep === Infinity) {
          return false;
        }
        return this._getEntryLevel(basePath, entryPath) >= this._settings.deep;
      }
      _getEntryLevel(basePath, entryPath) {
        const entryPathDepth = entryPath.split("/").length;
        if (basePath === "") {
          return entryPathDepth;
        }
        const basePathDepth = basePath.split("/").length;
        return entryPathDepth - basePathDepth;
      }
      _isSkippedSymbolicLink(entry) {
        return !this._settings.followSymbolicLinks && entry.dirent.isSymbolicLink();
      }
      _isSkippedByPositivePatterns(entryPath, matcher) {
        return !this._settings.baseNameMatch && !matcher.match(entryPath);
      }
      _isSkippedByNegativePatterns(entryPath, patternsRe) {
        return !utils2.pattern.matchAny(entryPath, patternsRe);
      }
    };
    exports.default = DeepFilter;
  }
});

// node_modules/fast-glob/out/providers/filters/entry.js
var require_entry = __commonJS({
  "node_modules/fast-glob/out/providers/filters/entry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils2 = require_utils4();
    var EntryFilter = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this.index = /* @__PURE__ */ new Map();
      }
      getFilter(positive, negative) {
        const positiveRe = utils2.pattern.convertPatternsToRe(positive, this._micromatchOptions);
        const negativeRe = utils2.pattern.convertPatternsToRe(negative, this._micromatchOptions);
        return (entry) => this._filter(entry, positiveRe, negativeRe);
      }
      _filter(entry, positiveRe, negativeRe) {
        if (this._settings.unique && this._isDuplicateEntry(entry)) {
          return false;
        }
        if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {
          return false;
        }
        if (this._isSkippedByAbsoluteNegativePatterns(entry.path, negativeRe)) {
          return false;
        }
        const filepath = this._settings.baseNameMatch ? entry.name : entry.path;
        const isDirectory2 = entry.dirent.isDirectory();
        const isMatched = this._isMatchToPatterns(filepath, positiveRe, isDirectory2) && !this._isMatchToPatterns(entry.path, negativeRe, isDirectory2);
        if (this._settings.unique && isMatched) {
          this._createIndexRecord(entry);
        }
        return isMatched;
      }
      _isDuplicateEntry(entry) {
        return this.index.has(entry.path);
      }
      _createIndexRecord(entry) {
        this.index.set(entry.path, void 0);
      }
      _onlyFileFilter(entry) {
        return this._settings.onlyFiles && !entry.dirent.isFile();
      }
      _onlyDirectoryFilter(entry) {
        return this._settings.onlyDirectories && !entry.dirent.isDirectory();
      }
      _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {
        if (!this._settings.absolute) {
          return false;
        }
        const fullpath = utils2.path.makeAbsolute(this._settings.cwd, entryPath);
        return utils2.pattern.matchAny(fullpath, patternsRe);
      }
      _isMatchToPatterns(entryPath, patternsRe, isDirectory2) {
        const filepath = utils2.path.removeLeadingDotSegment(entryPath);
        const isMatched = utils2.pattern.matchAny(filepath, patternsRe);
        if (!isMatched && isDirectory2) {
          return utils2.pattern.matchAny(filepath + "/", patternsRe);
        }
        return isMatched;
      }
    };
    exports.default = EntryFilter;
  }
});

// node_modules/fast-glob/out/providers/filters/error.js
var require_error = __commonJS({
  "node_modules/fast-glob/out/providers/filters/error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils2 = require_utils4();
    var ErrorFilter = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getFilter() {
        return (error) => this._isNonFatalError(error);
      }
      _isNonFatalError(error) {
        return utils2.errno.isEnoentCodeError(error) || this._settings.suppressErrors;
      }
    };
    exports.default = ErrorFilter;
  }
});

// node_modules/fast-glob/out/providers/transformers/entry.js
var require_entry2 = __commonJS({
  "node_modules/fast-glob/out/providers/transformers/entry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils2 = require_utils4();
    var EntryTransformer = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getTransformer() {
        return (entry) => this._transform(entry);
      }
      _transform(entry) {
        let filepath = entry.path;
        if (this._settings.absolute) {
          filepath = utils2.path.makeAbsolute(this._settings.cwd, filepath);
          filepath = utils2.path.unixify(filepath);
        }
        if (this._settings.markDirectories && entry.dirent.isDirectory()) {
          filepath += "/";
        }
        if (!this._settings.objectMode) {
          return filepath;
        }
        return Object.assign(Object.assign({}, entry), { path: filepath });
      }
    };
    exports.default = EntryTransformer;
  }
});

// node_modules/fast-glob/out/providers/provider.js
var require_provider = __commonJS({
  "node_modules/fast-glob/out/providers/provider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var path11 = __require("path");
    var deep_1 = require_deep();
    var entry_1 = require_entry();
    var error_1 = require_error();
    var entry_2 = require_entry2();
    var Provider = class {
      constructor(_settings) {
        this._settings = _settings;
        this.errorFilter = new error_1.default(this._settings);
        this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions());
        this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions());
        this.entryTransformer = new entry_2.default(this._settings);
      }
      _getRootDirectory(task) {
        return path11.resolve(this._settings.cwd, task.base);
      }
      _getReaderOptions(task) {
        const basePath = task.base === "." ? "" : task.base;
        return {
          basePath,
          pathSegmentSeparator: "/",
          concurrency: this._settings.concurrency,
          deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),
          entryFilter: this.entryFilter.getFilter(task.positive, task.negative),
          errorFilter: this.errorFilter.getFilter(),
          followSymbolicLinks: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          stats: this._settings.stats,
          throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
          transform: this.entryTransformer.getTransformer()
        };
      }
      _getMicromatchOptions() {
        return {
          dot: this._settings.dot,
          matchBase: this._settings.baseNameMatch,
          nobrace: !this._settings.braceExpansion,
          nocase: !this._settings.caseSensitiveMatch,
          noext: !this._settings.extglob,
          noglobstar: !this._settings.globstar,
          posix: true,
          strictSlashes: false
        };
      }
    };
    exports.default = Provider;
  }
});

// node_modules/fast-glob/out/providers/async.js
var require_async6 = __commonJS({
  "node_modules/fast-glob/out/providers/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var async_1 = require_async5();
    var provider_1 = require_provider();
    var ProviderAsync = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new async_1.default(this._settings);
      }
      async read(task) {
        const root = this._getRootDirectory(task);
        const options9 = this._getReaderOptions(task);
        const entries = await this.api(root, task, options9);
        return entries.map((entry) => options9.transform(entry));
      }
      api(root, task, options9) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options9);
        }
        return this._reader.static(task.patterns, options9);
      }
    };
    exports.default = ProviderAsync;
  }
});

// node_modules/fast-glob/out/providers/stream.js
var require_stream4 = __commonJS({
  "node_modules/fast-glob/out/providers/stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var stream_1 = __require("stream");
    var stream_2 = require_stream3();
    var provider_1 = require_provider();
    var ProviderStream = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new stream_2.default(this._settings);
      }
      read(task) {
        const root = this._getRootDirectory(task);
        const options9 = this._getReaderOptions(task);
        const source = this.api(root, task, options9);
        const destination = new stream_1.Readable({ objectMode: true, read: () => {
        } });
        source.once("error", (error) => destination.emit("error", error)).on("data", (entry) => destination.emit("data", options9.transform(entry))).once("end", () => destination.emit("end"));
        destination.once("close", () => source.destroy());
        return destination;
      }
      api(root, task, options9) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options9);
        }
        return this._reader.static(task.patterns, options9);
      }
    };
    exports.default = ProviderStream;
  }
});

// node_modules/fast-glob/out/readers/sync.js
var require_sync5 = __commonJS({
  "node_modules/fast-glob/out/readers/sync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var fsStat = require_out();
    var fsWalk = require_out3();
    var reader_1 = require_reader2();
    var ReaderSync = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkSync = fsWalk.walkSync;
        this._statSync = fsStat.statSync;
      }
      dynamic(root, options9) {
        return this._walkSync(root, options9);
      }
      static(patterns, options9) {
        const entries = [];
        for (const pattern of patterns) {
          const filepath = this._getFullEntryPath(pattern);
          const entry = this._getEntry(filepath, pattern, options9);
          if (entry === null || !options9.entryFilter(entry)) {
            continue;
          }
          entries.push(entry);
        }
        return entries;
      }
      _getEntry(filepath, pattern, options9) {
        try {
          const stats = this._getStat(filepath);
          return this._makeEntry(stats, pattern);
        } catch (error) {
          if (options9.errorFilter(error)) {
            return null;
          }
          throw error;
        }
      }
      _getStat(filepath) {
        return this._statSync(filepath, this._fsStatSettings);
      }
    };
    exports.default = ReaderSync;
  }
});

// node_modules/fast-glob/out/providers/sync.js
var require_sync6 = __commonJS({
  "node_modules/fast-glob/out/providers/sync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var sync_1 = require_sync5();
    var provider_1 = require_provider();
    var ProviderSync = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new sync_1.default(this._settings);
      }
      read(task) {
        const root = this._getRootDirectory(task);
        const options9 = this._getReaderOptions(task);
        const entries = this.api(root, task, options9);
        return entries.map(options9.transform);
      }
      api(root, task, options9) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options9);
        }
        return this._reader.static(task.patterns, options9);
      }
    };
    exports.default = ProviderSync;
  }
});

// node_modules/fast-glob/out/settings.js
var require_settings4 = __commonJS({
  "node_modules/fast-glob/out/settings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;
    var fs6 = __require("fs");
    var os = __require("os");
    var CPU_COUNT = Math.max(os.cpus().length, 1);
    exports.DEFAULT_FILE_SYSTEM_ADAPTER = {
      lstat: fs6.lstat,
      lstatSync: fs6.lstatSync,
      stat: fs6.stat,
      statSync: fs6.statSync,
      readdir: fs6.readdir,
      readdirSync: fs6.readdirSync
    };
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.absolute = this._getValue(this._options.absolute, false);
        this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);
        this.braceExpansion = this._getValue(this._options.braceExpansion, true);
        this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);
        this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);
        this.cwd = this._getValue(this._options.cwd, process.cwd());
        this.deep = this._getValue(this._options.deep, Infinity);
        this.dot = this._getValue(this._options.dot, false);
        this.extglob = this._getValue(this._options.extglob, true);
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);
        this.fs = this._getFileSystemMethods(this._options.fs);
        this.globstar = this._getValue(this._options.globstar, true);
        this.ignore = this._getValue(this._options.ignore, []);
        this.markDirectories = this._getValue(this._options.markDirectories, false);
        this.objectMode = this._getValue(this._options.objectMode, false);
        this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);
        this.onlyFiles = this._getValue(this._options.onlyFiles, true);
        this.stats = this._getValue(this._options.stats, false);
        this.suppressErrors = this._getValue(this._options.suppressErrors, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);
        this.unique = this._getValue(this._options.unique, true);
        if (this.onlyDirectories) {
          this.onlyFiles = false;
        }
        if (this.stats) {
          this.objectMode = true;
        }
      }
      _getValue(option, value) {
        return option === void 0 ? value : option;
      }
      _getFileSystemMethods(methods = {}) {
        return Object.assign(Object.assign({}, exports.DEFAULT_FILE_SYSTEM_ADAPTER), methods);
      }
    };
    exports.default = Settings;
  }
});

// node_modules/fast-glob/out/index.js
var require_out4 = __commonJS({
  "node_modules/fast-glob/out/index.js"(exports, module) {
    "use strict";
    var taskManager = require_tasks();
    var patternManager = require_patterns();
    var async_1 = require_async6();
    var stream_1 = require_stream4();
    var sync_1 = require_sync6();
    var settings_1 = require_settings4();
    var utils2 = require_utils4();
    async function FastGlob(source, options9) {
      assertPatternsInput(source);
      const works = getWorks(source, async_1.default, options9);
      const result = await Promise.all(works);
      return utils2.array.flatten(result);
    }
    (function(FastGlob2) {
      function sync(source, options9) {
        assertPatternsInput(source);
        const works = getWorks(source, sync_1.default, options9);
        return utils2.array.flatten(works);
      }
      FastGlob2.sync = sync;
      function stream(source, options9) {
        assertPatternsInput(source);
        const works = getWorks(source, stream_1.default, options9);
        return utils2.stream.merge(works);
      }
      FastGlob2.stream = stream;
      function generateTasks(source, options9) {
        assertPatternsInput(source);
        const patterns = patternManager.transform([].concat(source));
        const settings = new settings_1.default(options9);
        return taskManager.generate(patterns, settings);
      }
      FastGlob2.generateTasks = generateTasks;
      function isDynamicPattern(source, options9) {
        assertPatternsInput(source);
        const settings = new settings_1.default(options9);
        return utils2.pattern.isDynamicPattern(source, settings);
      }
      FastGlob2.isDynamicPattern = isDynamicPattern;
      function escapePath(source) {
        assertPatternsInput(source);
        return utils2.path.escape(source);
      }
      FastGlob2.escapePath = escapePath;
    })(FastGlob || (FastGlob = {}));
    function getWorks(source, _Provider, options9) {
      const patterns = patternManager.transform([].concat(source));
      const settings = new settings_1.default(options9);
      const tasks = taskManager.generate(patterns, settings);
      const provider = new _Provider(settings);
      return tasks.map(provider.read, provider);
    }
    function assertPatternsInput(input) {
      const source = [].concat(input);
      const isValidSource = source.every((item) => utils2.string.isString(item) && !utils2.string.isEmpty(item));
      if (!isValidSource) {
        throw new TypeError("Patterns must be a string (non empty) or an array of strings");
      }
    }
    module.exports = FastGlob;
  }
});

// node_modules/diff/lib/diff/base.js
var require_base = __commonJS({
  "node_modules/diff/lib/diff/base.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = Diff;
    function Diff() {
    }
    Diff.prototype = {
      /*istanbul ignore start*/
      /*istanbul ignore end*/
      diff: function diff(oldString, newString) {
        var options9 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var callback = options9.callback;
        if (typeof options9 === "function") {
          callback = options9;
          options9 = {};
        }
        this.options = options9;
        var self2 = this;
        function done(value) {
          if (callback) {
            setTimeout(function() {
              callback(void 0, value);
            }, 0);
            return true;
          } else {
            return value;
          }
        }
        oldString = this.castInput(oldString);
        newString = this.castInput(newString);
        oldString = this.removeEmpty(this.tokenize(oldString));
        newString = this.removeEmpty(this.tokenize(newString));
        var newLen = newString.length, oldLen = oldString.length;
        var editLength = 1;
        var maxEditLength = newLen + oldLen;
        if (options9.maxEditLength) {
          maxEditLength = Math.min(maxEditLength, options9.maxEditLength);
        }
        var bestPath = [{
          newPos: -1,
          components: []
        }];
        var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);
        if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
          return done([{
            value: this.join(newString),
            count: newString.length
          }]);
        }
        function execEditLength() {
          for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
            var basePath = (
              /*istanbul ignore start*/
              void 0
            );
            var addPath = bestPath[diagonalPath - 1], removePath = bestPath[diagonalPath + 1], _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;
            if (addPath) {
              bestPath[diagonalPath - 1] = void 0;
            }
            var canAdd = addPath && addPath.newPos + 1 < newLen, canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;
            if (!canAdd && !canRemove) {
              bestPath[diagonalPath] = void 0;
              continue;
            }
            if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
              basePath = clonePath(removePath);
              self2.pushComponent(basePath.components, void 0, true);
            } else {
              basePath = addPath;
              basePath.newPos++;
              self2.pushComponent(basePath.components, true, void 0);
            }
            _oldPos = self2.extractCommon(basePath, newString, oldString, diagonalPath);
            if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {
              return done(buildValues(self2, basePath.components, newString, oldString, self2.useLongestToken));
            } else {
              bestPath[diagonalPath] = basePath;
            }
          }
          editLength++;
        }
        if (callback) {
          (function exec() {
            setTimeout(function() {
              if (editLength > maxEditLength) {
                return callback();
              }
              if (!execEditLength()) {
                exec();
              }
            }, 0);
          })();
        } else {
          while (editLength <= maxEditLength) {
            var ret = execEditLength();
            if (ret) {
              return ret;
            }
          }
        }
      },
      /*istanbul ignore start*/
      /*istanbul ignore end*/
      pushComponent: function pushComponent(components, added, removed) {
        var last = components[components.length - 1];
        if (last && last.added === added && last.removed === removed) {
          components[components.length - 1] = {
            count: last.count + 1,
            added,
            removed
          };
        } else {
          components.push({
            count: 1,
            added,
            removed
          });
        }
      },
      /*istanbul ignore start*/
      /*istanbul ignore end*/
      extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
        var newLen = newString.length, oldLen = oldString.length, newPos = basePath.newPos, oldPos = newPos - diagonalPath, commonCount = 0;
        while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
          newPos++;
          oldPos++;
          commonCount++;
        }
        if (commonCount) {
          basePath.components.push({
            count: commonCount
          });
        }
        basePath.newPos = newPos;
        return oldPos;
      },
      /*istanbul ignore start*/
      /*istanbul ignore end*/
      equals: function equals(left, right) {
        if (this.options.comparator) {
          return this.options.comparator(left, right);
        } else {
          return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
        }
      },
      /*istanbul ignore start*/
      /*istanbul ignore end*/
      removeEmpty: function removeEmpty(array) {
        var ret = [];
        for (var i = 0; i < array.length; i++) {
          if (array[i]) {
            ret.push(array[i]);
          }
        }
        return ret;
      },
      /*istanbul ignore start*/
      /*istanbul ignore end*/
      castInput: function castInput(value) {
        return value;
      },
      /*istanbul ignore start*/
      /*istanbul ignore end*/
      tokenize: function tokenize(value) {
        return value.split("");
      },
      /*istanbul ignore start*/
      /*istanbul ignore end*/
      join: function join2(chars) {
        return chars.join("");
      }
    };
    function buildValues(diff, components, newString, oldString, useLongestToken) {
      var componentPos = 0, componentLen = components.length, newPos = 0, oldPos = 0;
      for (; componentPos < componentLen; componentPos++) {
        var component = components[componentPos];
        if (!component.removed) {
          if (!component.added && useLongestToken) {
            var value = newString.slice(newPos, newPos + component.count);
            value = value.map(function(value2, i) {
              var oldValue = oldString[oldPos + i];
              return oldValue.length > value2.length ? oldValue : value2;
            });
            component.value = diff.join(value);
          } else {
            component.value = diff.join(newString.slice(newPos, newPos + component.count));
          }
          newPos += component.count;
          if (!component.added) {
            oldPos += component.count;
          }
        } else {
          component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));
          oldPos += component.count;
          if (componentPos && components[componentPos - 1].added) {
            var tmp = components[componentPos - 1];
            components[componentPos - 1] = components[componentPos];
            components[componentPos] = tmp;
          }
        }
      }
      var lastComponent = components[componentLen - 1];
      if (componentLen > 1 && typeof lastComponent.value === "string" && (lastComponent.added || lastComponent.removed) && diff.equals("", lastComponent.value)) {
        components[componentLen - 2].value += lastComponent.value;
        components.pop();
      }
      return components;
    }
    function clonePath(path11) {
      return {
        newPos: path11.newPos,
        components: path11.components.slice(0)
      };
    }
  }
});

// node_modules/diff/lib/diff/array.js
var require_array3 = __commonJS({
  "node_modules/diff/lib/diff/array.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.diffArrays = diffArrays2;
    exports.arrayDiff = void 0;
    var _base = _interopRequireDefault(require_base());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var arrayDiff = new /*istanbul ignore start*/
    _base[
      /*istanbul ignore start*/
      "default"
      /*istanbul ignore end*/
    ]();
    exports.arrayDiff = arrayDiff;
    arrayDiff.tokenize = function(value) {
      return value.slice();
    };
    arrayDiff.join = arrayDiff.removeEmpty = function(value) {
      return value;
    };
    function diffArrays2(oldArr, newArr, callback) {
      return arrayDiff.diff(oldArr, newArr, callback);
    }
  }
});

// node_modules/js-tokens/index.js
var require_js_tokens = __commonJS({
  "node_modules/js-tokens/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
    exports.matchToToken = function(match) {
      var token = { type: "invalid", value: match[0], closed: void 0 };
      if (match[1])
        token.type = "string", token.closed = !!(match[3] || match[4]);
      else if (match[5])
        token.type = "comment";
      else if (match[6])
        token.type = "comment", token.closed = !!match[7];
      else if (match[8])
        token.type = "regex";
      else if (match[9])
        token.type = "number";
      else if (match[10])
        token.type = "name";
      else if (match[11])
        token.type = "punctuator";
      else if (match[12])
        token.type = "whitespace";
      return token;
    };
  }
});

// node_modules/@babel/helper-validator-identifier/lib/identifier.js
var require_identifier = __commonJS({
  "node_modules/@babel/helper-validator-identifier/lib/identifier.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isIdentifierChar = isIdentifierChar;
    exports.isIdentifierName = isIdentifierName;
    exports.isIdentifierStart = isIdentifierStart;
    var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
    var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
    var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
    var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
    var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191];
    var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
    function isInAstralSet(code, set) {
      let pos = 65536;
      for (let i = 0, length = set.length; i < length; i += 2) {
        pos += set[i];
        if (pos > code)
          return false;
        pos += set[i + 1];
        if (pos >= code)
          return true;
      }
      return false;
    }
    function isIdentifierStart(code) {
      if (code < 65)
        return code === 36;
      if (code <= 90)
        return true;
      if (code < 97)
        return code === 95;
      if (code <= 122)
        return true;
      if (code <= 65535) {
        return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
      }
      return isInAstralSet(code, astralIdentifierStartCodes);
    }
    function isIdentifierChar(code) {
      if (code < 48)
        return code === 36;
      if (code < 58)
        return true;
      if (code < 65)
        return false;
      if (code <= 90)
        return true;
      if (code < 97)
        return code === 95;
      if (code <= 122)
        return true;
      if (code <= 65535) {
        return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
      }
      return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
    }
    function isIdentifierName(name) {
      let isFirst = true;
      for (let i = 0; i < name.length; i++) {
        let cp = name.charCodeAt(i);
        if ((cp & 64512) === 55296 && i + 1 < name.length) {
          const trail = name.charCodeAt(++i);
          if ((trail & 64512) === 56320) {
            cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
          }
        }
        if (isFirst) {
          isFirst = false;
          if (!isIdentifierStart(cp)) {
            return false;
          }
        } else if (!isIdentifierChar(cp)) {
          return false;
        }
      }
      return !isFirst;
    }
  }
});

// node_modules/@babel/helper-validator-identifier/lib/keyword.js
var require_keyword = __commonJS({
  "node_modules/@babel/helper-validator-identifier/lib/keyword.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isKeyword = isKeyword;
    exports.isReservedWord = isReservedWord;
    exports.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
    exports.isStrictBindReservedWord = isStrictBindReservedWord;
    exports.isStrictReservedWord = isStrictReservedWord;
    var reservedWords = {
      keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
      strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
      strictBind: ["eval", "arguments"]
    };
    var keywords = new Set(reservedWords.keyword);
    var reservedWordsStrictSet = new Set(reservedWords.strict);
    var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
    function isReservedWord(word, inModule) {
      return inModule && word === "await" || word === "enum";
    }
    function isStrictReservedWord(word, inModule) {
      return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
    }
    function isStrictBindOnlyReservedWord(word) {
      return reservedWordsStrictBindSet.has(word);
    }
    function isStrictBindReservedWord(word, inModule) {
      return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
    }
    function isKeyword(word) {
      return keywords.has(word);
    }
  }
});

// node_modules/@babel/helper-validator-identifier/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/@babel/helper-validator-identifier/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "isIdentifierChar", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierChar;
      }
    });
    Object.defineProperty(exports, "isIdentifierName", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierName;
      }
    });
    Object.defineProperty(exports, "isIdentifierStart", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierStart;
      }
    });
    Object.defineProperty(exports, "isKeyword", {
      enumerable: true,
      get: function() {
        return _keyword.isKeyword;
      }
    });
    Object.defineProperty(exports, "isReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isReservedWord;
      }
    });
    Object.defineProperty(exports, "isStrictBindOnlyReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictBindOnlyReservedWord;
      }
    });
    Object.defineProperty(exports, "isStrictBindReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictBindReservedWord;
      }
    });
    Object.defineProperty(exports, "isStrictReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictReservedWord;
      }
    });
    var _identifier = require_identifier();
    var _keyword = require_keyword();
  }
});

// node_modules/@babel/highlight/node_modules/escape-string-regexp/index.js
var require_escape_string_regexp2 = __commonJS({
  "node_modules/@babel/highlight/node_modules/escape-string-regexp/index.js"(exports, module) {
    "use strict";
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    module.exports = function(str) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      return str.replace(matchOperatorsRe, "\\$&");
    };
  }
});

// node_modules/@babel/highlight/node_modules/has-flag/index.js
var require_has_flag2 = __commonJS({
  "node_modules/@babel/highlight/node_modules/has-flag/index.js"(exports, module) {
    "use strict";
    module.exports = (flag, argv) => {
      argv = argv || process.argv;
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const pos = argv.indexOf(prefix + flag);
      const terminatorPos = argv.indexOf("--");
      return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
    };
  }
});

// node_modules/@babel/highlight/node_modules/supports-color/index.js
var require_supports_color2 = __commonJS({
  "node_modules/@babel/highlight/node_modules/supports-color/index.js"(exports, module) {
    "use strict";
    var os = __require("os");
    var hasFlag = require_has_flag2();
    var env = process.env;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
      forceColor = false;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = true;
    }
    if ("FORCE_COLOR" in env) {
      forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(stream) {
      if (forceColor === false) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (stream && !stream.isTTY && forceColor !== true) {
        return 0;
      }
      const min = forceColor ? 1 : 0;
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      if (env.TERM === "dumb") {
        return min;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream);
      return translateLevel(level);
    }
    module.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel(process.stdout),
      stderr: getSupportLevel(process.stderr)
    };
  }
});

// node_modules/@babel/highlight/node_modules/chalk/templates.js
var require_templates2 = __commonJS({
  "node_modules/@babel/highlight/node_modules/chalk/templates.js"(exports, module) {
    "use strict";
    var TEMPLATE_REGEX = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    var STRING_REGEX2 = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    var ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;
    var ESCAPES = /* @__PURE__ */ new Map([
      ["n", "\n"],
      ["r", "\r"],
      ["t", "	"],
      ["b", "\b"],
      ["f", "\f"],
      ["v", "\v"],
      ["0", "\0"],
      ["\\", "\\"],
      ["e", "\x1B"],
      ["a", "\x07"]
    ]);
    function unescape(c) {
      if (c[0] === "u" && c.length === 5 || c[0] === "x" && c.length === 3) {
        return String.fromCharCode(parseInt(c.slice(1), 16));
      }
      return ESCAPES.get(c) || c;
    }
    function parseArguments(name, args) {
      const results = [];
      const chunks = args.trim().split(/\s*,\s*/g);
      let matches;
      for (const chunk of chunks) {
        if (!isNaN(chunk)) {
          results.push(Number(chunk));
        } else if (matches = chunk.match(STRING_REGEX2)) {
          results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, chr) => escape ? unescape(escape) : chr));
        } else {
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
        }
      }
      return results;
    }
    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      const results = [];
      let matches;
      while ((matches = STYLE_REGEX.exec(style)) !== null) {
        const name = matches[1];
        if (matches[2]) {
          const args = parseArguments(name, matches[2]);
          results.push([name].concat(args));
        } else {
          results.push([name]);
        }
      }
      return results;
    }
    function buildStyle(chalk, styles) {
      const enabled = {};
      for (const layer of styles) {
        for (const style of layer.styles) {
          enabled[style[0]] = layer.inverse ? null : style.slice(1);
        }
      }
      let current = chalk;
      for (const styleName of Object.keys(enabled)) {
        if (Array.isArray(enabled[styleName])) {
          if (!(styleName in current)) {
            throw new Error(`Unknown Chalk style: ${styleName}`);
          }
          if (enabled[styleName].length > 0) {
            current = current[styleName].apply(current, enabled[styleName]);
          } else {
            current = current[styleName];
          }
        }
      }
      return current;
    }
    module.exports = (chalk, tmp) => {
      const styles = [];
      const chunks = [];
      let chunk = [];
      tmp.replace(TEMPLATE_REGEX, (m, escapeChar, inverse, style, close, chr) => {
        if (escapeChar) {
          chunk.push(unescape(escapeChar));
        } else if (style) {
          const str = chunk.join("");
          chunk = [];
          chunks.push(styles.length === 0 ? str : buildStyle(chalk, styles)(str));
          styles.push({ inverse, styles: parseStyle(style) });
        } else if (close) {
          if (styles.length === 0) {
            throw new Error("Found extraneous } in Chalk template literal");
          }
          chunks.push(buildStyle(chalk, styles)(chunk.join("")));
          chunk = [];
          styles.pop();
        } else {
          chunk.push(chr);
        }
      });
      chunks.push(chunk.join(""));
      if (styles.length > 0) {
        const errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMsg);
      }
      return chunks.join("");
    };
  }
});

// node_modules/@babel/highlight/node_modules/chalk/index.js
var require_chalk2 = __commonJS({
  "node_modules/@babel/highlight/node_modules/chalk/index.js"(exports, module) {
    "use strict";
    var escapeStringRegexp2 = require_escape_string_regexp2();
    var ansiStyles = require_ansi_styles();
    var stdoutColor = require_supports_color2().stdout;
    var template = require_templates2();
    var isSimpleWindowsTerm = process.platform === "win32" && !(process.env.TERM || "").toLowerCase().startsWith("xterm");
    var levelMapping = ["ansi", "ansi", "ansi256", "ansi16m"];
    var skipModels = /* @__PURE__ */ new Set(["gray"]);
    var styles = /* @__PURE__ */ Object.create(null);
    function applyOptions(obj, options9) {
      options9 = options9 || {};
      const scLevel = stdoutColor ? stdoutColor.level : 0;
      obj.level = options9.level === void 0 ? scLevel : options9.level;
      obj.enabled = "enabled" in options9 ? options9.enabled : obj.level > 0;
    }
    function Chalk(options9) {
      if (!this || !(this instanceof Chalk) || this.template) {
        const chalk = {};
        applyOptions(chalk, options9);
        chalk.template = function() {
          const args = [].slice.call(arguments);
          return chalkTag.apply(null, [chalk.template].concat(args));
        };
        Object.setPrototypeOf(chalk, Chalk.prototype);
        Object.setPrototypeOf(chalk.template, chalk);
        chalk.template.constructor = Chalk;
        return chalk.template;
      }
      applyOptions(this, options9);
    }
    if (isSimpleWindowsTerm) {
      ansiStyles.blue.open = "\x1B[94m";
    }
    for (const key of Object.keys(ansiStyles)) {
      ansiStyles[key].closeRe = new RegExp(escapeStringRegexp2(ansiStyles[key].close), "g");
      styles[key] = {
        get() {
          const codes2 = ansiStyles[key];
          return build.call(this, this._styles ? this._styles.concat(codes2) : [codes2], this._empty, key);
        }
      };
    }
    styles.visible = {
      get() {
        return build.call(this, this._styles || [], true, "visible");
      }
    };
    ansiStyles.color.closeRe = new RegExp(escapeStringRegexp2(ansiStyles.color.close), "g");
    for (const model of Object.keys(ansiStyles.color.ansi)) {
      if (skipModels.has(model)) {
        continue;
      }
      styles[model] = {
        get() {
          const level = this.level;
          return function() {
            const open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);
            const codes2 = {
              open,
              close: ansiStyles.color.close,
              closeRe: ansiStyles.color.closeRe
            };
            return build.call(this, this._styles ? this._styles.concat(codes2) : [codes2], this._empty, model);
          };
        }
      };
    }
    ansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp2(ansiStyles.bgColor.close), "g");
    for (const model of Object.keys(ansiStyles.bgColor.ansi)) {
      if (skipModels.has(model)) {
        continue;
      }
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles[bgModel] = {
        get() {
          const level = this.level;
          return function() {
            const open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);
            const codes2 = {
              open,
              close: ansiStyles.bgColor.close,
              closeRe: ansiStyles.bgColor.closeRe
            };
            return build.call(this, this._styles ? this._styles.concat(codes2) : [codes2], this._empty, model);
          };
        }
      };
    }
    var proto = Object.defineProperties(() => {
    }, styles);
    function build(_styles, _empty, key) {
      const builder = function() {
        return applyStyle.apply(builder, arguments);
      };
      builder._styles = _styles;
      builder._empty = _empty;
      const self2 = this;
      Object.defineProperty(builder, "level", {
        enumerable: true,
        get() {
          return self2.level;
        },
        set(level) {
          self2.level = level;
        }
      });
      Object.defineProperty(builder, "enabled", {
        enumerable: true,
        get() {
          return self2.enabled;
        },
        set(enabled) {
          self2.enabled = enabled;
        }
      });
      builder.hasGrey = this.hasGrey || key === "gray" || key === "grey";
      builder.__proto__ = proto;
      return builder;
    }
    function applyStyle() {
      const args = arguments;
      const argsLen = args.length;
      let str = String(arguments[0]);
      if (argsLen === 0) {
        return "";
      }
      if (argsLen > 1) {
        for (let a = 1; a < argsLen; a++) {
          str += " " + args[a];
        }
      }
      if (!this.enabled || this.level <= 0 || !str) {
        return this._empty ? "" : str;
      }
      const originalDim = ansiStyles.dim.open;
      if (isSimpleWindowsTerm && this.hasGrey) {
        ansiStyles.dim.open = "";
      }
      for (const code of this._styles.slice().reverse()) {
        str = code.open + str.replace(code.closeRe, code.open) + code.close;
        str = str.replace(/\r?\n/g, `${code.close}$&${code.open}`);
      }
      ansiStyles.dim.open = originalDim;
      return str;
    }
    function chalkTag(chalk, strings) {
      if (!Array.isArray(strings)) {
        return [].slice.call(arguments, 1).join(" ");
      }
      const args = [].slice.call(arguments, 2);
      const parts = [strings.raw[0]];
      for (let i = 1; i < strings.length; i++) {
        parts.push(String(args[i - 1]).replace(/[{}\\]/g, "\\$&"));
        parts.push(String(strings.raw[i]));
      }
      return template(chalk, parts.join(""));
    }
    Object.defineProperties(Chalk.prototype, styles);
    module.exports = Chalk();
    module.exports.supportsColor = stdoutColor;
    module.exports.default = module.exports;
  }
});

// node_modules/@babel/highlight/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/@babel/highlight/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = highlight;
    exports.getChalk = getChalk;
    exports.shouldHighlight = shouldHighlight;
    var _jsTokens = require_js_tokens();
    var _helperValidatorIdentifier = require_lib2();
    var _chalk = require_chalk2();
    var sometimesKeywords = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of", "set"]);
    function getDefs(chalk) {
      return {
        keyword: chalk.cyan,
        capitalized: chalk.yellow,
        jsxIdentifier: chalk.yellow,
        punctuator: chalk.yellow,
        number: chalk.magenta,
        string: chalk.green,
        regex: chalk.magenta,
        comment: chalk.grey,
        invalid: chalk.white.bgRed.bold
      };
    }
    var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
    var BRACKET = /^[()[\]{}]$/;
    var tokenize;
    {
      const JSX_TAG = /^[a-z][\w-]*$/i;
      const getTokenType = function(token, offset, text) {
        if (token.type === "name") {
          if ((0, _helperValidatorIdentifier.isKeyword)(token.value) || (0, _helperValidatorIdentifier.isStrictReservedWord)(token.value, true) || sometimesKeywords.has(token.value)) {
            return "keyword";
          }
          if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.slice(offset - 2, offset) == "</")) {
            return "jsxIdentifier";
          }
          if (token.value[0] !== token.value[0].toLowerCase()) {
            return "capitalized";
          }
        }
        if (token.type === "punctuator" && BRACKET.test(token.value)) {
          return "bracket";
        }
        if (token.type === "invalid" && (token.value === "@" || token.value === "#")) {
          return "punctuator";
        }
        return token.type;
      };
      tokenize = function* (text) {
        let match;
        while (match = _jsTokens.default.exec(text)) {
          const token = _jsTokens.matchToToken(match);
          yield {
            type: getTokenType(token, match.index, text),
            value: token.value
          };
        }
      };
    }
    function highlightTokens(defs, text) {
      let highlighted = "";
      for (const {
        type,
        value
      } of tokenize(text)) {
        const colorize = defs[type];
        if (colorize) {
          highlighted += value.split(NEWLINE).map((str) => colorize(str)).join("\n");
        } else {
          highlighted += value;
        }
      }
      return highlighted;
    }
    function shouldHighlight(options9) {
      return !!_chalk.supportsColor || options9.forceColor;
    }
    function getChalk(options9) {
      return options9.forceColor ? new _chalk.constructor({
        enabled: true,
        level: 1
      }) : _chalk;
    }
    function highlight(code, options9 = {}) {
      if (code !== "" && shouldHighlight(options9)) {
        const chalk = getChalk(options9);
        const defs = getDefs(chalk);
        return highlightTokens(defs, code);
      } else {
        return code;
      }
    }
  }
});

// node_modules/@babel/code-frame/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/@babel/code-frame/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.codeFrameColumns = codeFrameColumns2;
    exports.default = _default;
    var _highlight = require_lib3();
    var deprecationWarningShown = false;
    function getDefs(chalk) {
      return {
        gutter: chalk.grey,
        marker: chalk.red.bold,
        message: chalk.red.bold
      };
    }
    var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
    function getMarkerLines(loc, source, opts) {
      const startLoc = Object.assign({
        column: 0,
        line: -1
      }, loc.start);
      const endLoc = Object.assign({}, startLoc, loc.end);
      const {
        linesAbove = 2,
        linesBelow = 3
      } = opts || {};
      const startLine = startLoc.line;
      const startColumn = startLoc.column;
      const endLine = endLoc.line;
      const endColumn = endLoc.column;
      let start = Math.max(startLine - (linesAbove + 1), 0);
      let end = Math.min(source.length, endLine + linesBelow);
      if (startLine === -1) {
        start = 0;
      }
      if (endLine === -1) {
        end = source.length;
      }
      const lineDiff = endLine - startLine;
      const markerLines = {};
      if (lineDiff) {
        for (let i = 0; i <= lineDiff; i++) {
          const lineNumber = i + startLine;
          if (!startColumn) {
            markerLines[lineNumber] = true;
          } else if (i === 0) {
            const sourceLength = source[lineNumber - 1].length;
            markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];
          } else if (i === lineDiff) {
            markerLines[lineNumber] = [0, endColumn];
          } else {
            const sourceLength = source[lineNumber - i].length;
            markerLines[lineNumber] = [0, sourceLength];
          }
        }
      } else {
        if (startColumn === endColumn) {
          if (startColumn) {
            markerLines[startLine] = [startColumn, 0];
          } else {
            markerLines[startLine] = true;
          }
        } else {
          markerLines[startLine] = [startColumn, endColumn - startColumn];
        }
      }
      return {
        start,
        end,
        markerLines
      };
    }
    function codeFrameColumns2(rawLines, loc, opts = {}) {
      const highlighted = (opts.highlightCode || opts.forceColor) && (0, _highlight.shouldHighlight)(opts);
      const chalk = (0, _highlight.getChalk)(opts);
      const defs = getDefs(chalk);
      const maybeHighlight = (chalkFn, string) => {
        return highlighted ? chalkFn(string) : string;
      };
      const lines = rawLines.split(NEWLINE);
      const {
        start,
        end,
        markerLines
      } = getMarkerLines(loc, lines, opts);
      const hasColumns = loc.start && typeof loc.start.column === "number";
      const numberMaxWidth = String(end).length;
      const highlightedLines = highlighted ? (0, _highlight.default)(rawLines, opts) : rawLines;
      let frame = highlightedLines.split(NEWLINE, end).slice(start, end).map((line2, index) => {
        const number = start + 1 + index;
        const paddedNumber = ` ${number}`.slice(-numberMaxWidth);
        const gutter = ` ${paddedNumber} |`;
        const hasMarker = markerLines[number];
        const lastMarkerLine = !markerLines[number + 1];
        if (hasMarker) {
          let markerLine = "";
          if (Array.isArray(hasMarker)) {
            const markerSpacing = line2.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " ");
            const numberOfMarkers = hasMarker[1] || 1;
            markerLine = ["\n ", maybeHighlight(defs.gutter, gutter.replace(/\d/g, " ")), " ", markerSpacing, maybeHighlight(defs.marker, "^").repeat(numberOfMarkers)].join("");
            if (lastMarkerLine && opts.message) {
              markerLine += " " + maybeHighlight(defs.message, opts.message);
            }
          }
          return [maybeHighlight(defs.marker, ">"), maybeHighlight(defs.gutter, gutter), line2.length > 0 ? ` ${line2}` : "", markerLine].join("");
        } else {
          return ` ${maybeHighlight(defs.gutter, gutter)}${line2.length > 0 ? ` ${line2}` : ""}`;
        }
      }).join("\n");
      if (opts.message && !hasColumns) {
        frame = `${" ".repeat(numberMaxWidth + 1)}${opts.message}
${frame}`;
      }
      if (highlighted) {
        return chalk.reset(frame);
      } else {
        return frame;
      }
    }
    function _default(rawLines, lineNumber, colNumber, opts = {}) {
      if (!deprecationWarningShown) {
        deprecationWarningShown = true;
        const message = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
        if (process.emitWarning) {
          process.emitWarning(message, "DeprecationWarning");
        } else {
          const deprecationError = new Error(message);
          deprecationError.name = "DeprecationWarning";
          console.warn(new Error(message));
        }
      }
      colNumber = Math.max(colNumber, 0);
      const location = {
        start: {
          column: colNumber,
          line: lineNumber
        }
      };
      return codeFrameColumns2(rawLines, location, opts);
    }
  }
});

// node_modules/n-readlines/readlines.js
var require_readlines = __commonJS({
  "node_modules/n-readlines/readlines.js"(exports, module) {
    "use strict";
    var fs6 = __require("fs");
    var LineByLine = class {
      constructor(file, options9) {
        options9 = options9 || {};
        if (!options9.readChunk)
          options9.readChunk = 1024;
        if (!options9.newLineCharacter) {
          options9.newLineCharacter = 10;
        } else {
          options9.newLineCharacter = options9.newLineCharacter.charCodeAt(0);
        }
        if (typeof file === "number") {
          this.fd = file;
        } else {
          this.fd = fs6.openSync(file, "r");
        }
        this.options = options9;
        this.newLineCharacter = options9.newLineCharacter;
        this.reset();
      }
      _searchInBuffer(buffer, hexNeedle) {
        let found = -1;
        for (let i = 0; i <= buffer.length; i++) {
          let b_byte = buffer[i];
          if (b_byte === hexNeedle) {
            found = i;
            break;
          }
        }
        return found;
      }
      reset() {
        this.eofReached = false;
        this.linesCache = [];
        this.fdPosition = 0;
      }
      close() {
        fs6.closeSync(this.fd);
        this.fd = null;
      }
      _extractLines(buffer) {
        let line2;
        const lines = [];
        let bufferPosition = 0;
        let lastNewLineBufferPosition = 0;
        while (true) {
          let bufferPositionValue = buffer[bufferPosition++];
          if (bufferPositionValue === this.newLineCharacter) {
            line2 = buffer.slice(lastNewLineBufferPosition, bufferPosition);
            lines.push(line2);
            lastNewLineBufferPosition = bufferPosition;
          } else if (bufferPositionValue === void 0) {
            break;
          }
        }
        let leftovers = buffer.slice(lastNewLineBufferPosition, bufferPosition);
        if (leftovers.length) {
          lines.push(leftovers);
        }
        return lines;
      }
      _readChunk(lineLeftovers) {
        let totalBytesRead = 0;
        let bytesRead;
        const buffers = [];
        do {
          const readBuffer = Buffer.alloc(this.options.readChunk);
          bytesRead = fs6.readSync(this.fd, readBuffer, 0, this.options.readChunk, this.fdPosition);
          totalBytesRead = totalBytesRead + bytesRead;
          this.fdPosition = this.fdPosition + bytesRead;
          buffers.push(readBuffer);
        } while (bytesRead && this._searchInBuffer(buffers[buffers.length - 1], this.options.newLineCharacter) === -1);
        let bufferData = Buffer.concat(buffers);
        if (bytesRead < this.options.readChunk) {
          this.eofReached = true;
          bufferData = bufferData.slice(0, totalBytesRead);
        }
        if (totalBytesRead) {
          this.linesCache = this._extractLines(bufferData);
          if (lineLeftovers) {
            this.linesCache[0] = Buffer.concat([lineLeftovers, this.linesCache[0]]);
          }
        }
        return totalBytesRead;
      }
      next() {
        if (!this.fd)
          return false;
        let line2 = false;
        if (this.eofReached && this.linesCache.length === 0) {
          return line2;
        }
        let bytesRead;
        if (!this.linesCache.length) {
          bytesRead = this._readChunk();
        }
        if (this.linesCache.length) {
          line2 = this.linesCache.shift();
          const lastLineCharacter = line2[line2.length - 1];
          if (lastLineCharacter !== this.newLineCharacter) {
            bytesRead = this._readChunk(line2);
            if (bytesRead) {
              line2 = this.linesCache.shift();
            }
          }
        }
        if (this.eofReached && this.linesCache.length === 0) {
          this.close();
        }
        if (line2 && line2[line2.length - 1] === this.newLineCharacter) {
          line2 = line2.slice(0, line2.length - 1);
        }
        return line2;
      }
    };
    module.exports = LineByLine;
  }
});

// node_modules/p-defer/index.js
var require_p_defer = __commonJS({
  "node_modules/p-defer/index.js"(exports, module) {
    "use strict";
    module.exports = () => {
      const ret = {};
      ret.promise = new Promise((resolve2, reject) => {
        ret.resolve = resolve2;
        ret.reject = reject;
      });
      return ret;
    };
  }
});

// node_modules/map-age-cleaner/dist/index.js
var require_dist = __commonJS({
  "node_modules/map-age-cleaner/dist/index.js"(exports, module) {
    "use strict";
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : new P(function(resolve3) {
            resolve3(result.value);
          }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var p_defer_1 = __importDefault2(require_p_defer());
    function mapAgeCleaner2(map, property = "maxAge") {
      let processingKey;
      let processingTimer;
      let processingDeferred;
      const cleanup = () => __awaiter2(this, void 0, void 0, function* () {
        if (processingKey !== void 0) {
          return;
        }
        const setupTimer = (item) => __awaiter2(this, void 0, void 0, function* () {
          processingDeferred = p_defer_1.default();
          const delay = item[1][property] - Date.now();
          if (delay <= 0) {
            map.delete(item[0]);
            processingDeferred.resolve();
            return;
          }
          processingKey = item[0];
          processingTimer = setTimeout(() => {
            map.delete(item[0]);
            if (processingDeferred) {
              processingDeferred.resolve();
            }
          }, delay);
          if (typeof processingTimer.unref === "function") {
            processingTimer.unref();
          }
          return processingDeferred.promise;
        });
        try {
          for (const entry of map) {
            yield setupTimer(entry);
          }
        } catch (_a) {
        }
        processingKey = void 0;
      });
      const reset = () => {
        processingKey = void 0;
        if (processingTimer !== void 0) {
          clearTimeout(processingTimer);
          processingTimer = void 0;
        }
        if (processingDeferred !== void 0) {
          processingDeferred.reject(void 0);
          processingDeferred = void 0;
        }
      };
      const originalSet = map.set.bind(map);
      map.set = (key, value) => {
        if (map.has(key)) {
          map.delete(key);
        }
        const result = originalSet(key, value);
        if (processingKey && processingKey === key) {
          reset();
        }
        cleanup();
        return result;
      };
      cleanup();
      return map;
    }
    exports.default = mapAgeCleaner2;
    module.exports = mapAgeCleaner2;
    module.exports.default = mapAgeCleaner2;
  }
});

// node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/semver/internal/debug.js"(exports, module) {
    var debug2 = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module.exports = debug2;
  }
});

// node_modules/semver/internal/constants.js
var require_constants4 = __commonJS({
  "node_modules/semver/internal/constants.js"(exports, module) {
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    module.exports = {
      SEMVER_SPEC_VERSION,
      MAX_LENGTH,
      MAX_SAFE_INTEGER,
      MAX_SAFE_COMPONENT_LENGTH
    };
  }
});

// node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/semver/internal/re.js"(exports, module) {
    var { MAX_SAFE_COMPONENT_LENGTH } = require_constants4();
    var debug2 = require_debug();
    exports = module.exports = {};
    var re = exports.re = [];
    var src = exports.src = [];
    var t = exports.t = {};
    var R = 0;
    var createToken = (name, value, isGlobal) => {
      const index = R++;
      debug2(name, index, value);
      t[name] = index;
      src[index] = value;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "[0-9]+");
    createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*");
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", "[0-9A-Za-z-]+");
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/semver/internal/parse-options.js"(exports, module) {
    var opts = ["includePrerelease", "loose", "rtl"];
    var parseOptions = (options9) => !options9 ? {} : typeof options9 !== "object" ? { loose: true } : opts.filter((k) => options9[k]).reduce((o, k) => {
      o[k] = true;
      return o;
    }, {});
    module.exports = parseOptions;
  }
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/semver/internal/identifiers.js"(exports, module) {
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/semver/classes/semver.js"(exports, module) {
    var debug2 = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants4();
    var { re, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class {
      constructor(version, options9) {
        options9 = parseOptions(options9);
        if (version instanceof SemVer) {
          if (version.loose === !!options9.loose && version.includePrerelease === !!options9.includePrerelease) {
            return version;
          } else {
            version = version.version;
          }
        } else if (typeof version !== "string") {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        if (version.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug2("SemVer", version, options9);
        this.options = options9;
        this.loose = !!options9.loose;
        this.includePrerelease = !!options9.includePrerelease;
        const m = version.trim().match(options9.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        this.raw = version;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug2("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug2("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug2("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier);
            this.inc("pre", identifier);
            break;
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier);
            }
            this.inc("pre", identifier);
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          case "pre":
            if (this.prerelease.length === 0) {
              this.prerelease = [0];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                this.prerelease.push(0);
              }
            }
            if (identifier) {
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = [identifier, 0];
                }
              } else {
                this.prerelease = [identifier, 0];
              }
            }
            break;
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.format();
        this.raw = this.version;
        return this;
      }
    };
    module.exports = SemVer;
  }
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/semver/functions/compare.js"(exports, module) {
    var SemVer = require_semver();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module.exports = compare;
  }
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/semver/functions/gte.js"(exports, module) {
    var compare = require_compare();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module.exports = gte;
  }
});

// node_modules/pseudomap/pseudomap.js
var require_pseudomap = __commonJS({
  "node_modules/pseudomap/pseudomap.js"(exports, module) {
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    module.exports = PseudoMap;
    function PseudoMap(set2) {
      if (!(this instanceof PseudoMap))
        throw new TypeError("Constructor PseudoMap requires 'new'");
      this.clear();
      if (set2) {
        if (set2 instanceof PseudoMap || typeof Map === "function" && set2 instanceof Map)
          set2.forEach(function(value, key) {
            this.set(key, value);
          }, this);
        else if (Array.isArray(set2))
          set2.forEach(function(kv) {
            this.set(kv[0], kv[1]);
          }, this);
        else
          throw new TypeError("invalid argument");
      }
    }
    PseudoMap.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      Object.keys(this._data).forEach(function(k) {
        if (k !== "size")
          fn.call(thisp, this._data[k].value, this._data[k].key);
      }, this);
    };
    PseudoMap.prototype.has = function(k) {
      return !!find(this._data, k);
    };
    PseudoMap.prototype.get = function(k) {
      var res = find(this._data, k);
      return res && res.value;
    };
    PseudoMap.prototype.set = function(k, v) {
      set(this._data, k, v);
    };
    PseudoMap.prototype.delete = function(k) {
      var res = find(this._data, k);
      if (res) {
        delete this._data[res._index];
        this._data.size--;
      }
    };
    PseudoMap.prototype.clear = function() {
      var data = /* @__PURE__ */ Object.create(null);
      data.size = 0;
      Object.defineProperty(this, "_data", {
        value: data,
        enumerable: false,
        configurable: true,
        writable: false
      });
    };
    Object.defineProperty(PseudoMap.prototype, "size", {
      get: function() {
        return this._data.size;
      },
      set: function(n) {
      },
      enumerable: true,
      configurable: true
    });
    PseudoMap.prototype.values = PseudoMap.prototype.keys = PseudoMap.prototype.entries = function() {
      throw new Error("iterators are not implemented in this version");
    };
    function same(a, b) {
      return a === b || a !== a && b !== b;
    }
    function Entry(k, v, i) {
      this.key = k;
      this.value = v;
      this._index = i;
    }
    function find(data, k) {
      for (var i = 0, s = "_" + k, key = s; hasOwnProperty2.call(data, key); key = s + i++) {
        if (same(data[key].key, k))
          return data[key];
      }
    }
    function set(data, k, v) {
      for (var i = 0, s = "_" + k, key = s; hasOwnProperty2.call(data, key); key = s + i++) {
        if (same(data[key].key, k)) {
          data[key].value = v;
          return;
        }
      }
      data.size++;
      data[key] = new Entry(k, v, key);
    }
  }
});

// node_modules/pseudomap/map.js
var require_map = __commonJS({
  "node_modules/pseudomap/map.js"(exports, module) {
    if (process.env.npm_package_name === "pseudomap" && process.env.npm_lifecycle_script === "test")
      process.env.TEST_PSEUDOMAP = "true";
    if (typeof Map === "function" && !process.env.TEST_PSEUDOMAP) {
      module.exports = Map;
    } else {
      module.exports = require_pseudomap();
    }
  }
});

// node_modules/editorconfig/node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "node_modules/editorconfig/node_modules/yallist/yallist.js"(exports, module) {
    module.exports = Yallist;
    Yallist.Node = Node;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self2 = this;
      if (!(self2 instanceof Yallist)) {
        self2 = new Yallist();
      }
      self2.tail = null;
      self2.head = null;
      self2.length = 0;
      if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
          self2.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self2.push(arguments[i]);
        }
      }
      return self2;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        walker = walker.next;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        walker = walker.prev;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = 0; walker !== null; i++) {
        acc = fn(acc, walker.value, i);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
        walker = walker.next;
      }
      for (; walker !== null && i < to; i++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
        walker = walker.prev;
      }
      for (; walker !== null && i > from; i--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function push(self2, item) {
      self2.tail = new Node(item, self2.tail, null, self2);
      if (!self2.head) {
        self2.head = self2.tail;
      }
      self2.length++;
    }
    function unshift(self2, item) {
      self2.head = new Node(item, null, self2.head, self2);
      if (!self2.tail) {
        self2.tail = self2.head;
      }
      self2.length++;
    }
    function Node(value, prev, next, list) {
      if (!(this instanceof Node)) {
        return new Node(value, prev, next, list);
      }
      this.list = list;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
  }
});

// node_modules/editorconfig/node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "node_modules/editorconfig/node_modules/lru-cache/index.js"(exports, module) {
    "use strict";
    module.exports = LRUCache;
    var Map2 = require_map();
    var util = __require("util");
    var Yallist = require_yallist();
    var hasSymbol = typeof Symbol === "function" && process.env._nodeLRUCacheForceNoSymbol !== "1";
    var makeSymbol;
    if (hasSymbol) {
      makeSymbol = function(key) {
        return Symbol(key);
      };
    } else {
      makeSymbol = function(key) {
        return "_" + key;
      };
    }
    var MAX = makeSymbol("max");
    var LENGTH = makeSymbol("length");
    var LENGTH_CALCULATOR = makeSymbol("lengthCalculator");
    var ALLOW_STALE = makeSymbol("allowStale");
    var MAX_AGE = makeSymbol("maxAge");
    var DISPOSE = makeSymbol("dispose");
    var NO_DISPOSE_ON_SET = makeSymbol("noDisposeOnSet");
    var LRU_LIST = makeSymbol("lruList");
    var CACHE = makeSymbol("cache");
    function naiveLength() {
      return 1;
    }
    function LRUCache(options9) {
      if (!(this instanceof LRUCache)) {
        return new LRUCache(options9);
      }
      if (typeof options9 === "number") {
        options9 = { max: options9 };
      }
      if (!options9) {
        options9 = {};
      }
      var max = this[MAX] = options9.max;
      if (!max || !(typeof max === "number") || max <= 0) {
        this[MAX] = Infinity;
      }
      var lc = options9.length || naiveLength;
      if (typeof lc !== "function") {
        lc = naiveLength;
      }
      this[LENGTH_CALCULATOR] = lc;
      this[ALLOW_STALE] = options9.stale || false;
      this[MAX_AGE] = options9.maxAge || 0;
      this[DISPOSE] = options9.dispose;
      this[NO_DISPOSE_ON_SET] = options9.noDisposeOnSet || false;
      this.reset();
    }
    Object.defineProperty(LRUCache.prototype, "max", {
      set: function(mL) {
        if (!mL || !(typeof mL === "number") || mL <= 0) {
          mL = Infinity;
        }
        this[MAX] = mL;
        trim2(this);
      },
      get: function() {
        return this[MAX];
      },
      enumerable: true
    });
    Object.defineProperty(LRUCache.prototype, "allowStale", {
      set: function(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      },
      get: function() {
        return this[ALLOW_STALE];
      },
      enumerable: true
    });
    Object.defineProperty(LRUCache.prototype, "maxAge", {
      set: function(mA) {
        if (!mA || !(typeof mA === "number") || mA < 0) {
          mA = 0;
        }
        this[MAX_AGE] = mA;
        trim2(this);
      },
      get: function() {
        return this[MAX_AGE];
      },
      enumerable: true
    });
    Object.defineProperty(LRUCache.prototype, "lengthCalculator", {
      set: function(lC) {
        if (typeof lC !== "function") {
          lC = naiveLength;
        }
        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach(function(hit) {
            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
            this[LENGTH] += hit.length;
          }, this);
        }
        trim2(this);
      },
      get: function() {
        return this[LENGTH_CALCULATOR];
      },
      enumerable: true
    });
    Object.defineProperty(LRUCache.prototype, "length", {
      get: function() {
        return this[LENGTH];
      },
      enumerable: true
    });
    Object.defineProperty(LRUCache.prototype, "itemCount", {
      get: function() {
        return this[LRU_LIST].length;
      },
      enumerable: true
    });
    LRUCache.prototype.rforEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this[LRU_LIST].tail; walker !== null; ) {
        var prev = walker.prev;
        forEachStep(this, fn, walker, thisp);
        walker = prev;
      }
    };
    function forEachStep(self2, fn, node, thisp) {
      var hit = node.value;
      if (isStale(self2, hit)) {
        del(self2, node);
        if (!self2[ALLOW_STALE]) {
          hit = void 0;
        }
      }
      if (hit) {
        fn.call(thisp, hit.value, hit.key, self2);
      }
    }
    LRUCache.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this[LRU_LIST].head; walker !== null; ) {
        var next = walker.next;
        forEachStep(this, fn, walker, thisp);
        walker = next;
      }
    };
    LRUCache.prototype.keys = function() {
      return this[LRU_LIST].toArray().map(function(k) {
        return k.key;
      }, this);
    };
    LRUCache.prototype.values = function() {
      return this[LRU_LIST].toArray().map(function(k) {
        return k.value;
      }, this);
    };
    LRUCache.prototype.reset = function() {
      if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
        this[LRU_LIST].forEach(function(hit) {
          this[DISPOSE](hit.key, hit.value);
        }, this);
      }
      this[CACHE] = new Map2();
      this[LRU_LIST] = new Yallist();
      this[LENGTH] = 0;
    };
    LRUCache.prototype.dump = function() {
      return this[LRU_LIST].map(function(hit) {
        if (!isStale(this, hit)) {
          return {
            k: hit.key,
            v: hit.value,
            e: hit.now + (hit.maxAge || 0)
          };
        }
      }, this).toArray().filter(function(h) {
        return h;
      });
    };
    LRUCache.prototype.dumpLru = function() {
      return this[LRU_LIST];
    };
    LRUCache.prototype.inspect = function(n, opts) {
      var str = "LRUCache {";
      var extras = false;
      var as = this[ALLOW_STALE];
      if (as) {
        str += "\n  allowStale: true";
        extras = true;
      }
      var max = this[MAX];
      if (max && max !== Infinity) {
        if (extras) {
          str += ",";
        }
        str += "\n  max: " + util.inspect(max, opts);
        extras = true;
      }
      var maxAge = this[MAX_AGE];
      if (maxAge) {
        if (extras) {
          str += ",";
        }
        str += "\n  maxAge: " + util.inspect(maxAge, opts);
        extras = true;
      }
      var lc = this[LENGTH_CALCULATOR];
      if (lc && lc !== naiveLength) {
        if (extras) {
          str += ",";
        }
        str += "\n  length: " + util.inspect(this[LENGTH], opts);
        extras = true;
      }
      var didFirst = false;
      this[LRU_LIST].forEach(function(item) {
        if (didFirst) {
          str += ",\n  ";
        } else {
          if (extras) {
            str += ",\n";
          }
          didFirst = true;
          str += "\n  ";
        }
        var key = util.inspect(item.key).split("\n").join("\n  ");
        var val = { value: item.value };
        if (item.maxAge !== maxAge) {
          val.maxAge = item.maxAge;
        }
        if (lc !== naiveLength) {
          val.length = item.length;
        }
        if (isStale(this, item)) {
          val.stale = true;
        }
        val = util.inspect(val, opts).split("\n").join("\n  ");
        str += key + " => " + val;
      });
      if (didFirst || extras) {
        str += "\n";
      }
      str += "}";
      return str;
    };
    LRUCache.prototype.set = function(key, value, maxAge) {
      maxAge = maxAge || this[MAX_AGE];
      var now = maxAge ? Date.now() : 0;
      var len = this[LENGTH_CALCULATOR](value, key);
      if (this[CACHE].has(key)) {
        if (len > this[MAX]) {
          del(this, this[CACHE].get(key));
          return false;
        }
        var node = this[CACHE].get(key);
        var item = node.value;
        if (this[DISPOSE]) {
          if (!this[NO_DISPOSE_ON_SET]) {
            this[DISPOSE](key, item.value);
          }
        }
        item.now = now;
        item.maxAge = maxAge;
        item.value = value;
        this[LENGTH] += len - item.length;
        item.length = len;
        this.get(key);
        trim2(this);
        return true;
      }
      var hit = new Entry(key, value, len, now, maxAge);
      if (hit.length > this[MAX]) {
        if (this[DISPOSE]) {
          this[DISPOSE](key, value);
        }
        return false;
      }
      this[LENGTH] += hit.length;
      this[LRU_LIST].unshift(hit);
      this[CACHE].set(key, this[LRU_LIST].head);
      trim2(this);
      return true;
    };
    LRUCache.prototype.has = function(key) {
      if (!this[CACHE].has(key))
        return false;
      var hit = this[CACHE].get(key).value;
      if (isStale(this, hit)) {
        return false;
      }
      return true;
    };
    LRUCache.prototype.get = function(key) {
      return get(this, key, true);
    };
    LRUCache.prototype.peek = function(key) {
      return get(this, key, false);
    };
    LRUCache.prototype.pop = function() {
      var node = this[LRU_LIST].tail;
      if (!node)
        return null;
      del(this, node);
      return node.value;
    };
    LRUCache.prototype.del = function(key) {
      del(this, this[CACHE].get(key));
    };
    LRUCache.prototype.load = function(arr) {
      this.reset();
      var now = Date.now();
      for (var l = arr.length - 1; l >= 0; l--) {
        var hit = arr[l];
        var expiresAt = hit.e || 0;
        if (expiresAt === 0) {
          this.set(hit.k, hit.v);
        } else {
          var maxAge = expiresAt - now;
          if (maxAge > 0) {
            this.set(hit.k, hit.v, maxAge);
          }
        }
      }
    };
    LRUCache.prototype.prune = function() {
      var self2 = this;
      this[CACHE].forEach(function(value, key) {
        get(self2, key, false);
      });
    };
    function get(self2, key, doUse) {
      var node = self2[CACHE].get(key);
      if (node) {
        var hit = node.value;
        if (isStale(self2, hit)) {
          del(self2, node);
          if (!self2[ALLOW_STALE])
            hit = void 0;
        } else {
          if (doUse) {
            self2[LRU_LIST].unshiftNode(node);
          }
        }
        if (hit)
          hit = hit.value;
      }
      return hit;
    }
    function isStale(self2, hit) {
      if (!hit || !hit.maxAge && !self2[MAX_AGE]) {
        return false;
      }
      var stale = false;
      var diff = Date.now() - hit.now;
      if (hit.maxAge) {
        stale = diff > hit.maxAge;
      } else {
        stale = self2[MAX_AGE] && diff > self2[MAX_AGE];
      }
      return stale;
    }
    function trim2(self2) {
      if (self2[LENGTH] > self2[MAX]) {
        for (var walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
          var prev = walker.prev;
          del(self2, walker);
          walker = prev;
        }
      }
    }
    function del(self2, node) {
      if (node) {
        var hit = node.value;
        if (self2[DISPOSE]) {
          self2[DISPOSE](hit.key, hit.value);
        }
        self2[LENGTH] -= hit.length;
        self2[CACHE].delete(hit.key);
        self2[LRU_LIST].removeNode(node);
      }
    }
    function Entry(key, value, length, now, maxAge) {
      this.key = key;
      this.value = value;
      this.length = length;
      this.now = now;
      this.maxAge = maxAge || 0;
    }
  }
});

// node_modules/sigmund/sigmund.js
var require_sigmund = __commonJS({
  "node_modules/sigmund/sigmund.js"(exports, module) {
    module.exports = sigmund;
    function sigmund(subject, maxSessions) {
      maxSessions = maxSessions || 10;
      var notes = [];
      var analysis = "";
      var RE = RegExp;
      function psychoAnalyze(subject2, session) {
        if (session > maxSessions)
          return;
        if (typeof subject2 === "function" || typeof subject2 === "undefined") {
          return;
        }
        if (typeof subject2 !== "object" || !subject2 || subject2 instanceof RE) {
          analysis += subject2;
          return;
        }
        if (notes.indexOf(subject2) !== -1 || session === maxSessions)
          return;
        notes.push(subject2);
        analysis += "{";
        Object.keys(subject2).forEach(function(issue, _, __) {
          if (issue.charAt(0) === "_")
            return;
          var to = typeof subject2[issue];
          if (to === "function" || to === "undefined")
            return;
          analysis += issue;
          psychoAnalyze(subject2[issue], session + 1);
        });
      }
      psychoAnalyze(subject, 0);
      return analysis;
    }
  }
});

// node_modules/editorconfig/src/lib/fnmatch.js
var require_fnmatch = __commonJS({
  "node_modules/editorconfig/src/lib/fnmatch.js"(exports, module) {
    var platform = typeof process === "object" ? process.platform : "win32";
    if (module)
      module.exports = minimatch;
    else
      exports.minimatch = minimatch;
    minimatch.Minimatch = Minimatch;
    var LRU = require_lru_cache();
    var cache = minimatch.cache = new LRU({ max: 100 });
    var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
    var sigmund = require_sigmund();
    var path11 = __require("path");
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var reSpecials = charSet("().*{}+?[]^$\\!");
    function charSet(s) {
      return s.split("").reduce(function(set, c) {
        set[c] = true;
        return set;
      }, {});
    }
    var slashSplit = /\/+/;
    minimatch.monkeyPatch = monkeyPatch;
    function monkeyPatch() {
      var desc = Object.getOwnPropertyDescriptor(String.prototype, "match");
      var orig = desc.value;
      desc.value = function(p) {
        if (p instanceof Minimatch)
          return p.match(this);
        return orig.call(this, p);
      };
      Object.defineProperty(String.prototype, desc);
    }
    minimatch.filter = filter;
    function filter(pattern, options9) {
      options9 = options9 || {};
      return function(p, i, list) {
        return minimatch(p, pattern, options9);
      };
    }
    function ext(a, b) {
      a = a || {};
      b = b || {};
      var t = {};
      Object.keys(b).forEach(function(k) {
        t[k] = b[k];
      });
      Object.keys(a).forEach(function(k) {
        t[k] = a[k];
      });
      return t;
    }
    minimatch.defaults = function(def) {
      if (!def || !Object.keys(def).length)
        return minimatch;
      var orig = minimatch;
      var m = function minimatch2(p, pattern, options9) {
        return orig.minimatch(p, pattern, ext(def, options9));
      };
      m.Minimatch = function Minimatch2(pattern, options9) {
        return new orig.Minimatch(pattern, ext(def, options9));
      };
      return m;
    };
    Minimatch.defaults = function(def) {
      if (!def || !Object.keys(def).length)
        return Minimatch;
      return minimatch.defaults(def).Minimatch;
    };
    function minimatch(p, pattern, options9) {
      if (typeof pattern !== "string") {
        throw new TypeError("glob pattern string required");
      }
      if (!options9)
        options9 = {};
      if (!options9.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      if (pattern.trim() === "")
        return p === "";
      return new Minimatch(pattern, options9).match(p);
    }
    function Minimatch(pattern, options9) {
      if (!(this instanceof Minimatch)) {
        return new Minimatch(pattern, options9, cache);
      }
      if (typeof pattern !== "string") {
        throw new TypeError("glob pattern string required");
      }
      if (!options9)
        options9 = {};
      if (platform === "win32") {
        pattern = pattern.split("\\").join("/");
      }
      var cacheKey = pattern + "\n" + sigmund(options9);
      var cached = minimatch.cache.get(cacheKey);
      if (cached)
        return cached;
      minimatch.cache.set(cacheKey, this);
      this.options = options9;
      this.set = [];
      this.pattern = pattern;
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.make();
    }
    Minimatch.prototype.make = make;
    function make() {
      if (this._made)
        return;
      var pattern = this.pattern;
      var options9 = this.options;
      if (!options9.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      var set = this.globSet = this.braceExpand();
      if (options9.debug)
        console.error(this.pattern, set);
      set = this.globParts = set.map(function(s) {
        return s.split(slashSplit);
      });
      if (options9.debug)
        console.error(this.pattern, set);
      set = set.map(function(s, si, set2) {
        return s.map(this.parse, this);
      }, this);
      if (options9.debug)
        console.error(this.pattern, set);
      set = set.filter(function(s) {
        return -1 === s.indexOf(false);
      });
      if (options9.debug)
        console.error(this.pattern, set);
      this.set = set;
    }
    Minimatch.prototype.parseNegate = parseNegate;
    function parseNegate() {
      var pattern = this.pattern, negate = false, options9 = this.options, negateOffset = 0;
      if (options9.nonegate)
        return;
      for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern.substr(negateOffset);
      this.negate = negate;
    }
    minimatch.braceExpand = function(pattern, options9) {
      return new Minimatch(pattern, options9).braceExpand();
    };
    Minimatch.prototype.braceExpand = braceExpand;
    function braceExpand(pattern, options9) {
      options9 = options9 || this.options;
      pattern = typeof pattern === "undefined" ? this.pattern : pattern;
      if (typeof pattern === "undefined") {
        throw new Error("undefined pattern");
      }
      if (options9.nobrace || !pattern.match(/\{.*\}/)) {
        return [pattern];
      }
      var escaping = false;
      if (pattern.charAt(0) !== "{") {
        var prefix = null;
        for (var i = 0, l = pattern.length; i < l; i++) {
          var c = pattern.charAt(i);
          if (c === "\\") {
            escaping = !escaping;
          } else if (c === "{" && !escaping) {
            prefix = pattern.substr(0, i);
            break;
          }
        }
        if (prefix === null) {
          return [pattern];
        }
        var tail = braceExpand(pattern.substr(i), options9);
        return tail.map(function(t) {
          return prefix + t;
        });
      }
      var numset = pattern.match(/^\{(-?[0-9]+)\.\.(-?[0-9]+)\}/);
      if (numset) {
        var suf = braceExpand(pattern.substr(numset[0].length), options9), start = +numset[1], end = +numset[2], inc = start > end ? -1 : 1, set = [];
        for (var i = start; i != end + inc; i += inc) {
          for (var ii = 0, ll = suf.length; ii < ll; ii++) {
            set.push(i + suf[ii]);
          }
        }
        return set;
      }
      var i = 1, depth = 1, set = [], member = "", sawEnd = false, escaping = false;
      function addMember() {
        set.push(member);
        member = "";
      }
      FOR:
        for (i = 1, l = pattern.length; i < l; i++) {
          var c = pattern.charAt(i);
          if (escaping) {
            escaping = false;
            member += "\\" + c;
          } else {
            switch (c) {
              case "\\":
                escaping = true;
                continue;
              case "{":
                depth++;
                member += "{";
                continue;
              case "}":
                depth--;
                if (depth === 0) {
                  addMember();
                  i++;
                  break FOR;
                } else {
                  member += c;
                  continue;
                }
              case ",":
                if (depth === 1) {
                  addMember();
                } else {
                  member += c;
                }
                continue;
              default:
                member += c;
                continue;
            }
          }
        }
      if (depth !== 0) {
        return braceExpand("\\" + pattern, options9);
      }
      var suf = braceExpand(pattern.substr(i), options9);
      var addBraces = set.length === 1;
      set = set.map(function(p) {
        return braceExpand(p, options9);
      });
      set = set.reduce(function(l2, r) {
        return l2.concat(r);
      });
      if (addBraces) {
        set = set.map(function(s) {
          return "{" + s + "}";
        });
      }
      var ret = [];
      for (var i = 0, l = set.length; i < l; i++) {
        for (var ii = 0, ll = suf.length; ii < ll; ii++) {
          ret.push(set[i] + suf[ii]);
        }
      }
      return ret;
    }
    Minimatch.prototype.parse = parse4;
    var SUBPARSE = {};
    function parse4(pattern, isSub) {
      var options9 = this.options;
      if (!options9.noglobstar && pattern === "**")
        return GLOBSTAR;
      if (pattern === "")
        return "";
      var re = "", hasMagic = !!options9.nocase, escaping = false, patternListStack = [], plType, stateChar, inClass = false, reClassStart = -1, classStart = -1, patternStart = pattern.charAt(0) === "." ? "" : options9.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      function clearStateChar() {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re += star;
              hasMagic = true;
              break;
            case "?":
              re += qmark;
              hasMagic = true;
              break;
            default:
              re += "\\" + stateChar;
              break;
          }
          stateChar = false;
        }
      }
      for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
        if (options9.debug) {
          console.error("%s	%s %s %j", pattern, i, re, c);
        }
        if (escaping && reSpecials[c]) {
          re += "\\" + c;
          escaping = false;
          continue;
        }
        SWITCH:
          switch (c) {
            case "/":
              return false;
            case "\\":
              clearStateChar();
              escaping = true;
              continue;
            case "?":
            case "*":
            case "+":
            case "@":
            case "!":
              if (options9.debug) {
                console.error("%s	%s %s %j <-- stateChar", pattern, i, re, c);
              }
              if (inClass) {
                if (c === "!" && i === classStart + 1)
                  c = "^";
                re += c;
                continue;
              }
              clearStateChar();
              stateChar = c;
              if (options9.noext)
                clearStateChar();
              continue;
            case "(":
              if (inClass) {
                re += "(";
                continue;
              }
              if (!stateChar) {
                re += "\\(";
                continue;
              }
              plType = stateChar;
              patternListStack.push({
                type: plType,
                start: i - 1,
                reStart: re.length
              });
              re += stateChar === "!" ? "(?:(?!" : "(?:";
              stateChar = false;
              continue;
            case ")":
              if (inClass || !patternListStack.length) {
                re += "\\)";
                continue;
              }
              hasMagic = true;
              re += ")";
              plType = patternListStack.pop().type;
              switch (plType) {
                case "!":
                  re += "[^/]*?)";
                  break;
                case "?":
                case "+":
                case "*":
                  re += plType;
                case "@":
                  break;
              }
              continue;
            case "|":
              if (inClass || !patternListStack.length || escaping) {
                re += "\\|";
                escaping = false;
                continue;
              }
              re += "|";
              continue;
            case "[":
              clearStateChar();
              if (inClass) {
                re += "\\" + c;
                continue;
              }
              inClass = true;
              classStart = i;
              reClassStart = re.length;
              re += c;
              continue;
            case "]":
              if (i === classStart + 1 || !inClass) {
                re += "\\" + c;
                escaping = false;
                continue;
              }
              hasMagic = true;
              inClass = false;
              re += c;
              continue;
            default:
              clearStateChar();
              if (escaping) {
                escaping = false;
              } else if (reSpecials[c] && !(c === "^" && inClass)) {
                re += "\\";
              }
              re += c;
          }
      }
      if (inClass) {
        var cs = pattern.substr(classStart + 1), sp = this.parse(cs, SUBPARSE);
        re = re.substr(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
      }
      var pl;
      while (pl = patternListStack.pop()) {
        var tail = re.slice(pl.reStart + 3);
        tail = tail.replace(/((?:\\{2})*)(\\?)\|/g, function(_, $1, $2) {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = true;
        re = re.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      clearStateChar();
      if (escaping) {
        re += "\\\\";
      }
      var addPatternStart = false;
      switch (re.charAt(0)) {
        case ".":
        case "[":
        case "(":
          addPatternStart = true;
      }
      if (re !== "" && hasMagic)
        re = "(?=.)" + re;
      if (addPatternStart)
        re = patternStart + re;
      if (isSub === SUBPARSE) {
        return [re, hasMagic];
      }
      if (!hasMagic) {
        return globUnescape(pattern);
      }
      var flags = options9.nocase ? "i" : "", regExp = new RegExp("^" + re + "$", flags);
      regExp._glob = pattern;
      regExp._src = re;
      return regExp;
    }
    minimatch.makeRe = function(pattern, options9) {
      return new Minimatch(pattern, options9 || {}).makeRe();
    };
    Minimatch.prototype.makeRe = makeRe;
    function makeRe() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      var set = this.set;
      if (!set.length)
        return this.regexp = false;
      var options9 = this.options;
      var twoStar = options9.noglobstar ? star : options9.dot ? twoStarDot : twoStarNoDot, flags = options9.nocase ? "i" : "";
      var re = set.map(function(pattern) {
        return pattern.map(function(p) {
          return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
        }).join("\\/");
      }).join("|");
      re = "^(?:" + re + ")$";
      if (this.negate)
        re = "^(?!" + re + ").*$";
      try {
        return this.regexp = new RegExp(re, flags);
      } catch (ex) {
        return this.regexp = false;
      }
    }
    minimatch.match = function(list, pattern, options9) {
      var mm = new Minimatch(pattern, options9);
      list = list.filter(function(f) {
        return mm.match(f);
      });
      if (options9.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    Minimatch.prototype.match = match;
    function match(f, partial) {
      if (this.comment)
        return false;
      if (this.empty)
        return f === "";
      if (f === "/" && partial)
        return true;
      var options9 = this.options;
      if (platform === "win32") {
        f = f.split("\\").join("/");
      }
      f = f.split(slashSplit);
      if (options9.debug) {
        console.error(this.pattern, "split", f);
      }
      var set = this.set;
      for (var i = 0, l = set.length; i < l; i++) {
        var pattern = set[i];
        var hit = this.matchOne(f, pattern, partial);
        if (hit) {
          if (options9.flipNegate)
            return true;
          return !this.negate;
        }
      }
      if (options9.flipNegate)
        return false;
      return this.negate;
    }
    Minimatch.prototype.matchOne = function(file, pattern, partial) {
      var options9 = this.options;
      if (options9.debug) {
        console.error(
          "matchOne",
          {
            "this": this,
            file,
            pattern
          }
        );
      }
      if (options9.matchBase && pattern.length === 1) {
        file = path11.basename(file.join("/")).split("/");
      }
      if (options9.debug) {
        console.error("matchOne", file.length, pattern.length);
      }
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        if (options9.debug) {
          console.error("matchOne loop");
        }
        var p = pattern[pi], f = file[fi];
        if (options9.debug) {
          console.error(pattern, p, f);
        }
        if (p === false)
          return false;
        if (p === GLOBSTAR) {
          if (options9.debug)
            console.error("GLOBSTAR", [pattern, p, f]);
          var fr = fi, pr = pi + 1;
          if (pr === pl) {
            if (options9.debug)
              console.error("** at the end");
            for (; fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options9.dot && file[fi].charAt(0) === ".")
                return false;
            }
            return true;
          }
          WHILE:
            while (fr < fl) {
              var swallowee = file[fr];
              if (options9.debug) {
                console.error(
                  "\nglobstar while",
                  file,
                  fr,
                  pattern,
                  pr,
                  swallowee
                );
              }
              if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                if (options9.debug)
                  console.error("globstar found match!", fr, fl, swallowee);
                return true;
              } else {
                if (swallowee === "." || swallowee === ".." || !options9.dot && swallowee.charAt(0) === ".") {
                  if (options9.debug)
                    console.error("dot detected!", file, fr, pattern, pr);
                  break WHILE;
                }
                if (options9.debug)
                  console.error("globstar swallow a segment, and continue");
                fr++;
              }
            }
          if (partial) {
            if (fr === fl)
              return true;
          }
          return false;
        }
        var hit;
        if (typeof p === "string") {
          if (options9.nocase) {
            hit = f.toLowerCase() === p.toLowerCase();
          } else {
            hit = f === p;
          }
          if (options9.debug) {
            console.error("string match", p, f, hit);
          }
        } else {
          hit = f.match(p);
          if (options9.debug) {
            console.error("pattern match", p, f, hit);
          }
        }
        if (!hit)
          return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial;
      } else if (pi === pl) {
        var emptyFileEnd = fi === fl - 1 && file[fi] === "";
        return emptyFileEnd;
      }
      throw new Error("wtf?");
    };
    function globUnescape(s) {
      return s.replace(/\\(.)/g, "$1");
    }
    function regExpEscape(s) {
      return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
  }
});

// node_modules/editorconfig/src/lib/ini.js
var require_ini = __commonJS({
  "node_modules/editorconfig/src/lib/ini.js"(exports) {
    "use strict";
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : new P(function(resolve3) {
            resolve3(result.value);
          }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator2 = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (Object.hasOwnProperty.call(mod, k))
            result[k] = mod[k];
      }
      result["default"] = mod;
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var fs6 = __importStar2(__require("fs"));
    var regex = {
      section: /^\s*\[(([^#;]|\\#|\\;)+)\]\s*([#;].*)?$/,
      param: /^\s*([\w\.\-\_]+)\s*[=:]\s*(.*?)\s*([#;].*)?$/,
      comment: /^\s*[#;].*$/
    };
    function parse4(file) {
      return __awaiter2(this, void 0, void 0, function() {
        return __generator2(this, function(_a) {
          return [2, new Promise(function(resolve2, reject) {
            fs6.readFile(file, "utf8", function(err, data) {
              if (err) {
                reject(err);
                return;
              }
              resolve2(parseString(data));
            });
          })];
        });
      });
    }
    exports.parse = parse4;
    function parseSync(file) {
      return parseString(fs6.readFileSync(file, "utf8"));
    }
    exports.parseSync = parseSync;
    function parseString(data) {
      var sectionBody = {};
      var sectionName = null;
      var value = [[sectionName, sectionBody]];
      var lines = data.split(/\r\n|\r|\n/);
      lines.forEach(function(line2) {
        var match;
        if (regex.comment.test(line2)) {
          return;
        }
        if (regex.param.test(line2)) {
          match = line2.match(regex.param);
          sectionBody[match[1]] = match[2];
        } else if (regex.section.test(line2)) {
          match = line2.match(regex.section);
          sectionName = match[1];
          sectionBody = {};
          value.push([sectionName, sectionBody]);
        }
      });
      return value;
    }
    exports.parseString = parseString;
  }
});

// node_modules/editorconfig/package.json
var require_package = __commonJS({
  "node_modules/editorconfig/package.json"(exports, module) {
    module.exports = {
      name: "editorconfig",
      version: "0.15.3",
      description: "EditorConfig File Locator and Interpreter for Node.js",
      keywords: [
        "editorconfig",
        "core"
      ],
      main: "src/index.js",
      contributors: [
        "Hong Xu (topbug.net)",
        "Jed Mao (https://github.com/jedmao/)",
        "Trey Hunner (http://treyhunner.com)"
      ],
      directories: {
        bin: "./bin",
        lib: "./lib"
      },
      scripts: {
        clean: "rimraf dist",
        prebuild: "npm run clean",
        build: "tsc",
        pretest: "npm run lint && npm run build && npm run copy && cmake .",
        test: "ctest .",
        "pretest:ci": "npm run pretest",
        "test:ci": "ctest -VV --output-on-failure .",
        lint: "npm run eclint && npm run tslint",
        eclint: 'eclint check --indent_size ignore "src/**"',
        tslint: "tslint --project tsconfig.json --exclude package.json",
        copy: "cpy .npmignore LICENSE README.md CHANGELOG.md dist && cpy bin/* dist/bin && cpy src/lib/fnmatch*.* dist/src/lib",
        prepub: "npm run lint && npm run build && npm run copy",
        pub: "npm publish ./dist"
      },
      repository: {
        type: "git",
        url: "git://github.com/editorconfig/editorconfig-core-js.git"
      },
      bugs: "https://github.com/editorconfig/editorconfig-core-js/issues",
      author: "EditorConfig Team",
      license: "MIT",
      dependencies: {
        commander: "^2.19.0",
        "lru-cache": "^4.1.5",
        semver: "^5.6.0",
        sigmund: "^1.0.1"
      },
      devDependencies: {
        "@types/mocha": "^5.2.6",
        "@types/node": "^10.12.29",
        "@types/semver": "^5.5.0",
        "cpy-cli": "^2.0.0",
        eclint: "^2.8.1",
        mocha: "^5.2.0",
        rimraf: "^2.6.3",
        should: "^13.2.3",
        tslint: "^5.13.1",
        typescript: "^3.3.3333"
      }
    };
  }
});

// node_modules/editorconfig/src/index.js
var require_src = __commonJS({
  "node_modules/editorconfig/src/index.js"(exports) {
    "use strict";
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : new P(function(resolve3) {
            resolve3(result.value);
          }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator2 = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (Object.hasOwnProperty.call(mod, k))
            result[k] = mod[k];
      }
      result["default"] = mod;
      return result;
    };
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var fs6 = __importStar2(__require("fs"));
    var path11 = __importStar2(__require("path"));
    var semver = {
      gte: require_gte()
    };
    var fnmatch_1 = __importDefault2(require_fnmatch());
    var ini_1 = require_ini();
    exports.parseString = ini_1.parseString;
    var package_json_1 = __importDefault2(require_package());
    var knownProps = {
      end_of_line: true,
      indent_style: true,
      indent_size: true,
      insert_final_newline: true,
      trim_trailing_whitespace: true,
      charset: true
    };
    function fnmatch(filepath, glob) {
      var matchOptions = { matchBase: true, dot: true, noext: true };
      glob = glob.replace(/\*\*/g, "{*,**/**/**}");
      return fnmatch_1.default(filepath, glob, matchOptions);
    }
    function getConfigFileNames(filepath, options9) {
      var paths = [];
      do {
        filepath = path11.dirname(filepath);
        paths.push(path11.join(filepath, options9.config));
      } while (filepath !== options9.root);
      return paths;
    }
    function processMatches(matches, version) {
      if ("indent_style" in matches && matches.indent_style === "tab" && !("indent_size" in matches) && semver.gte(version, "0.10.0")) {
        matches.indent_size = "tab";
      }
      if ("indent_size" in matches && !("tab_width" in matches) && matches.indent_size !== "tab") {
        matches.tab_width = matches.indent_size;
      }
      if ("indent_size" in matches && "tab_width" in matches && matches.indent_size === "tab") {
        matches.indent_size = matches.tab_width;
      }
      return matches;
    }
    function processOptions(options9, filepath) {
      if (options9 === void 0) {
        options9 = {};
      }
      return {
        config: options9.config || ".editorconfig",
        version: options9.version || package_json_1.default.version,
        root: path11.resolve(options9.root || path11.parse(filepath).root)
      };
    }
    function buildFullGlob(pathPrefix, glob) {
      switch (glob.indexOf("/")) {
        case -1:
          glob = "**/" + glob;
          break;
        case 0:
          glob = glob.substring(1);
          break;
        default:
          break;
      }
      return path11.join(pathPrefix, glob);
    }
    function extendProps(props, options9) {
      if (props === void 0) {
        props = {};
      }
      if (options9 === void 0) {
        options9 = {};
      }
      for (var key in options9) {
        if (options9.hasOwnProperty(key)) {
          var value = options9[key];
          var key2 = key.toLowerCase();
          var value2 = value;
          if (knownProps[key2]) {
            value2 = value.toLowerCase();
          }
          try {
            value2 = JSON.parse(value);
          } catch (e) {
          }
          if (typeof value === "undefined" || value === null) {
            value2 = String(value);
          }
          props[key2] = value2;
        }
      }
      return props;
    }
    function parseFromConfigs(configs, filepath, options9) {
      return processMatches(configs.reverse().reduce(function(matches, file) {
        var pathPrefix = path11.dirname(file.name);
        file.contents.forEach(function(section) {
          var glob = section[0];
          var options22 = section[1];
          if (!glob) {
            return;
          }
          var fullGlob = buildFullGlob(pathPrefix, glob);
          if (!fnmatch(filepath, fullGlob)) {
            return;
          }
          matches = extendProps(matches, options22);
        });
        return matches;
      }, {}), options9.version);
    }
    function getConfigsForFiles(files) {
      var configs = [];
      for (var i in files) {
        if (files.hasOwnProperty(i)) {
          var file = files[i];
          var contents = ini_1.parseString(file.contents);
          configs.push({
            name: file.name,
            contents
          });
          if ((contents[0][1].root || "").toLowerCase() === "true") {
            break;
          }
        }
      }
      return configs;
    }
    function readConfigFiles(filepaths) {
      return __awaiter2(this, void 0, void 0, function() {
        return __generator2(this, function(_a) {
          return [2, Promise.all(filepaths.map(function(name) {
            return new Promise(function(resolve2) {
              fs6.readFile(name, "utf8", function(err, data) {
                resolve2({
                  name,
                  contents: err ? "" : data
                });
              });
            });
          }))];
        });
      });
    }
    function readConfigFilesSync(filepaths) {
      var files = [];
      var file;
      filepaths.forEach(function(filepath) {
        try {
          file = fs6.readFileSync(filepath, "utf8");
        } catch (e) {
          file = "";
        }
        files.push({
          name: filepath,
          contents: file
        });
      });
      return files;
    }
    function opts(filepath, options9) {
      if (options9 === void 0) {
        options9 = {};
      }
      var resolvedFilePath = path11.resolve(filepath);
      return [
        resolvedFilePath,
        processOptions(options9, resolvedFilePath)
      ];
    }
    function parseFromFiles(filepath, files, options9) {
      if (options9 === void 0) {
        options9 = {};
      }
      return __awaiter2(this, void 0, void 0, function() {
        var _a, resolvedFilePath, processedOptions;
        return __generator2(this, function(_b) {
          _a = opts(filepath, options9), resolvedFilePath = _a[0], processedOptions = _a[1];
          return [2, files.then(getConfigsForFiles).then(function(configs) {
            return parseFromConfigs(configs, resolvedFilePath, processedOptions);
          })];
        });
      });
    }
    exports.parseFromFiles = parseFromFiles;
    function parseFromFilesSync(filepath, files, options9) {
      if (options9 === void 0) {
        options9 = {};
      }
      var _a = opts(filepath, options9), resolvedFilePath = _a[0], processedOptions = _a[1];
      return parseFromConfigs(getConfigsForFiles(files), resolvedFilePath, processedOptions);
    }
    exports.parseFromFilesSync = parseFromFilesSync;
    function parse4(_filepath, _options) {
      if (_options === void 0) {
        _options = {};
      }
      return __awaiter2(this, void 0, void 0, function() {
        var _a, resolvedFilePath, processedOptions, filepaths;
        return __generator2(this, function(_b) {
          _a = opts(_filepath, _options), resolvedFilePath = _a[0], processedOptions = _a[1];
          filepaths = getConfigFileNames(resolvedFilePath, processedOptions);
          return [2, readConfigFiles(filepaths).then(getConfigsForFiles).then(function(configs) {
            return parseFromConfigs(configs, resolvedFilePath, processedOptions);
          })];
        });
      });
    }
    exports.parse = parse4;
    function parseSync(_filepath, _options) {
      if (_options === void 0) {
        _options = {};
      }
      var _a = opts(_filepath, _options), resolvedFilePath = _a[0], processedOptions = _a[1];
      var filepaths = getConfigFileNames(resolvedFilePath, processedOptions);
      var files = readConfigFilesSync(filepaths);
      return parseFromConfigs(getConfigsForFiles(files), resolvedFilePath, processedOptions);
    }
    exports.parseSync = parseSync;
  }
});

// node_modules/editorconfig-to-prettier/index.js
var require_editorconfig_to_prettier = __commonJS({
  "node_modules/editorconfig-to-prettier/index.js"(exports, module) {
    module.exports = editorConfigToPrettier2;
    function removeUnset(editorConfig) {
      const result = {};
      const keys = Object.keys(editorConfig);
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        if (editorConfig[key] === "unset") {
          continue;
        }
        result[key] = editorConfig[key];
      }
      return result;
    }
    function editorConfigToPrettier2(editorConfig) {
      if (!editorConfig) {
        return null;
      }
      editorConfig = removeUnset(editorConfig);
      if (Object.keys(editorConfig).length === 0) {
        return null;
      }
      const result = {};
      if (editorConfig.indent_style) {
        result.useTabs = editorConfig.indent_style === "tab";
      }
      if (editorConfig.indent_size === "tab") {
        result.useTabs = true;
      }
      if (result.useTabs && editorConfig.tab_width) {
        result.tabWidth = editorConfig.tab_width;
      } else if (editorConfig.indent_style === "space" && editorConfig.indent_size && editorConfig.indent_size !== "tab") {
        result.tabWidth = editorConfig.indent_size;
      } else if (editorConfig.tab_width !== void 0) {
        result.tabWidth = editorConfig.tab_width;
      }
      if (editorConfig.max_line_length && editorConfig.max_line_length !== "off") {
        result.printWidth = editorConfig.max_line_length;
      }
      if (editorConfig.quote_type === "single") {
        result.singleQuote = true;
      } else if (editorConfig.quote_type === "double") {
        result.singleQuote = false;
      }
      if (["cr", "crlf", "lf"].indexOf(editorConfig.end_of_line) !== -1) {
        result.endOfLine = editorConfig.end_of_line;
      }
      if (editorConfig.insert_final_newline === false || editorConfig.insert_final_newline === true) {
        result.insertFinalNewline = editorConfig.insert_final_newline;
      }
      return result;
    }
  }
});

// node_modules/@iarna/toml/lib/parser.js
var require_parser = __commonJS({
  "node_modules/@iarna/toml/lib/parser.js"(exports, module) {
    "use strict";
    var ParserEND = 1114112;
    var ParserError = class extends Error {
      /* istanbul ignore next */
      constructor(msg, filename, linenumber) {
        super("[ParserError] " + msg, filename, linenumber);
        this.name = "ParserError";
        this.code = "ParserError";
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, ParserError);
      }
    };
    var State = class {
      constructor(parser) {
        this.parser = parser;
        this.buf = "";
        this.returned = null;
        this.result = null;
        this.resultTable = null;
        this.resultArr = null;
      }
    };
    var Parser = class {
      constructor() {
        this.pos = 0;
        this.col = 0;
        this.line = 0;
        this.obj = {};
        this.ctx = this.obj;
        this.stack = [];
        this._buf = "";
        this.char = null;
        this.ii = 0;
        this.state = new State(this.parseStart);
      }
      parse(str) {
        if (str.length === 0 || str.length == null)
          return;
        this._buf = String(str);
        this.ii = -1;
        this.char = -1;
        let getNext;
        while (getNext === false || this.nextChar()) {
          getNext = this.runOne();
        }
        this._buf = null;
      }
      nextChar() {
        if (this.char === 10) {
          ++this.line;
          this.col = -1;
        }
        ++this.ii;
        this.char = this._buf.codePointAt(this.ii);
        ++this.pos;
        ++this.col;
        return this.haveBuffer();
      }
      haveBuffer() {
        return this.ii < this._buf.length;
      }
      runOne() {
        return this.state.parser.call(this, this.state.returned);
      }
      finish() {
        this.char = ParserEND;
        let last;
        do {
          last = this.state.parser;
          this.runOne();
        } while (this.state.parser !== last);
        this.ctx = null;
        this.state = null;
        this._buf = null;
        return this.obj;
      }
      next(fn) {
        if (typeof fn !== "function")
          throw new ParserError("Tried to set state to non-existent state: " + JSON.stringify(fn));
        this.state.parser = fn;
      }
      goto(fn) {
        this.next(fn);
        return this.runOne();
      }
      call(fn, returnWith) {
        if (returnWith)
          this.next(returnWith);
        this.stack.push(this.state);
        this.state = new State(fn);
      }
      callNow(fn, returnWith) {
        this.call(fn, returnWith);
        return this.runOne();
      }
      return(value) {
        if (this.stack.length === 0)
          throw this.error(new ParserError("Stack underflow"));
        if (value === void 0)
          value = this.state.buf;
        this.state = this.stack.pop();
        this.state.returned = value;
      }
      returnNow(value) {
        this.return(value);
        return this.runOne();
      }
      consume() {
        if (this.char === ParserEND)
          throw this.error(new ParserError("Unexpected end-of-buffer"));
        this.state.buf += this._buf[this.ii];
      }
      error(err) {
        err.line = this.line;
        err.col = this.col;
        err.pos = this.pos;
        return err;
      }
      /* istanbul ignore next */
      parseStart() {
        throw new ParserError("Must declare a parseStart method");
      }
    };
    Parser.END = ParserEND;
    Parser.Error = ParserError;
    module.exports = Parser;
  }
});

// node_modules/@iarna/toml/lib/create-datetime.js
var require_create_datetime = __commonJS({
  "node_modules/@iarna/toml/lib/create-datetime.js"(exports, module) {
    "use strict";
    module.exports = (value) => {
      const date = new Date(value);
      if (isNaN(date)) {
        throw new TypeError("Invalid Datetime");
      } else {
        return date;
      }
    };
  }
});

// node_modules/@iarna/toml/lib/format-num.js
var require_format_num = __commonJS({
  "node_modules/@iarna/toml/lib/format-num.js"(exports, module) {
    "use strict";
    module.exports = (d, num) => {
      num = String(num);
      while (num.length < d)
        num = "0" + num;
      return num;
    };
  }
});

// node_modules/@iarna/toml/lib/create-datetime-float.js
var require_create_datetime_float = __commonJS({
  "node_modules/@iarna/toml/lib/create-datetime-float.js"(exports, module) {
    "use strict";
    var f = require_format_num();
    var FloatingDateTime = class extends Date {
      constructor(value) {
        super(value + "Z");
        this.isFloating = true;
      }
      toISOString() {
        const date = `${this.getUTCFullYear()}-${f(2, this.getUTCMonth() + 1)}-${f(2, this.getUTCDate())}`;
        const time = `${f(2, this.getUTCHours())}:${f(2, this.getUTCMinutes())}:${f(2, this.getUTCSeconds())}.${f(3, this.getUTCMilliseconds())}`;
        return `${date}T${time}`;
      }
    };
    module.exports = (value) => {
      const date = new FloatingDateTime(value);
      if (isNaN(date)) {
        throw new TypeError("Invalid Datetime");
      } else {
        return date;
      }
    };
  }
});

// node_modules/@iarna/toml/lib/create-date.js
var require_create_date = __commonJS({
  "node_modules/@iarna/toml/lib/create-date.js"(exports, module) {
    "use strict";
    var f = require_format_num();
    var DateTime = global.Date;
    var Date2 = class extends DateTime {
      constructor(value) {
        super(value);
        this.isDate = true;
      }
      toISOString() {
        return `${this.getUTCFullYear()}-${f(2, this.getUTCMonth() + 1)}-${f(2, this.getUTCDate())}`;
      }
    };
    module.exports = (value) => {
      const date = new Date2(value);
      if (isNaN(date)) {
        throw new TypeError("Invalid Datetime");
      } else {
        return date;
      }
    };
  }
});

// node_modules/@iarna/toml/lib/create-time.js
var require_create_time = __commonJS({
  "node_modules/@iarna/toml/lib/create-time.js"(exports, module) {
    "use strict";
    var f = require_format_num();
    var Time = class extends Date {
      constructor(value) {
        super(`0000-01-01T${value}Z`);
        this.isTime = true;
      }
      toISOString() {
        return `${f(2, this.getUTCHours())}:${f(2, this.getUTCMinutes())}:${f(2, this.getUTCSeconds())}.${f(3, this.getUTCMilliseconds())}`;
      }
    };
    module.exports = (value) => {
      const date = new Time(value);
      if (isNaN(date)) {
        throw new TypeError("Invalid Datetime");
      } else {
        return date;
      }
    };
  }
});

// node_modules/@iarna/toml/lib/toml-parser.js
var require_toml_parser = __commonJS({
  "node_modules/@iarna/toml/lib/toml-parser.js"(exports, module) {
    "use strict";
    module.exports = makeParserClass(require_parser());
    module.exports.makeParserClass = makeParserClass;
    var TomlError = class extends Error {
      constructor(msg) {
        super(msg);
        this.name = "TomlError";
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, TomlError);
        this.fromTOML = true;
        this.wrapped = null;
      }
    };
    TomlError.wrap = (err) => {
      const terr = new TomlError(err.message);
      terr.code = err.code;
      terr.wrapped = err;
      return terr;
    };
    module.exports.TomlError = TomlError;
    var createDateTime = require_create_datetime();
    var createDateTimeFloat = require_create_datetime_float();
    var createDate = require_create_date();
    var createTime = require_create_time();
    var CTRL_I = 9;
    var CTRL_J = 10;
    var CTRL_M = 13;
    var CTRL_CHAR_BOUNDARY = 31;
    var CHAR_SP = 32;
    var CHAR_QUOT = 34;
    var CHAR_NUM = 35;
    var CHAR_APOS = 39;
    var CHAR_PLUS = 43;
    var CHAR_COMMA = 44;
    var CHAR_HYPHEN = 45;
    var CHAR_PERIOD = 46;
    var CHAR_0 = 48;
    var CHAR_1 = 49;
    var CHAR_7 = 55;
    var CHAR_9 = 57;
    var CHAR_COLON = 58;
    var CHAR_EQUALS = 61;
    var CHAR_A = 65;
    var CHAR_E = 69;
    var CHAR_F = 70;
    var CHAR_T = 84;
    var CHAR_U = 85;
    var CHAR_Z = 90;
    var CHAR_LOWBAR = 95;
    var CHAR_a = 97;
    var CHAR_b = 98;
    var CHAR_e = 101;
    var CHAR_f = 102;
    var CHAR_i = 105;
    var CHAR_l = 108;
    var CHAR_n = 110;
    var CHAR_o = 111;
    var CHAR_r = 114;
    var CHAR_s = 115;
    var CHAR_t = 116;
    var CHAR_u = 117;
    var CHAR_x = 120;
    var CHAR_z = 122;
    var CHAR_LCUB = 123;
    var CHAR_RCUB = 125;
    var CHAR_LSQB = 91;
    var CHAR_BSOL = 92;
    var CHAR_RSQB = 93;
    var CHAR_DEL = 127;
    var SURROGATE_FIRST = 55296;
    var SURROGATE_LAST = 57343;
    var escapes = {
      [CHAR_b]: "\b",
      [CHAR_t]: "	",
      [CHAR_n]: "\n",
      [CHAR_f]: "\f",
      [CHAR_r]: "\r",
      [CHAR_QUOT]: '"',
      [CHAR_BSOL]: "\\"
    };
    function isDigit(cp) {
      return cp >= CHAR_0 && cp <= CHAR_9;
    }
    function isHexit(cp) {
      return cp >= CHAR_A && cp <= CHAR_F || cp >= CHAR_a && cp <= CHAR_f || cp >= CHAR_0 && cp <= CHAR_9;
    }
    function isBit(cp) {
      return cp === CHAR_1 || cp === CHAR_0;
    }
    function isOctit(cp) {
      return cp >= CHAR_0 && cp <= CHAR_7;
    }
    function isAlphaNumQuoteHyphen(cp) {
      return cp >= CHAR_A && cp <= CHAR_Z || cp >= CHAR_a && cp <= CHAR_z || cp >= CHAR_0 && cp <= CHAR_9 || cp === CHAR_APOS || cp === CHAR_QUOT || cp === CHAR_LOWBAR || cp === CHAR_HYPHEN;
    }
    function isAlphaNumHyphen(cp) {
      return cp >= CHAR_A && cp <= CHAR_Z || cp >= CHAR_a && cp <= CHAR_z || cp >= CHAR_0 && cp <= CHAR_9 || cp === CHAR_LOWBAR || cp === CHAR_HYPHEN;
    }
    var _type = Symbol("type");
    var _declared = Symbol("declared");
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var defineProperty = Object.defineProperty;
    var descriptor = { configurable: true, enumerable: true, writable: true, value: void 0 };
    function hasKey(obj, key) {
      if (hasOwnProperty2.call(obj, key))
        return true;
      if (key === "__proto__")
        defineProperty(obj, "__proto__", descriptor);
      return false;
    }
    var INLINE_TABLE = Symbol("inline-table");
    function InlineTable() {
      return Object.defineProperties({}, {
        [_type]: { value: INLINE_TABLE }
      });
    }
    function isInlineTable(obj) {
      if (obj === null || typeof obj !== "object")
        return false;
      return obj[_type] === INLINE_TABLE;
    }
    var TABLE = Symbol("table");
    function Table() {
      return Object.defineProperties({}, {
        [_type]: { value: TABLE },
        [_declared]: { value: false, writable: true }
      });
    }
    function isTable(obj) {
      if (obj === null || typeof obj !== "object")
        return false;
      return obj[_type] === TABLE;
    }
    var _contentType = Symbol("content-type");
    var INLINE_LIST = Symbol("inline-list");
    function InlineList(type) {
      return Object.defineProperties([], {
        [_type]: { value: INLINE_LIST },
        [_contentType]: { value: type }
      });
    }
    function isInlineList(obj) {
      if (obj === null || typeof obj !== "object")
        return false;
      return obj[_type] === INLINE_LIST;
    }
    var LIST = Symbol("list");
    function List() {
      return Object.defineProperties([], {
        [_type]: { value: LIST }
      });
    }
    function isList(obj) {
      if (obj === null || typeof obj !== "object")
        return false;
      return obj[_type] === LIST;
    }
    var _custom;
    try {
      const utilInspect = __require("util").inspect;
      _custom = utilInspect.custom;
    } catch (_) {
    }
    var _inspect = _custom || "inspect";
    var BoxedBigInt = class {
      constructor(value) {
        try {
          this.value = global.BigInt.asIntN(64, value);
        } catch (_) {
          this.value = null;
        }
        Object.defineProperty(this, _type, { value: INTEGER });
      }
      isNaN() {
        return this.value === null;
      }
      /* istanbul ignore next */
      toString() {
        return String(this.value);
      }
      /* istanbul ignore next */
      [_inspect]() {
        return `[BigInt: ${this.toString()}]}`;
      }
      valueOf() {
        return this.value;
      }
    };
    var INTEGER = Symbol("integer");
    function Integer(value) {
      let num = Number(value);
      if (Object.is(num, -0))
        num = 0;
      if (global.BigInt && !Number.isSafeInteger(num)) {
        return new BoxedBigInt(value);
      } else {
        return Object.defineProperties(new Number(num), {
          isNaN: { value: function() {
            return isNaN(this);
          } },
          [_type]: { value: INTEGER },
          [_inspect]: { value: () => `[Integer: ${value}]` }
        });
      }
    }
    function isInteger(obj) {
      if (obj === null || typeof obj !== "object")
        return false;
      return obj[_type] === INTEGER;
    }
    var FLOAT = Symbol("float");
    function Float(value) {
      return Object.defineProperties(new Number(value), {
        [_type]: { value: FLOAT },
        [_inspect]: { value: () => `[Float: ${value}]` }
      });
    }
    function isFloat(obj) {
      if (obj === null || typeof obj !== "object")
        return false;
      return obj[_type] === FLOAT;
    }
    function tomlType(value) {
      const type = typeof value;
      if (type === "object") {
        if (value === null)
          return "null";
        if (value instanceof Date)
          return "datetime";
        if (_type in value) {
          switch (value[_type]) {
            case INLINE_TABLE:
              return "inline-table";
            case INLINE_LIST:
              return "inline-list";
            case TABLE:
              return "table";
            case LIST:
              return "list";
            case FLOAT:
              return "float";
            case INTEGER:
              return "integer";
          }
        }
      }
      return type;
    }
    function makeParserClass(Parser) {
      class TOMLParser extends Parser {
        constructor() {
          super();
          this.ctx = this.obj = Table();
        }
        /* MATCH HELPER */
        atEndOfWord() {
          return this.char === CHAR_NUM || this.char === CTRL_I || this.char === CHAR_SP || this.atEndOfLine();
        }
        atEndOfLine() {
          return this.char === Parser.END || this.char === CTRL_J || this.char === CTRL_M;
        }
        parseStart() {
          if (this.char === Parser.END) {
            return null;
          } else if (this.char === CHAR_LSQB) {
            return this.call(this.parseTableOrList);
          } else if (this.char === CHAR_NUM) {
            return this.call(this.parseComment);
          } else if (this.char === CTRL_J || this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M) {
            return null;
          } else if (isAlphaNumQuoteHyphen(this.char)) {
            return this.callNow(this.parseAssignStatement);
          } else {
            throw this.error(new TomlError(`Unknown character "${this.char}"`));
          }
        }
        // HELPER, this strips any whitespace and comments to the end of the line
        // then RETURNS. Last state in a production.
        parseWhitespaceToEOL() {
          if (this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M) {
            return null;
          } else if (this.char === CHAR_NUM) {
            return this.goto(this.parseComment);
          } else if (this.char === Parser.END || this.char === CTRL_J) {
            return this.return();
          } else {
            throw this.error(new TomlError("Unexpected character, expected only whitespace or comments till end of line"));
          }
        }
        /* ASSIGNMENT: key = value */
        parseAssignStatement() {
          return this.callNow(this.parseAssign, this.recordAssignStatement);
        }
        recordAssignStatement(kv) {
          let target = this.ctx;
          let finalKey = kv.key.pop();
          for (let kw of kv.key) {
            if (hasKey(target, kw) && (!isTable(target[kw]) || target[kw][_declared])) {
              throw this.error(new TomlError("Can't redefine existing key"));
            }
            target = target[kw] = target[kw] || Table();
          }
          if (hasKey(target, finalKey)) {
            throw this.error(new TomlError("Can't redefine existing key"));
          }
          if (isInteger(kv.value) || isFloat(kv.value)) {
            target[finalKey] = kv.value.valueOf();
          } else {
            target[finalKey] = kv.value;
          }
          return this.goto(this.parseWhitespaceToEOL);
        }
        /* ASSSIGNMENT expression, key = value possibly inside an inline table */
        parseAssign() {
          return this.callNow(this.parseKeyword, this.recordAssignKeyword);
        }
        recordAssignKeyword(key) {
          if (this.state.resultTable) {
            this.state.resultTable.push(key);
          } else {
            this.state.resultTable = [key];
          }
          return this.goto(this.parseAssignKeywordPreDot);
        }
        parseAssignKeywordPreDot() {
          if (this.char === CHAR_PERIOD) {
            return this.next(this.parseAssignKeywordPostDot);
          } else if (this.char !== CHAR_SP && this.char !== CTRL_I) {
            return this.goto(this.parseAssignEqual);
          }
        }
        parseAssignKeywordPostDot() {
          if (this.char !== CHAR_SP && this.char !== CTRL_I) {
            return this.callNow(this.parseKeyword, this.recordAssignKeyword);
          }
        }
        parseAssignEqual() {
          if (this.char === CHAR_EQUALS) {
            return this.next(this.parseAssignPreValue);
          } else {
            throw this.error(new TomlError('Invalid character, expected "="'));
          }
        }
        parseAssignPreValue() {
          if (this.char === CHAR_SP || this.char === CTRL_I) {
            return null;
          } else {
            return this.callNow(this.parseValue, this.recordAssignValue);
          }
        }
        recordAssignValue(value) {
          return this.returnNow({ key: this.state.resultTable, value });
        }
        /* COMMENTS: #...eol */
        parseComment() {
          do {
            if (this.char === Parser.END || this.char === CTRL_J) {
              return this.return();
            }
          } while (this.nextChar());
        }
        /* TABLES AND LISTS, [foo] and [[foo]] */
        parseTableOrList() {
          if (this.char === CHAR_LSQB) {
            this.next(this.parseList);
          } else {
            return this.goto(this.parseTable);
          }
        }
        /* TABLE [foo.bar.baz] */
        parseTable() {
          this.ctx = this.obj;
          return this.goto(this.parseTableNext);
        }
        parseTableNext() {
          if (this.char === CHAR_SP || this.char === CTRL_I) {
            return null;
          } else {
            return this.callNow(this.parseKeyword, this.parseTableMore);
          }
        }
        parseTableMore(keyword) {
          if (this.char === CHAR_SP || this.char === CTRL_I) {
            return null;
          } else if (this.char === CHAR_RSQB) {
            if (hasKey(this.ctx, keyword) && (!isTable(this.ctx[keyword]) || this.ctx[keyword][_declared])) {
              throw this.error(new TomlError("Can't redefine existing key"));
            } else {
              this.ctx = this.ctx[keyword] = this.ctx[keyword] || Table();
              this.ctx[_declared] = true;
            }
            return this.next(this.parseWhitespaceToEOL);
          } else if (this.char === CHAR_PERIOD) {
            if (!hasKey(this.ctx, keyword)) {
              this.ctx = this.ctx[keyword] = Table();
            } else if (isTable(this.ctx[keyword])) {
              this.ctx = this.ctx[keyword];
            } else if (isList(this.ctx[keyword])) {
              this.ctx = this.ctx[keyword][this.ctx[keyword].length - 1];
            } else {
              throw this.error(new TomlError("Can't redefine existing key"));
            }
            return this.next(this.parseTableNext);
          } else {
            throw this.error(new TomlError("Unexpected character, expected whitespace, . or ]"));
          }
        }
        /* LIST [[a.b.c]] */
        parseList() {
          this.ctx = this.obj;
          return this.goto(this.parseListNext);
        }
        parseListNext() {
          if (this.char === CHAR_SP || this.char === CTRL_I) {
            return null;
          } else {
            return this.callNow(this.parseKeyword, this.parseListMore);
          }
        }
        parseListMore(keyword) {
          if (this.char === CHAR_SP || this.char === CTRL_I) {
            return null;
          } else if (this.char === CHAR_RSQB) {
            if (!hasKey(this.ctx, keyword)) {
              this.ctx[keyword] = List();
            }
            if (isInlineList(this.ctx[keyword])) {
              throw this.error(new TomlError("Can't extend an inline array"));
            } else if (isList(this.ctx[keyword])) {
              const next = Table();
              this.ctx[keyword].push(next);
              this.ctx = next;
            } else {
              throw this.error(new TomlError("Can't redefine an existing key"));
            }
            return this.next(this.parseListEnd);
          } else if (this.char === CHAR_PERIOD) {
            if (!hasKey(this.ctx, keyword)) {
              this.ctx = this.ctx[keyword] = Table();
            } else if (isInlineList(this.ctx[keyword])) {
              throw this.error(new TomlError("Can't extend an inline array"));
            } else if (isInlineTable(this.ctx[keyword])) {
              throw this.error(new TomlError("Can't extend an inline table"));
            } else if (isList(this.ctx[keyword])) {
              this.ctx = this.ctx[keyword][this.ctx[keyword].length - 1];
            } else if (isTable(this.ctx[keyword])) {
              this.ctx = this.ctx[keyword];
            } else {
              throw this.error(new TomlError("Can't redefine an existing key"));
            }
            return this.next(this.parseListNext);
          } else {
            throw this.error(new TomlError("Unexpected character, expected whitespace, . or ]"));
          }
        }
        parseListEnd(keyword) {
          if (this.char === CHAR_RSQB) {
            return this.next(this.parseWhitespaceToEOL);
          } else {
            throw this.error(new TomlError("Unexpected character, expected whitespace, . or ]"));
          }
        }
        /* VALUE string, number, boolean, inline list, inline object */
        parseValue() {
          if (this.char === Parser.END) {
            throw this.error(new TomlError("Key without value"));
          } else if (this.char === CHAR_QUOT) {
            return this.next(this.parseDoubleString);
          }
          if (this.char === CHAR_APOS) {
            return this.next(this.parseSingleString);
          } else if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS) {
            return this.goto(this.parseNumberSign);
          } else if (this.char === CHAR_i) {
            return this.next(this.parseInf);
          } else if (this.char === CHAR_n) {
            return this.next(this.parseNan);
          } else if (isDigit(this.char)) {
            return this.goto(this.parseNumberOrDateTime);
          } else if (this.char === CHAR_t || this.char === CHAR_f) {
            return this.goto(this.parseBoolean);
          } else if (this.char === CHAR_LSQB) {
            return this.call(this.parseInlineList, this.recordValue);
          } else if (this.char === CHAR_LCUB) {
            return this.call(this.parseInlineTable, this.recordValue);
          } else {
            throw this.error(new TomlError("Unexpected character, expecting string, number, datetime, boolean, inline array or inline table"));
          }
        }
        recordValue(value) {
          return this.returnNow(value);
        }
        parseInf() {
          if (this.char === CHAR_n) {
            return this.next(this.parseInf2);
          } else {
            throw this.error(new TomlError('Unexpected character, expected "inf", "+inf" or "-inf"'));
          }
        }
        parseInf2() {
          if (this.char === CHAR_f) {
            if (this.state.buf === "-") {
              return this.return(-Infinity);
            } else {
              return this.return(Infinity);
            }
          } else {
            throw this.error(new TomlError('Unexpected character, expected "inf", "+inf" or "-inf"'));
          }
        }
        parseNan() {
          if (this.char === CHAR_a) {
            return this.next(this.parseNan2);
          } else {
            throw this.error(new TomlError('Unexpected character, expected "nan"'));
          }
        }
        parseNan2() {
          if (this.char === CHAR_n) {
            return this.return(NaN);
          } else {
            throw this.error(new TomlError('Unexpected character, expected "nan"'));
          }
        }
        /* KEYS, barewords or basic, literal, or dotted */
        parseKeyword() {
          if (this.char === CHAR_QUOT) {
            return this.next(this.parseBasicString);
          } else if (this.char === CHAR_APOS) {
            return this.next(this.parseLiteralString);
          } else {
            return this.goto(this.parseBareKey);
          }
        }
        /* KEYS: barewords */
        parseBareKey() {
          do {
            if (this.char === Parser.END) {
              throw this.error(new TomlError("Key ended without value"));
            } else if (isAlphaNumHyphen(this.char)) {
              this.consume();
            } else if (this.state.buf.length === 0) {
              throw this.error(new TomlError("Empty bare keys are not allowed"));
            } else {
              return this.returnNow();
            }
          } while (this.nextChar());
        }
        /* STRINGS, single quoted (literal) */
        parseSingleString() {
          if (this.char === CHAR_APOS) {
            return this.next(this.parseLiteralMultiStringMaybe);
          } else {
            return this.goto(this.parseLiteralString);
          }
        }
        parseLiteralString() {
          do {
            if (this.char === CHAR_APOS) {
              return this.return();
            } else if (this.atEndOfLine()) {
              throw this.error(new TomlError("Unterminated string"));
            } else if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I) {
              throw this.errorControlCharInString();
            } else {
              this.consume();
            }
          } while (this.nextChar());
        }
        parseLiteralMultiStringMaybe() {
          if (this.char === CHAR_APOS) {
            return this.next(this.parseLiteralMultiString);
          } else {
            return this.returnNow();
          }
        }
        parseLiteralMultiString() {
          if (this.char === CTRL_M) {
            return null;
          } else if (this.char === CTRL_J) {
            return this.next(this.parseLiteralMultiStringContent);
          } else {
            return this.goto(this.parseLiteralMultiStringContent);
          }
        }
        parseLiteralMultiStringContent() {
          do {
            if (this.char === CHAR_APOS) {
              return this.next(this.parseLiteralMultiEnd);
            } else if (this.char === Parser.END) {
              throw this.error(new TomlError("Unterminated multi-line string"));
            } else if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I && this.char !== CTRL_J && this.char !== CTRL_M) {
              throw this.errorControlCharInString();
            } else {
              this.consume();
            }
          } while (this.nextChar());
        }
        parseLiteralMultiEnd() {
          if (this.char === CHAR_APOS) {
            return this.next(this.parseLiteralMultiEnd2);
          } else {
            this.state.buf += "'";
            return this.goto(this.parseLiteralMultiStringContent);
          }
        }
        parseLiteralMultiEnd2() {
          if (this.char === CHAR_APOS) {
            return this.return();
          } else {
            this.state.buf += "''";
            return this.goto(this.parseLiteralMultiStringContent);
          }
        }
        /* STRINGS double quoted */
        parseDoubleString() {
          if (this.char === CHAR_QUOT) {
            return this.next(this.parseMultiStringMaybe);
          } else {
            return this.goto(this.parseBasicString);
          }
        }
        parseBasicString() {
          do {
            if (this.char === CHAR_BSOL) {
              return this.call(this.parseEscape, this.recordEscapeReplacement);
            } else if (this.char === CHAR_QUOT) {
              return this.return();
            } else if (this.atEndOfLine()) {
              throw this.error(new TomlError("Unterminated string"));
            } else if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I) {
              throw this.errorControlCharInString();
            } else {
              this.consume();
            }
          } while (this.nextChar());
        }
        recordEscapeReplacement(replacement) {
          this.state.buf += replacement;
          return this.goto(this.parseBasicString);
        }
        parseMultiStringMaybe() {
          if (this.char === CHAR_QUOT) {
            return this.next(this.parseMultiString);
          } else {
            return this.returnNow();
          }
        }
        parseMultiString() {
          if (this.char === CTRL_M) {
            return null;
          } else if (this.char === CTRL_J) {
            return this.next(this.parseMultiStringContent);
          } else {
            return this.goto(this.parseMultiStringContent);
          }
        }
        parseMultiStringContent() {
          do {
            if (this.char === CHAR_BSOL) {
              return this.call(this.parseMultiEscape, this.recordMultiEscapeReplacement);
            } else if (this.char === CHAR_QUOT) {
              return this.next(this.parseMultiEnd);
            } else if (this.char === Parser.END) {
              throw this.error(new TomlError("Unterminated multi-line string"));
            } else if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I && this.char !== CTRL_J && this.char !== CTRL_M) {
              throw this.errorControlCharInString();
            } else {
              this.consume();
            }
          } while (this.nextChar());
        }
        errorControlCharInString() {
          let displayCode = "\\u00";
          if (this.char < 16) {
            displayCode += "0";
          }
          displayCode += this.char.toString(16);
          return this.error(new TomlError(`Control characters (codes < 0x1f and 0x7f) are not allowed in strings, use ${displayCode} instead`));
        }
        recordMultiEscapeReplacement(replacement) {
          this.state.buf += replacement;
          return this.goto(this.parseMultiStringContent);
        }
        parseMultiEnd() {
          if (this.char === CHAR_QUOT) {
            return this.next(this.parseMultiEnd2);
          } else {
            this.state.buf += '"';
            return this.goto(this.parseMultiStringContent);
          }
        }
        parseMultiEnd2() {
          if (this.char === CHAR_QUOT) {
            return this.return();
          } else {
            this.state.buf += '""';
            return this.goto(this.parseMultiStringContent);
          }
        }
        parseMultiEscape() {
          if (this.char === CTRL_M || this.char === CTRL_J) {
            return this.next(this.parseMultiTrim);
          } else if (this.char === CHAR_SP || this.char === CTRL_I) {
            return this.next(this.parsePreMultiTrim);
          } else {
            return this.goto(this.parseEscape);
          }
        }
        parsePreMultiTrim() {
          if (this.char === CHAR_SP || this.char === CTRL_I) {
            return null;
          } else if (this.char === CTRL_M || this.char === CTRL_J) {
            return this.next(this.parseMultiTrim);
          } else {
            throw this.error(new TomlError("Can't escape whitespace"));
          }
        }
        parseMultiTrim() {
          if (this.char === CTRL_J || this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M) {
            return null;
          } else {
            return this.returnNow();
          }
        }
        parseEscape() {
          if (this.char in escapes) {
            return this.return(escapes[this.char]);
          } else if (this.char === CHAR_u) {
            return this.call(this.parseSmallUnicode, this.parseUnicodeReturn);
          } else if (this.char === CHAR_U) {
            return this.call(this.parseLargeUnicode, this.parseUnicodeReturn);
          } else {
            throw this.error(new TomlError("Unknown escape character: " + this.char));
          }
        }
        parseUnicodeReturn(char) {
          try {
            const codePoint = parseInt(char, 16);
            if (codePoint >= SURROGATE_FIRST && codePoint <= SURROGATE_LAST) {
              throw this.error(new TomlError("Invalid unicode, character in range 0xD800 - 0xDFFF is reserved"));
            }
            return this.returnNow(String.fromCodePoint(codePoint));
          } catch (err) {
            throw this.error(TomlError.wrap(err));
          }
        }
        parseSmallUnicode() {
          if (!isHexit(this.char)) {
            throw this.error(new TomlError("Invalid character in unicode sequence, expected hex"));
          } else {
            this.consume();
            if (this.state.buf.length >= 4)
              return this.return();
          }
        }
        parseLargeUnicode() {
          if (!isHexit(this.char)) {
            throw this.error(new TomlError("Invalid character in unicode sequence, expected hex"));
          } else {
            this.consume();
            if (this.state.buf.length >= 8)
              return this.return();
          }
        }
        /* NUMBERS */
        parseNumberSign() {
          this.consume();
          return this.next(this.parseMaybeSignedInfOrNan);
        }
        parseMaybeSignedInfOrNan() {
          if (this.char === CHAR_i) {
            return this.next(this.parseInf);
          } else if (this.char === CHAR_n) {
            return this.next(this.parseNan);
          } else {
            return this.callNow(this.parseNoUnder, this.parseNumberIntegerStart);
          }
        }
        parseNumberIntegerStart() {
          if (this.char === CHAR_0) {
            this.consume();
            return this.next(this.parseNumberIntegerExponentOrDecimal);
          } else {
            return this.goto(this.parseNumberInteger);
          }
        }
        parseNumberIntegerExponentOrDecimal() {
          if (this.char === CHAR_PERIOD) {
            this.consume();
            return this.call(this.parseNoUnder, this.parseNumberFloat);
          } else if (this.char === CHAR_E || this.char === CHAR_e) {
            this.consume();
            return this.next(this.parseNumberExponentSign);
          } else {
            return this.returnNow(Integer(this.state.buf));
          }
        }
        parseNumberInteger() {
          if (isDigit(this.char)) {
            this.consume();
          } else if (this.char === CHAR_LOWBAR) {
            return this.call(this.parseNoUnder);
          } else if (this.char === CHAR_E || this.char === CHAR_e) {
            this.consume();
            return this.next(this.parseNumberExponentSign);
          } else if (this.char === CHAR_PERIOD) {
            this.consume();
            return this.call(this.parseNoUnder, this.parseNumberFloat);
          } else {
            const result = Integer(this.state.buf);
            if (result.isNaN()) {
              throw this.error(new TomlError("Invalid number"));
            } else {
              return this.returnNow(result);
            }
          }
        }
        parseNoUnder() {
          if (this.char === CHAR_LOWBAR || this.char === CHAR_PERIOD || this.char === CHAR_E || this.char === CHAR_e) {
            throw this.error(new TomlError("Unexpected character, expected digit"));
          } else if (this.atEndOfWord()) {
            throw this.error(new TomlError("Incomplete number"));
          }
          return this.returnNow();
        }
        parseNoUnderHexOctBinLiteral() {
          if (this.char === CHAR_LOWBAR || this.char === CHAR_PERIOD) {
            throw this.error(new TomlError("Unexpected character, expected digit"));
          } else if (this.atEndOfWord()) {
            throw this.error(new TomlError("Incomplete number"));
          }
          return this.returnNow();
        }
        parseNumberFloat() {
          if (this.char === CHAR_LOWBAR) {
            return this.call(this.parseNoUnder, this.parseNumberFloat);
          } else if (isDigit(this.char)) {
            this.consume();
          } else if (this.char === CHAR_E || this.char === CHAR_e) {
            this.consume();
            return this.next(this.parseNumberExponentSign);
          } else {
            return this.returnNow(Float(this.state.buf));
          }
        }
        parseNumberExponentSign() {
          if (isDigit(this.char)) {
            return this.goto(this.parseNumberExponent);
          } else if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS) {
            this.consume();
            this.call(this.parseNoUnder, this.parseNumberExponent);
          } else {
            throw this.error(new TomlError("Unexpected character, expected -, + or digit"));
          }
        }
        parseNumberExponent() {
          if (isDigit(this.char)) {
            this.consume();
          } else if (this.char === CHAR_LOWBAR) {
            return this.call(this.parseNoUnder);
          } else {
            return this.returnNow(Float(this.state.buf));
          }
        }
        /* NUMBERS or DATETIMES  */
        parseNumberOrDateTime() {
          if (this.char === CHAR_0) {
            this.consume();
            return this.next(this.parseNumberBaseOrDateTime);
          } else {
            return this.goto(this.parseNumberOrDateTimeOnly);
          }
        }
        parseNumberOrDateTimeOnly() {
          if (this.char === CHAR_LOWBAR) {
            return this.call(this.parseNoUnder, this.parseNumberInteger);
          } else if (isDigit(this.char)) {
            this.consume();
            if (this.state.buf.length > 4)
              this.next(this.parseNumberInteger);
          } else if (this.char === CHAR_E || this.char === CHAR_e) {
            this.consume();
            return this.next(this.parseNumberExponentSign);
          } else if (this.char === CHAR_PERIOD) {
            this.consume();
            return this.call(this.parseNoUnder, this.parseNumberFloat);
          } else if (this.char === CHAR_HYPHEN) {
            return this.goto(this.parseDateTime);
          } else if (this.char === CHAR_COLON) {
            return this.goto(this.parseOnlyTimeHour);
          } else {
            return this.returnNow(Integer(this.state.buf));
          }
        }
        parseDateTimeOnly() {
          if (this.state.buf.length < 4) {
            if (isDigit(this.char)) {
              return this.consume();
            } else if (this.char === CHAR_COLON) {
              return this.goto(this.parseOnlyTimeHour);
            } else {
              throw this.error(new TomlError("Expected digit while parsing year part of a date"));
            }
          } else {
            if (this.char === CHAR_HYPHEN) {
              return this.goto(this.parseDateTime);
            } else {
              throw this.error(new TomlError("Expected hyphen (-) while parsing year part of date"));
            }
          }
        }
        parseNumberBaseOrDateTime() {
          if (this.char === CHAR_b) {
            this.consume();
            return this.call(this.parseNoUnderHexOctBinLiteral, this.parseIntegerBin);
          } else if (this.char === CHAR_o) {
            this.consume();
            return this.call(this.parseNoUnderHexOctBinLiteral, this.parseIntegerOct);
          } else if (this.char === CHAR_x) {
            this.consume();
            return this.call(this.parseNoUnderHexOctBinLiteral, this.parseIntegerHex);
          } else if (this.char === CHAR_PERIOD) {
            return this.goto(this.parseNumberInteger);
          } else if (isDigit(this.char)) {
            return this.goto(this.parseDateTimeOnly);
          } else {
            return this.returnNow(Integer(this.state.buf));
          }
        }
        parseIntegerHex() {
          if (isHexit(this.char)) {
            this.consume();
          } else if (this.char === CHAR_LOWBAR) {
            return this.call(this.parseNoUnderHexOctBinLiteral);
          } else {
            const result = Integer(this.state.buf);
            if (result.isNaN()) {
              throw this.error(new TomlError("Invalid number"));
            } else {
              return this.returnNow(result);
            }
          }
        }
        parseIntegerOct() {
          if (isOctit(this.char)) {
            this.consume();
          } else if (this.char === CHAR_LOWBAR) {
            return this.call(this.parseNoUnderHexOctBinLiteral);
          } else {
            const result = Integer(this.state.buf);
            if (result.isNaN()) {
              throw this.error(new TomlError("Invalid number"));
            } else {
              return this.returnNow(result);
            }
          }
        }
        parseIntegerBin() {
          if (isBit(this.char)) {
            this.consume();
          } else if (this.char === CHAR_LOWBAR) {
            return this.call(this.parseNoUnderHexOctBinLiteral);
          } else {
            const result = Integer(this.state.buf);
            if (result.isNaN()) {
              throw this.error(new TomlError("Invalid number"));
            } else {
              return this.returnNow(result);
            }
          }
        }
        /* DATETIME */
        parseDateTime() {
          if (this.state.buf.length < 4) {
            throw this.error(new TomlError("Years less than 1000 must be zero padded to four characters"));
          }
          this.state.result = this.state.buf;
          this.state.buf = "";
          return this.next(this.parseDateMonth);
        }
        parseDateMonth() {
          if (this.char === CHAR_HYPHEN) {
            if (this.state.buf.length < 2) {
              throw this.error(new TomlError("Months less than 10 must be zero padded to two characters"));
            }
            this.state.result += "-" + this.state.buf;
            this.state.buf = "";
            return this.next(this.parseDateDay);
          } else if (isDigit(this.char)) {
            this.consume();
          } else {
            throw this.error(new TomlError("Incomplete datetime"));
          }
        }
        parseDateDay() {
          if (this.char === CHAR_T || this.char === CHAR_SP) {
            if (this.state.buf.length < 2) {
              throw this.error(new TomlError("Days less than 10 must be zero padded to two characters"));
            }
            this.state.result += "-" + this.state.buf;
            this.state.buf = "";
            return this.next(this.parseStartTimeHour);
          } else if (this.atEndOfWord()) {
            return this.returnNow(createDate(this.state.result + "-" + this.state.buf));
          } else if (isDigit(this.char)) {
            this.consume();
          } else {
            throw this.error(new TomlError("Incomplete datetime"));
          }
        }
        parseStartTimeHour() {
          if (this.atEndOfWord()) {
            return this.returnNow(createDate(this.state.result));
          } else {
            return this.goto(this.parseTimeHour);
          }
        }
        parseTimeHour() {
          if (this.char === CHAR_COLON) {
            if (this.state.buf.length < 2) {
              throw this.error(new TomlError("Hours less than 10 must be zero padded to two characters"));
            }
            this.state.result += "T" + this.state.buf;
            this.state.buf = "";
            return this.next(this.parseTimeMin);
          } else if (isDigit(this.char)) {
            this.consume();
          } else {
            throw this.error(new TomlError("Incomplete datetime"));
          }
        }
        parseTimeMin() {
          if (this.state.buf.length < 2 && isDigit(this.char)) {
            this.consume();
          } else if (this.state.buf.length === 2 && this.char === CHAR_COLON) {
            this.state.result += ":" + this.state.buf;
            this.state.buf = "";
            return this.next(this.parseTimeSec);
          } else {
            throw this.error(new TomlError("Incomplete datetime"));
          }
        }
        parseTimeSec() {
          if (isDigit(this.char)) {
            this.consume();
            if (this.state.buf.length === 2) {
              this.state.result += ":" + this.state.buf;
              this.state.buf = "";
              return this.next(this.parseTimeZoneOrFraction);
            }
          } else {
            throw this.error(new TomlError("Incomplete datetime"));
          }
        }
        parseOnlyTimeHour() {
          if (this.char === CHAR_COLON) {
            if (this.state.buf.length < 2) {
              throw this.error(new TomlError("Hours less than 10 must be zero padded to two characters"));
            }
            this.state.result = this.state.buf;
            this.state.buf = "";
            return this.next(this.parseOnlyTimeMin);
          } else {
            throw this.error(new TomlError("Incomplete time"));
          }
        }
        parseOnlyTimeMin() {
          if (this.state.buf.length < 2 && isDigit(this.char)) {
            this.consume();
          } else if (this.state.buf.length === 2 && this.char === CHAR_COLON) {
            this.state.result += ":" + this.state.buf;
            this.state.buf = "";
            return this.next(this.parseOnlyTimeSec);
          } else {
            throw this.error(new TomlError("Incomplete time"));
          }
        }
        parseOnlyTimeSec() {
          if (isDigit(this.char)) {
            this.consume();
            if (this.state.buf.length === 2) {
              return this.next(this.parseOnlyTimeFractionMaybe);
            }
          } else {
            throw this.error(new TomlError("Incomplete time"));
          }
        }
        parseOnlyTimeFractionMaybe() {
          this.state.result += ":" + this.state.buf;
          if (this.char === CHAR_PERIOD) {
            this.state.buf = "";
            this.next(this.parseOnlyTimeFraction);
          } else {
            return this.return(createTime(this.state.result));
          }
        }
        parseOnlyTimeFraction() {
          if (isDigit(this.char)) {
            this.consume();
          } else if (this.atEndOfWord()) {
            if (this.state.buf.length === 0)
              throw this.error(new TomlError("Expected digit in milliseconds"));
            return this.returnNow(createTime(this.state.result + "." + this.state.buf));
          } else {
            throw this.error(new TomlError("Unexpected character in datetime, expected period (.), minus (-), plus (+) or Z"));
          }
        }
        parseTimeZoneOrFraction() {
          if (this.char === CHAR_PERIOD) {
            this.consume();
            this.next(this.parseDateTimeFraction);
          } else if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS) {
            this.consume();
            this.next(this.parseTimeZoneHour);
          } else if (this.char === CHAR_Z) {
            this.consume();
            return this.return(createDateTime(this.state.result + this.state.buf));
          } else if (this.atEndOfWord()) {
            return this.returnNow(createDateTimeFloat(this.state.result + this.state.buf));
          } else {
            throw this.error(new TomlError("Unexpected character in datetime, expected period (.), minus (-), plus (+) or Z"));
          }
        }
        parseDateTimeFraction() {
          if (isDigit(this.char)) {
            this.consume();
          } else if (this.state.buf.length === 1) {
            throw this.error(new TomlError("Expected digit in milliseconds"));
          } else if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS) {
            this.consume();
            this.next(this.parseTimeZoneHour);
          } else if (this.char === CHAR_Z) {
            this.consume();
            return this.return(createDateTime(this.state.result + this.state.buf));
          } else if (this.atEndOfWord()) {
            return this.returnNow(createDateTimeFloat(this.state.result + this.state.buf));
          } else {
            throw this.error(new TomlError("Unexpected character in datetime, expected period (.), minus (-), plus (+) or Z"));
          }
        }
        parseTimeZoneHour() {
          if (isDigit(this.char)) {
            this.consume();
            if (/\d\d$/.test(this.state.buf))
              return this.next(this.parseTimeZoneSep);
          } else {
            throw this.error(new TomlError("Unexpected character in datetime, expected digit"));
          }
        }
        parseTimeZoneSep() {
          if (this.char === CHAR_COLON) {
            this.consume();
            this.next(this.parseTimeZoneMin);
          } else {
            throw this.error(new TomlError("Unexpected character in datetime, expected colon"));
          }
        }
        parseTimeZoneMin() {
          if (isDigit(this.char)) {
            this.consume();
            if (/\d\d$/.test(this.state.buf))
              return this.return(createDateTime(this.state.result + this.state.buf));
          } else {
            throw this.error(new TomlError("Unexpected character in datetime, expected digit"));
          }
        }
        /* BOOLEAN */
        parseBoolean() {
          if (this.char === CHAR_t) {
            this.consume();
            return this.next(this.parseTrue_r);
          } else if (this.char === CHAR_f) {
            this.consume();
            return this.next(this.parseFalse_a);
          }
        }
        parseTrue_r() {
          if (this.char === CHAR_r) {
            this.consume();
            return this.next(this.parseTrue_u);
          } else {
            throw this.error(new TomlError("Invalid boolean, expected true or false"));
          }
        }
        parseTrue_u() {
          if (this.char === CHAR_u) {
            this.consume();
            return this.next(this.parseTrue_e);
          } else {
            throw this.error(new TomlError("Invalid boolean, expected true or false"));
          }
        }
        parseTrue_e() {
          if (this.char === CHAR_e) {
            return this.return(true);
          } else {
            throw this.error(new TomlError("Invalid boolean, expected true or false"));
          }
        }
        parseFalse_a() {
          if (this.char === CHAR_a) {
            this.consume();
            return this.next(this.parseFalse_l);
          } else {
            throw this.error(new TomlError("Invalid boolean, expected true or false"));
          }
        }
        parseFalse_l() {
          if (this.char === CHAR_l) {
            this.consume();
            return this.next(this.parseFalse_s);
          } else {
            throw this.error(new TomlError("Invalid boolean, expected true or false"));
          }
        }
        parseFalse_s() {
          if (this.char === CHAR_s) {
            this.consume();
            return this.next(this.parseFalse_e);
          } else {
            throw this.error(new TomlError("Invalid boolean, expected true or false"));
          }
        }
        parseFalse_e() {
          if (this.char === CHAR_e) {
            return this.return(false);
          } else {
            throw this.error(new TomlError("Invalid boolean, expected true or false"));
          }
        }
        /* INLINE LISTS */
        parseInlineList() {
          if (this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M || this.char === CTRL_J) {
            return null;
          } else if (this.char === Parser.END) {
            throw this.error(new TomlError("Unterminated inline array"));
          } else if (this.char === CHAR_NUM) {
            return this.call(this.parseComment);
          } else if (this.char === CHAR_RSQB) {
            return this.return(this.state.resultArr || InlineList());
          } else {
            return this.callNow(this.parseValue, this.recordInlineListValue);
          }
        }
        recordInlineListValue(value) {
          if (this.state.resultArr) {
            const listType = this.state.resultArr[_contentType];
            const valueType = tomlType(value);
            if (listType !== valueType) {
              throw this.error(new TomlError(`Inline lists must be a single type, not a mix of ${listType} and ${valueType}`));
            }
          } else {
            this.state.resultArr = InlineList(tomlType(value));
          }
          if (isFloat(value) || isInteger(value)) {
            this.state.resultArr.push(value.valueOf());
          } else {
            this.state.resultArr.push(value);
          }
          return this.goto(this.parseInlineListNext);
        }
        parseInlineListNext() {
          if (this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M || this.char === CTRL_J) {
            return null;
          } else if (this.char === CHAR_NUM) {
            return this.call(this.parseComment);
          } else if (this.char === CHAR_COMMA) {
            return this.next(this.parseInlineList);
          } else if (this.char === CHAR_RSQB) {
            return this.goto(this.parseInlineList);
          } else {
            throw this.error(new TomlError("Invalid character, expected whitespace, comma (,) or close bracket (])"));
          }
        }
        /* INLINE TABLE */
        parseInlineTable() {
          if (this.char === CHAR_SP || this.char === CTRL_I) {
            return null;
          } else if (this.char === Parser.END || this.char === CHAR_NUM || this.char === CTRL_J || this.char === CTRL_M) {
            throw this.error(new TomlError("Unterminated inline array"));
          } else if (this.char === CHAR_RCUB) {
            return this.return(this.state.resultTable || InlineTable());
          } else {
            if (!this.state.resultTable)
              this.state.resultTable = InlineTable();
            return this.callNow(this.parseAssign, this.recordInlineTableValue);
          }
        }
        recordInlineTableValue(kv) {
          let target = this.state.resultTable;
          let finalKey = kv.key.pop();
          for (let kw of kv.key) {
            if (hasKey(target, kw) && (!isTable(target[kw]) || target[kw][_declared])) {
              throw this.error(new TomlError("Can't redefine existing key"));
            }
            target = target[kw] = target[kw] || Table();
          }
          if (hasKey(target, finalKey)) {
            throw this.error(new TomlError("Can't redefine existing key"));
          }
          if (isInteger(kv.value) || isFloat(kv.value)) {
            target[finalKey] = kv.value.valueOf();
          } else {
            target[finalKey] = kv.value;
          }
          return this.goto(this.parseInlineTableNext);
        }
        parseInlineTableNext() {
          if (this.char === CHAR_SP || this.char === CTRL_I) {
            return null;
          } else if (this.char === Parser.END || this.char === CHAR_NUM || this.char === CTRL_J || this.char === CTRL_M) {
            throw this.error(new TomlError("Unterminated inline array"));
          } else if (this.char === CHAR_COMMA) {
            return this.next(this.parseInlineTable);
          } else if (this.char === CHAR_RCUB) {
            return this.goto(this.parseInlineTable);
          } else {
            throw this.error(new TomlError("Invalid character, expected whitespace, comma (,) or close bracket (])"));
          }
        }
      }
      return TOMLParser;
    }
  }
});

// node_modules/@iarna/toml/parse-pretty-error.js
var require_parse_pretty_error = __commonJS({
  "node_modules/@iarna/toml/parse-pretty-error.js"(exports, module) {
    "use strict";
    module.exports = prettyError;
    function prettyError(err, buf) {
      if (err.pos == null || err.line == null)
        return err;
      let msg = err.message;
      msg += ` at row ${err.line + 1}, col ${err.col + 1}, pos ${err.pos}:
`;
      if (buf && buf.split) {
        const lines = buf.split(/\n/);
        const lineNumWidth = String(Math.min(lines.length, err.line + 3)).length;
        let linePadding = " ";
        while (linePadding.length < lineNumWidth)
          linePadding += " ";
        for (let ii = Math.max(0, err.line - 1); ii < Math.min(lines.length, err.line + 2); ++ii) {
          let lineNum = String(ii + 1);
          if (lineNum.length < lineNumWidth)
            lineNum = " " + lineNum;
          if (err.line === ii) {
            msg += lineNum + "> " + lines[ii] + "\n";
            msg += linePadding + "  ";
            for (let hh = 0; hh < err.col; ++hh) {
              msg += " ";
            }
            msg += "^\n";
          } else {
            msg += lineNum + ": " + lines[ii] + "\n";
          }
        }
      }
      err.message = msg + "\n";
      return err;
    }
  }
});

// node_modules/@iarna/toml/parse-async.js
var require_parse_async = __commonJS({
  "node_modules/@iarna/toml/parse-async.js"(exports, module) {
    "use strict";
    module.exports = parseAsync;
    var TOMLParser = require_toml_parser();
    var prettyError = require_parse_pretty_error();
    function parseAsync(str, opts) {
      if (!opts)
        opts = {};
      const index = 0;
      const blocksize = opts.blocksize || 40960;
      const parser = new TOMLParser();
      return new Promise((resolve2, reject) => {
        setImmediate(parseAsyncNext, index, blocksize, resolve2, reject);
      });
      function parseAsyncNext(index2, blocksize2, resolve2, reject) {
        if (index2 >= str.length) {
          try {
            return resolve2(parser.finish());
          } catch (err) {
            return reject(prettyError(err, str));
          }
        }
        try {
          parser.parse(str.slice(index2, index2 + blocksize2));
          setImmediate(parseAsyncNext, index2 + blocksize2, blocksize2, resolve2, reject);
        } catch (err) {
          reject(prettyError(err, str));
        }
      }
    }
  }
});

// node_modules/json5/lib/unicode.js
var require_unicode = __commonJS({
  "node_modules/json5/lib/unicode.js"(exports, module) {
    module.exports.Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/;
    module.exports.ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
    module.exports.ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;
  }
});

// node_modules/json5/lib/util.js
var require_util = __commonJS({
  "node_modules/json5/lib/util.js"(exports, module) {
    var unicode = require_unicode();
    module.exports = {
      isSpaceSeparator(c) {
        return typeof c === "string" && unicode.Space_Separator.test(c);
      },
      isIdStartChar(c) {
        return typeof c === "string" && (c >= "a" && c <= "z" || c >= "A" && c <= "Z" || c === "$" || c === "_" || unicode.ID_Start.test(c));
      },
      isIdContinueChar(c) {
        return typeof c === "string" && (c >= "a" && c <= "z" || c >= "A" && c <= "Z" || c >= "0" && c <= "9" || c === "$" || c === "_" || c === "\u200C" || c === "\u200D" || unicode.ID_Continue.test(c));
      },
      isDigit(c) {
        return typeof c === "string" && /[0-9]/.test(c);
      },
      isHexDigit(c) {
        return typeof c === "string" && /[0-9A-Fa-f]/.test(c);
      }
    };
  }
});

// node_modules/json5/lib/parse.js
var require_parse3 = __commonJS({
  "node_modules/json5/lib/parse.js"(exports, module) {
    var util = require_util();
    var source;
    var parseState;
    var stack;
    var pos;
    var line2;
    var column;
    var token;
    var key;
    var root;
    module.exports = function parse4(text, reviver) {
      source = String(text);
      parseState = "start";
      stack = [];
      pos = 0;
      line2 = 1;
      column = 0;
      token = void 0;
      key = void 0;
      root = void 0;
      do {
        token = lex();
        parseStates[parseState]();
      } while (token.type !== "eof");
      if (typeof reviver === "function") {
        return internalize({ "": root }, "", reviver);
      }
      return root;
    };
    function internalize(holder, name, reviver) {
      const value = holder[name];
      if (value != null && typeof value === "object") {
        if (Array.isArray(value)) {
          for (let i = 0; i < value.length; i++) {
            const key2 = String(i);
            const replacement = internalize(value, key2, reviver);
            if (replacement === void 0) {
              delete value[key2];
            } else {
              Object.defineProperty(value, key2, {
                value: replacement,
                writable: true,
                enumerable: true,
                configurable: true
              });
            }
          }
        } else {
          for (const key2 in value) {
            const replacement = internalize(value, key2, reviver);
            if (replacement === void 0) {
              delete value[key2];
            } else {
              Object.defineProperty(value, key2, {
                value: replacement,
                writable: true,
                enumerable: true,
                configurable: true
              });
            }
          }
        }
      }
      return reviver.call(holder, name, value);
    }
    var lexState;
    var buffer;
    var doubleQuote;
    var sign;
    var c;
    function lex() {
      lexState = "default";
      buffer = "";
      doubleQuote = false;
      sign = 1;
      for (; ; ) {
        c = peek();
        const token2 = lexStates[lexState]();
        if (token2) {
          return token2;
        }
      }
    }
    function peek() {
      if (source[pos]) {
        return String.fromCodePoint(source.codePointAt(pos));
      }
    }
    function read2() {
      const c2 = peek();
      if (c2 === "\n") {
        line2++;
        column = 0;
      } else if (c2) {
        column += c2.length;
      } else {
        column++;
      }
      if (c2) {
        pos += c2.length;
      }
      return c2;
    }
    var lexStates = {
      default() {
        switch (c) {
          case "	":
          case "\v":
          case "\f":
          case " ":
          case "\xA0":
          case "\uFEFF":
          case "\n":
          case "\r":
          case "\u2028":
          case "\u2029":
            read2();
            return;
          case "/":
            read2();
            lexState = "comment";
            return;
          case void 0:
            read2();
            return newToken("eof");
        }
        if (util.isSpaceSeparator(c)) {
          read2();
          return;
        }
        return lexStates[parseState]();
      },
      comment() {
        switch (c) {
          case "*":
            read2();
            lexState = "multiLineComment";
            return;
          case "/":
            read2();
            lexState = "singleLineComment";
            return;
        }
        throw invalidChar(read2());
      },
      multiLineComment() {
        switch (c) {
          case "*":
            read2();
            lexState = "multiLineCommentAsterisk";
            return;
          case void 0:
            throw invalidChar(read2());
        }
        read2();
      },
      multiLineCommentAsterisk() {
        switch (c) {
          case "*":
            read2();
            return;
          case "/":
            read2();
            lexState = "default";
            return;
          case void 0:
            throw invalidChar(read2());
        }
        read2();
        lexState = "multiLineComment";
      },
      singleLineComment() {
        switch (c) {
          case "\n":
          case "\r":
          case "\u2028":
          case "\u2029":
            read2();
            lexState = "default";
            return;
          case void 0:
            read2();
            return newToken("eof");
        }
        read2();
      },
      value() {
        switch (c) {
          case "{":
          case "[":
            return newToken("punctuator", read2());
          case "n":
            read2();
            literal("ull");
            return newToken("null", null);
          case "t":
            read2();
            literal("rue");
            return newToken("boolean", true);
          case "f":
            read2();
            literal("alse");
            return newToken("boolean", false);
          case "-":
          case "+":
            if (read2() === "-") {
              sign = -1;
            }
            lexState = "sign";
            return;
          case ".":
            buffer = read2();
            lexState = "decimalPointLeading";
            return;
          case "0":
            buffer = read2();
            lexState = "zero";
            return;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
            buffer = read2();
            lexState = "decimalInteger";
            return;
          case "I":
            read2();
            literal("nfinity");
            return newToken("numeric", Infinity);
          case "N":
            read2();
            literal("aN");
            return newToken("numeric", NaN);
          case '"':
          case "'":
            doubleQuote = read2() === '"';
            buffer = "";
            lexState = "string";
            return;
        }
        throw invalidChar(read2());
      },
      identifierNameStartEscape() {
        if (c !== "u") {
          throw invalidChar(read2());
        }
        read2();
        const u = unicodeEscape();
        switch (u) {
          case "$":
          case "_":
            break;
          default:
            if (!util.isIdStartChar(u)) {
              throw invalidIdentifier();
            }
            break;
        }
        buffer += u;
        lexState = "identifierName";
      },
      identifierName() {
        switch (c) {
          case "$":
          case "_":
          case "\u200C":
          case "\u200D":
            buffer += read2();
            return;
          case "\\":
            read2();
            lexState = "identifierNameEscape";
            return;
        }
        if (util.isIdContinueChar(c)) {
          buffer += read2();
          return;
        }
        return newToken("identifier", buffer);
      },
      identifierNameEscape() {
        if (c !== "u") {
          throw invalidChar(read2());
        }
        read2();
        const u = unicodeEscape();
        switch (u) {
          case "$":
          case "_":
          case "\u200C":
          case "\u200D":
            break;
          default:
            if (!util.isIdContinueChar(u)) {
              throw invalidIdentifier();
            }
            break;
        }
        buffer += u;
        lexState = "identifierName";
      },
      sign() {
        switch (c) {
          case ".":
            buffer = read2();
            lexState = "decimalPointLeading";
            return;
          case "0":
            buffer = read2();
            lexState = "zero";
            return;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
            buffer = read2();
            lexState = "decimalInteger";
            return;
          case "I":
            read2();
            literal("nfinity");
            return newToken("numeric", sign * Infinity);
          case "N":
            read2();
            literal("aN");
            return newToken("numeric", NaN);
        }
        throw invalidChar(read2());
      },
      zero() {
        switch (c) {
          case ".":
            buffer += read2();
            lexState = "decimalPoint";
            return;
          case "e":
          case "E":
            buffer += read2();
            lexState = "decimalExponent";
            return;
          case "x":
          case "X":
            buffer += read2();
            lexState = "hexadecimal";
            return;
        }
        return newToken("numeric", sign * 0);
      },
      decimalInteger() {
        switch (c) {
          case ".":
            buffer += read2();
            lexState = "decimalPoint";
            return;
          case "e":
          case "E":
            buffer += read2();
            lexState = "decimalExponent";
            return;
        }
        if (util.isDigit(c)) {
          buffer += read2();
          return;
        }
        return newToken("numeric", sign * Number(buffer));
      },
      decimalPointLeading() {
        if (util.isDigit(c)) {
          buffer += read2();
          lexState = "decimalFraction";
          return;
        }
        throw invalidChar(read2());
      },
      decimalPoint() {
        switch (c) {
          case "e":
          case "E":
            buffer += read2();
            lexState = "decimalExponent";
            return;
        }
        if (util.isDigit(c)) {
          buffer += read2();
          lexState = "decimalFraction";
          return;
        }
        return newToken("numeric", sign * Number(buffer));
      },
      decimalFraction() {
        switch (c) {
          case "e":
          case "E":
            buffer += read2();
            lexState = "decimalExponent";
            return;
        }
        if (util.isDigit(c)) {
          buffer += read2();
          return;
        }
        return newToken("numeric", sign * Number(buffer));
      },
      decimalExponent() {
        switch (c) {
          case "+":
          case "-":
            buffer += read2();
            lexState = "decimalExponentSign";
            return;
        }
        if (util.isDigit(c)) {
          buffer += read2();
          lexState = "decimalExponentInteger";
          return;
        }
        throw invalidChar(read2());
      },
      decimalExponentSign() {
        if (util.isDigit(c)) {
          buffer += read2();
          lexState = "decimalExponentInteger";
          return;
        }
        throw invalidChar(read2());
      },
      decimalExponentInteger() {
        if (util.isDigit(c)) {
          buffer += read2();
          return;
        }
        return newToken("numeric", sign * Number(buffer));
      },
      hexadecimal() {
        if (util.isHexDigit(c)) {
          buffer += read2();
          lexState = "hexadecimalInteger";
          return;
        }
        throw invalidChar(read2());
      },
      hexadecimalInteger() {
        if (util.isHexDigit(c)) {
          buffer += read2();
          return;
        }
        return newToken("numeric", sign * Number(buffer));
      },
      string() {
        switch (c) {
          case "\\":
            read2();
            buffer += escape();
            return;
          case '"':
            if (doubleQuote) {
              read2();
              return newToken("string", buffer);
            }
            buffer += read2();
            return;
          case "'":
            if (!doubleQuote) {
              read2();
              return newToken("string", buffer);
            }
            buffer += read2();
            return;
          case "\n":
          case "\r":
            throw invalidChar(read2());
          case "\u2028":
          case "\u2029":
            separatorChar(c);
            break;
          case void 0:
            throw invalidChar(read2());
        }
        buffer += read2();
      },
      start() {
        switch (c) {
          case "{":
          case "[":
            return newToken("punctuator", read2());
        }
        lexState = "value";
      },
      beforePropertyName() {
        switch (c) {
          case "$":
          case "_":
            buffer = read2();
            lexState = "identifierName";
            return;
          case "\\":
            read2();
            lexState = "identifierNameStartEscape";
            return;
          case "}":
            return newToken("punctuator", read2());
          case '"':
          case "'":
            doubleQuote = read2() === '"';
            lexState = "string";
            return;
        }
        if (util.isIdStartChar(c)) {
          buffer += read2();
          lexState = "identifierName";
          return;
        }
        throw invalidChar(read2());
      },
      afterPropertyName() {
        if (c === ":") {
          return newToken("punctuator", read2());
        }
        throw invalidChar(read2());
      },
      beforePropertyValue() {
        lexState = "value";
      },
      afterPropertyValue() {
        switch (c) {
          case ",":
          case "}":
            return newToken("punctuator", read2());
        }
        throw invalidChar(read2());
      },
      beforeArrayValue() {
        if (c === "]") {
          return newToken("punctuator", read2());
        }
        lexState = "value";
      },
      afterArrayValue() {
        switch (c) {
          case ",":
          case "]":
            return newToken("punctuator", read2());
        }
        throw invalidChar(read2());
      },
      end() {
        throw invalidChar(read2());
      }
    };
    function newToken(type, value) {
      return {
        type,
        value,
        line: line2,
        column
      };
    }
    function literal(s) {
      for (const c2 of s) {
        const p = peek();
        if (p !== c2) {
          throw invalidChar(read2());
        }
        read2();
      }
    }
    function escape() {
      const c2 = peek();
      switch (c2) {
        case "b":
          read2();
          return "\b";
        case "f":
          read2();
          return "\f";
        case "n":
          read2();
          return "\n";
        case "r":
          read2();
          return "\r";
        case "t":
          read2();
          return "	";
        case "v":
          read2();
          return "\v";
        case "0":
          read2();
          if (util.isDigit(peek())) {
            throw invalidChar(read2());
          }
          return "\0";
        case "x":
          read2();
          return hexEscape();
        case "u":
          read2();
          return unicodeEscape();
        case "\n":
        case "\u2028":
        case "\u2029":
          read2();
          return "";
        case "\r":
          read2();
          if (peek() === "\n") {
            read2();
          }
          return "";
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          throw invalidChar(read2());
        case void 0:
          throw invalidChar(read2());
      }
      return read2();
    }
    function hexEscape() {
      let buffer2 = "";
      let c2 = peek();
      if (!util.isHexDigit(c2)) {
        throw invalidChar(read2());
      }
      buffer2 += read2();
      c2 = peek();
      if (!util.isHexDigit(c2)) {
        throw invalidChar(read2());
      }
      buffer2 += read2();
      return String.fromCodePoint(parseInt(buffer2, 16));
    }
    function unicodeEscape() {
      let buffer2 = "";
      let count = 4;
      while (count-- > 0) {
        const c2 = peek();
        if (!util.isHexDigit(c2)) {
          throw invalidChar(read2());
        }
        buffer2 += read2();
      }
      return String.fromCodePoint(parseInt(buffer2, 16));
    }
    var parseStates = {
      start() {
        if (token.type === "eof") {
          throw invalidEOF();
        }
        push();
      },
      beforePropertyName() {
        switch (token.type) {
          case "identifier":
          case "string":
            key = token.value;
            parseState = "afterPropertyName";
            return;
          case "punctuator":
            pop();
            return;
          case "eof":
            throw invalidEOF();
        }
      },
      afterPropertyName() {
        if (token.type === "eof") {
          throw invalidEOF();
        }
        parseState = "beforePropertyValue";
      },
      beforePropertyValue() {
        if (token.type === "eof") {
          throw invalidEOF();
        }
        push();
      },
      beforeArrayValue() {
        if (token.type === "eof") {
          throw invalidEOF();
        }
        if (token.type === "punctuator" && token.value === "]") {
          pop();
          return;
        }
        push();
      },
      afterPropertyValue() {
        if (token.type === "eof") {
          throw invalidEOF();
        }
        switch (token.value) {
          case ",":
            parseState = "beforePropertyName";
            return;
          case "}":
            pop();
        }
      },
      afterArrayValue() {
        if (token.type === "eof") {
          throw invalidEOF();
        }
        switch (token.value) {
          case ",":
            parseState = "beforeArrayValue";
            return;
          case "]":
            pop();
        }
      },
      end() {
      }
    };
    function push() {
      let value;
      switch (token.type) {
        case "punctuator":
          switch (token.value) {
            case "{":
              value = {};
              break;
            case "[":
              value = [];
              break;
          }
          break;
        case "null":
        case "boolean":
        case "numeric":
        case "string":
          value = token.value;
          break;
      }
      if (root === void 0) {
        root = value;
      } else {
        const parent = stack[stack.length - 1];
        if (Array.isArray(parent)) {
          parent.push(value);
        } else {
          Object.defineProperty(parent, key, {
            value,
            writable: true,
            enumerable: true,
            configurable: true
          });
        }
      }
      if (value !== null && typeof value === "object") {
        stack.push(value);
        if (Array.isArray(value)) {
          parseState = "beforeArrayValue";
        } else {
          parseState = "beforePropertyName";
        }
      } else {
        const current = stack[stack.length - 1];
        if (current == null) {
          parseState = "end";
        } else if (Array.isArray(current)) {
          parseState = "afterArrayValue";
        } else {
          parseState = "afterPropertyValue";
        }
      }
    }
    function pop() {
      stack.pop();
      const current = stack[stack.length - 1];
      if (current == null) {
        parseState = "end";
      } else if (Array.isArray(current)) {
        parseState = "afterArrayValue";
      } else {
        parseState = "afterPropertyValue";
      }
    }
    function invalidChar(c2) {
      if (c2 === void 0) {
        return syntaxError(`JSON5: invalid end of input at ${line2}:${column}`);
      }
      return syntaxError(`JSON5: invalid character '${formatChar(c2)}' at ${line2}:${column}`);
    }
    function invalidEOF() {
      return syntaxError(`JSON5: invalid end of input at ${line2}:${column}`);
    }
    function invalidIdentifier() {
      column -= 5;
      return syntaxError(`JSON5: invalid identifier character at ${line2}:${column}`);
    }
    function separatorChar(c2) {
      console.warn(`JSON5: '${formatChar(c2)}' in strings is not valid ECMAScript; consider escaping`);
    }
    function formatChar(c2) {
      const replacements = {
        "'": "\\'",
        '"': '\\"',
        "\\": "\\\\",
        "\b": "\\b",
        "\f": "\\f",
        "\n": "\\n",
        "\r": "\\r",
        "	": "\\t",
        "\v": "\\v",
        "\0": "\\0",
        "\u2028": "\\u2028",
        "\u2029": "\\u2029"
      };
      if (replacements[c2]) {
        return replacements[c2];
      }
      if (c2 < " ") {
        const hexString = c2.charCodeAt(0).toString(16);
        return "\\x" + ("00" + hexString).substring(hexString.length);
      }
      return c2;
    }
    function syntaxError(message) {
      const err = new SyntaxError(message);
      err.lineNumber = line2;
      err.columnNumber = column;
      return err;
    }
  }
});

// node_modules/ignore/index.js
var require_ignore = __commonJS({
  "node_modules/ignore/index.js"(exports, module) {
    function makeArray(subject) {
      return Array.isArray(subject) ? subject : [subject];
    }
    var EMPTY = "";
    var SPACE = " ";
    var ESCAPE = "\\";
    var REGEX_TEST_BLANK_LINE = /^\s+$/;
    var REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\]|^)\\$/;
    var REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
    var REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
    var REGEX_SPLITALL_CRLF = /\r?\n/g;
    var REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/;
    var SLASH = "/";
    var TMP_KEY_IGNORE = "node-ignore";
    if (typeof Symbol !== "undefined") {
      TMP_KEY_IGNORE = Symbol.for("node-ignore");
    }
    var KEY_IGNORE = TMP_KEY_IGNORE;
    var define = (object, key, value) => Object.defineProperty(object, key, { value });
    var REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;
    var RETURN_FALSE = () => false;
    var sanitizeRange = (range) => range.replace(
      REGEX_REGEXP_RANGE,
      (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match : EMPTY
    );
    var cleanRangeBackSlash = (slashes) => {
      const { length } = slashes;
      return slashes.slice(0, length - length % 2);
    };
    var REPLACERS = [
      // > Trailing spaces are ignored unless they are quoted with backslash ("\")
      [
        // (a\ ) -> (a )
        // (a  ) -> (a)
        // (a \ ) -> (a  )
        /\\?\s+$/,
        (match) => match.indexOf("\\") === 0 ? SPACE : EMPTY
      ],
      // replace (\ ) with ' '
      [
        /\\\s/g,
        () => SPACE
      ],
      // Escape metacharacters
      // which is written down by users but means special for regular expressions.
      // > There are 12 characters with special meanings:
      // > - the backslash \,
      // > - the caret ^,
      // > - the dollar sign $,
      // > - the period or dot .,
      // > - the vertical bar or pipe symbol |,
      // > - the question mark ?,
      // > - the asterisk or star *,
      // > - the plus sign +,
      // > - the opening parenthesis (,
      // > - the closing parenthesis ),
      // > - and the opening square bracket [,
      // > - the opening curly brace {,
      // > These special characters are often called "metacharacters".
      [
        /[\\$.|*+(){^]/g,
        (match) => `\\${match}`
      ],
      [
        // > a question mark (?) matches a single character
        /(?!\\)\?/g,
        () => "[^/]"
      ],
      // leading slash
      [
        // > A leading slash matches the beginning of the pathname.
        // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
        // A leading slash matches the beginning of the pathname
        /^\//,
        () => "^"
      ],
      // replace special metacharacter slash after the leading slash
      [
        /\//g,
        () => "\\/"
      ],
      [
        // > A leading "**" followed by a slash means match in all directories.
        // > For example, "**/foo" matches file or directory "foo" anywhere,
        // > the same as pattern "foo".
        // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
        // >   under directory "foo".
        // Notice that the '*'s have been replaced as '\\*'
        /^\^*\\\*\\\*\\\//,
        // '**/foo' <-> 'foo'
        () => "^(?:.*\\/)?"
      ],
      // starting
      [
        // there will be no leading '/'
        //   (which has been replaced by section "leading slash")
        // If starts with '**', adding a '^' to the regular expression also works
        /^(?=[^^])/,
        function startingReplacer() {
          return !/\/(?!$)/.test(this) ? "(?:^|\\/)" : "^";
        }
      ],
      // two globstars
      [
        // Use lookahead assertions so that we could match more than one `'/**'`
        /\\\/\\\*\\\*(?=\\\/|$)/g,
        // Zero, one or several directories
        // should not use '*', or it will be replaced by the next replacer
        // Check if it is not the last `'/**'`
        (_, index, str) => index + 6 < str.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
      ],
      // normal intermediate wildcards
      [
        // Never replace escaped '*'
        // ignore rule '\*' will match the path '*'
        // 'abc.*/' -> go
        // 'abc.*'  -> skip this rule,
        //    coz trailing single wildcard will be handed by [trailing wildcard]
        /(^|[^\\]+)(\\\*)+(?=.+)/g,
        // '*.js' matches '.js'
        // '*.js' doesn't match 'abc'
        (_, p1, p2) => {
          const unescaped = p2.replace(/\\\*/g, "[^\\/]*");
          return p1 + unescaped;
        }
      ],
      [
        // unescape, revert step 3 except for back slash
        // For example, if a user escape a '\\*',
        // after step 3, the result will be '\\\\\\*'
        /\\\\\\(?=[$.|*+(){^])/g,
        () => ESCAPE
      ],
      [
        // '\\\\' -> '\\'
        /\\\\/g,
        () => ESCAPE
      ],
      [
        // > The range notation, e.g. [a-zA-Z],
        // > can be used to match one of the characters in a range.
        // `\` is escaped by step 3
        /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
        (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close}` : close === "]" ? endEscape.length % 2 === 0 ? `[${sanitizeRange(range)}${endEscape}]` : "[]" : "[]"
      ],
      // ending
      [
        // 'js' will not match 'js.'
        // 'ab' will not match 'abc'
        /(?:[^*])$/,
        // WTF!
        // https://git-scm.com/docs/gitignore
        // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
        // which re-fixes #24, #38
        // > If there is a separator at the end of the pattern then the pattern
        // > will only match directories, otherwise the pattern can match both
        // > files and directories.
        // 'js*' will not match 'a.js'
        // 'js/' will not match 'a.js'
        // 'js' will match 'a.js' and 'a.js/'
        (match) => /\/$/.test(match) ? `${match}$` : `${match}(?=$|\\/$)`
      ],
      // trailing wildcard
      [
        /(\^|\\\/)?\\\*$/,
        (_, p1) => {
          const prefix = p1 ? `${p1}[^/]+` : "[^/]*";
          return `${prefix}(?=$|\\/$)`;
        }
      ]
    ];
    var regexCache = /* @__PURE__ */ Object.create(null);
    var makeRegex = (pattern, ignoreCase) => {
      let source = regexCache[pattern];
      if (!source) {
        source = REPLACERS.reduce(
          (prev, current) => prev.replace(current[0], current[1].bind(pattern)),
          pattern
        );
        regexCache[pattern] = source;
      }
      return ignoreCase ? new RegExp(source, "i") : new RegExp(source);
    };
    var isString = (subject) => typeof subject === "string";
    var checkPattern = (pattern) => pattern && isString(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) && !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern) && pattern.indexOf("#") !== 0;
    var splitPattern = (pattern) => pattern.split(REGEX_SPLITALL_CRLF);
    var IgnoreRule = class {
      constructor(origin, pattern, negative, regex) {
        this.origin = origin;
        this.pattern = pattern;
        this.negative = negative;
        this.regex = regex;
      }
    };
    var createRule = (pattern, ignoreCase) => {
      const origin = pattern;
      let negative = false;
      if (pattern.indexOf("!") === 0) {
        negative = true;
        pattern = pattern.substr(1);
      }
      pattern = pattern.replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, "!").replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, "#");
      const regex = makeRegex(pattern, ignoreCase);
      return new IgnoreRule(
        origin,
        pattern,
        negative,
        regex
      );
    };
    var throwError = (message, Ctor) => {
      throw new Ctor(message);
    };
    var checkPath = (path11, originalPath, doThrow) => {
      if (!isString(path11)) {
        return doThrow(
          `path must be a string, but got \`${originalPath}\``,
          TypeError
        );
      }
      if (!path11) {
        return doThrow(`path must not be empty`, TypeError);
      }
      if (checkPath.isNotRelative(path11)) {
        const r = "`path.relative()`d";
        return doThrow(
          `path should be a ${r} string, but got "${originalPath}"`,
          RangeError
        );
      }
      return true;
    };
    var isNotRelative = (path11) => REGEX_TEST_INVALID_PATH.test(path11);
    checkPath.isNotRelative = isNotRelative;
    checkPath.convert = (p) => p;
    var Ignore = class {
      constructor({
        ignorecase = true,
        ignoreCase = ignorecase,
        allowRelativePaths = false
      } = {}) {
        define(this, KEY_IGNORE, true);
        this._rules = [];
        this._ignoreCase = ignoreCase;
        this._allowRelativePaths = allowRelativePaths;
        this._initCache();
      }
      _initCache() {
        this._ignoreCache = /* @__PURE__ */ Object.create(null);
        this._testCache = /* @__PURE__ */ Object.create(null);
      }
      _addPattern(pattern) {
        if (pattern && pattern[KEY_IGNORE]) {
          this._rules = this._rules.concat(pattern._rules);
          this._added = true;
          return;
        }
        if (checkPattern(pattern)) {
          const rule = createRule(pattern, this._ignoreCase);
          this._added = true;
          this._rules.push(rule);
        }
      }
      // @param {Array<string> | string | Ignore} pattern
      add(pattern) {
        this._added = false;
        makeArray(
          isString(pattern) ? splitPattern(pattern) : pattern
        ).forEach(this._addPattern, this);
        if (this._added) {
          this._initCache();
        }
        return this;
      }
      // legacy
      addPattern(pattern) {
        return this.add(pattern);
      }
      //          |           ignored : unignored
      // negative |   0:0   |   0:1   |   1:0   |   1:1
      // -------- | ------- | ------- | ------- | --------
      //     0    |  TEST   |  TEST   |  SKIP   |    X
      //     1    |  TESTIF |  SKIP   |  TEST   |    X
      // - SKIP: always skip
      // - TEST: always test
      // - TESTIF: only test if checkUnignored
      // - X: that never happen
      // @param {boolean} whether should check if the path is unignored,
      //   setting `checkUnignored` to `false` could reduce additional
      //   path matching.
      // @returns {TestResult} true if a file is ignored
      _testOne(path11, checkUnignored) {
        let ignored = false;
        let unignored = false;
        this._rules.forEach((rule) => {
          const { negative } = rule;
          if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {
            return;
          }
          const matched = rule.regex.test(path11);
          if (matched) {
            ignored = !negative;
            unignored = negative;
          }
        });
        return {
          ignored,
          unignored
        };
      }
      // @returns {TestResult}
      _test(originalPath, cache, checkUnignored, slices) {
        const path11 = originalPath && checkPath.convert(originalPath);
        checkPath(
          path11,
          originalPath,
          this._allowRelativePaths ? RETURN_FALSE : throwError
        );
        return this._t(path11, cache, checkUnignored, slices);
      }
      _t(path11, cache, checkUnignored, slices) {
        if (path11 in cache) {
          return cache[path11];
        }
        if (!slices) {
          slices = path11.split(SLASH);
        }
        slices.pop();
        if (!slices.length) {
          return cache[path11] = this._testOne(path11, checkUnignored);
        }
        const parent = this._t(
          slices.join(SLASH) + SLASH,
          cache,
          checkUnignored,
          slices
        );
        return cache[path11] = parent.ignored ? parent : this._testOne(path11, checkUnignored);
      }
      ignores(path11) {
        return this._test(path11, this._ignoreCache, false).ignored;
      }
      createFilter() {
        return (path11) => !this.ignores(path11);
      }
      filter(paths) {
        return makeArray(paths).filter(this.createFilter());
      }
      // @returns {TestResult}
      test(path11) {
        return this._test(path11, this._testCache, true);
      }
    };
    var factory = (options9) => new Ignore(options9);
    var isPathValid = (path11) => checkPath(path11 && checkPath.convert(path11), path11, RETURN_FALSE);
    factory.isPathValid = isPathValid;
    factory.default = factory;
    module.exports = factory;
    if (
      // Detect `process` so that it can run in browsers.
      typeof process !== "undefined" && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === "win32")
    ) {
      const makePosix = (str) => /^\\\\\?\\/.test(str) || /["<>|\u0000-\u001F]+/u.test(str) ? str : str.replace(/\\/g, "/");
      checkPath.convert = makePosix;
      const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
      checkPath.isNotRelative = (path11) => REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path11) || isNotRelative(path11);
    }
  }
});

// node_modules/string-width/node_modules/emoji-regex/index.js
var require_emoji_regex = __commonJS({
  "node_modules/string-width/node_modules/emoji-regex/index.js"(exports, module) {
    "use strict";
    module.exports = function() {
      return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
    };
  }
});

// node_modules/jest-docblock/build/index.js
var require_build = __commonJS({
  "node_modules/jest-docblock/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.extract = extract2;
    exports.parse = parse4;
    exports.parseWithComments = parseWithComments2;
    exports.print = print4;
    exports.strip = strip2;
    var commentEndRe = /\*\/$/;
    var commentStartRe = /^\/\*\*?/;
    var docblockRe = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/;
    var lineCommentRe = /(^|\s+)\/\/([^\r\n]*)/g;
    var ltrimNewlineRe = /^(\r?\n)+/;
    var multilineRe = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g;
    var propertyRe = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g;
    var stringStartRe = /(\r?\n|^) *\* ?/g;
    var STRING_ARRAY = [];
    function extract2(contents) {
      const match = contents.match(docblockRe);
      return match ? match[0].trimLeft() : "";
    }
    function strip2(contents) {
      const match = contents.match(docblockRe);
      return match && match[0] ? contents.substring(match[0].length) : contents;
    }
    function parse4(docblock) {
      return parseWithComments2(docblock).pragmas;
    }
    function parseWithComments2(docblock) {
      const line2 = "\n";
      docblock = docblock.replace(commentStartRe, "").replace(commentEndRe, "").replace(stringStartRe, "$1");
      let prev = "";
      while (prev !== docblock) {
        prev = docblock;
        docblock = docblock.replace(multilineRe, `${line2}$1 $2${line2}`);
      }
      docblock = docblock.replace(ltrimNewlineRe, "").trimRight();
      const result = /* @__PURE__ */ Object.create(null);
      const comments = docblock.replace(propertyRe, "").replace(ltrimNewlineRe, "").trimRight();
      let match;
      while (match = propertyRe.exec(docblock)) {
        const nextPragma = match[2].replace(lineCommentRe, "");
        if (typeof result[match[1]] === "string" || Array.isArray(result[match[1]])) {
          result[match[1]] = STRING_ARRAY.concat(result[match[1]], nextPragma);
        } else {
          result[match[1]] = nextPragma;
        }
      }
      return {
        comments,
        pragmas: result
      };
    }
    function print4({ comments = "", pragmas: pragmas2 = {} }) {
      const line2 = "\n";
      const head = "/**";
      const start = " *";
      const tail = " */";
      const keys = Object.keys(pragmas2);
      const printedObject = keys.map((key) => printKeyValues(key, pragmas2[key])).reduce((arr, next) => arr.concat(next), []).map((keyValue) => `${start} ${keyValue}${line2}`).join("");
      if (!comments) {
        if (keys.length === 0) {
          return "";
        }
        if (keys.length === 1 && !Array.isArray(pragmas2[keys[0]])) {
          const value = pragmas2[keys[0]];
          return `${head} ${printKeyValues(keys[0], value)[0]}${tail}`;
        }
      }
      const printedComments = comments.split(line2).map((textLine) => `${start} ${textLine}`).join(line2) + line2;
      return head + line2 + (comments ? printedComments : "") + (comments && keys.length ? start + line2 : "") + printedObject + tail;
    }
    function printKeyValues(key, valueOrArray) {
      return STRING_ARRAY.concat(valueOrArray).map(
        (value) => `@${key} ${value}`.trim()
      );
    }
  }
});

// node_modules/collapse-white-space/index.js
var require_collapse_white_space = __commonJS({
  "node_modules/collapse-white-space/index.js"(exports, module) {
    "use strict";
    module.exports = collapse;
    function collapse(value) {
      return String(value).replace(/\s+/g, " ");
    }
  }
});

// src/index.js
var import_vnopts2 = __toESM(require_lib(), 1);
var import_fast_glob2 = __toESM(require_out4(), 1);

// scripts/build/shims/string-replace-all.js
var stringReplaceAll = (isOptionalObject, original, pattern, replacement) => {
  if (isOptionalObject && (original === void 0 || original === null)) {
    return;
  }
  if (original.replaceAll) {
    return original.replaceAll(pattern, replacement);
  }
  if (pattern.global) {
    return original.replace(pattern, replacement);
  }
  return original.split(pattern).join(replacement);
};
var string_replace_all_default = stringReplaceAll;

// src/main/core.js
var import_diff = __toESM(require_array3(), 1);

// src/document/printer.js
import { printer } from "./doc.mjs";
var {
  printDocToString
} = printer;

// src/document/debug.js
import { debug } from "./doc.mjs";
var {
  printDocToDebug
} = debug;

// src/utils/get-alignment-size.js
function getAlignmentSize(text, tabWidth, startIndex = 0) {
  let size = 0;
  for (let i = startIndex; i < text.length; ++i) {
    if (text[i] === "	") {
      size = size + tabWidth - size % tabWidth;
    } else {
      size++;
    }
  }
  return size;
}
var get_alignment_size_default = getAlignmentSize;

// src/common/end-of-line.js
function guessEndOfLine(text) {
  const index = text.indexOf("\r");
  if (index >= 0) {
    return text.charAt(index + 1) === "\n" ? "crlf" : "cr";
  }
  return "lf";
}
function convertEndOfLineToChars(value) {
  switch (value) {
    case "cr":
      return "\r";
    case "crlf":
      return "\r\n";
    default:
      return "\n";
  }
}
function countEndOfLineChars(text, eol) {
  let regex;
  switch (eol) {
    case "\n":
      regex = /\n/g;
      break;
    case "\r":
      regex = /\r/g;
      break;
    case "\r\n":
      regex = /\r\n/g;
      break;
    default:
      throw new Error(`Unexpected "eol" ${JSON.stringify(eol)}.`);
  }
  const endOfLines = text.match(regex);
  return endOfLines ? endOfLines.length : 0;
}
function normalizeEndOfLine(text) {
  return string_replace_all_default(
    /* isOptionalObject*/
    false,
    text,
    /\r\n?/g,
    "\n"
  );
}

// src/common/errors.js
var errors_exports = {};
__export(errors_exports, {
  ArgExpansionBailout: () => ArgExpansionBailout,
  ConfigError: () => ConfigError,
  DebugError: () => DebugError,
  UndefinedParserError: () => UndefinedParserError
});
var ConfigError = class extends Error {
};
var DebugError = class extends Error {
};
var UndefinedParserError = class extends Error {
};
var ArgExpansionBailout = class extends Error {
};

// scripts/build/shims/at.js
var at = (isOptionalObject, object, index) => {
  if (isOptionalObject && (object === void 0 || object === null)) {
    return;
  }
  return object.at ? object.at(index) : object[index < 0 ? object.length + index : index];
};
var at_default = at;

// src/utils/arrayify.js
var arrayify = (object, keyName) => Object.entries(object).map(([key, value]) => ({
  [keyName]: key,
  ...value
}));
var arrayify_default = arrayify;

// src/main/core-options.evaluate.js
var core_options_evaluate_exports = {};
__export(core_options_evaluate_exports, {
  CATEGORY_CONFIG: () => CATEGORY_CONFIG,
  CATEGORY_EDITOR: () => CATEGORY_EDITOR,
  CATEGORY_FORMAT: () => CATEGORY_FORMAT,
  CATEGORY_GLOBAL: () => CATEGORY_GLOBAL,
  CATEGORY_OTHER: () => CATEGORY_OTHER,
  CATEGORY_OUTPUT: () => CATEGORY_OUTPUT,
  CATEGORY_SPECIAL: () => CATEGORY_SPECIAL,
  options: () => options
});
var CATEGORY_CONFIG = "Config";
var CATEGORY_EDITOR = "Editor";
var CATEGORY_FORMAT = "Format";
var CATEGORY_GLOBAL = "Global";
var CATEGORY_OTHER = "Other";
var CATEGORY_OUTPUT = "Output";
var CATEGORY_SPECIAL = "Special";
var options = {
  "cursorOffset": {
    "category": "Special",
    "type": "int",
    "default": -1,
    "range": {
      "start": -1,
      "end": Infinity,
      "step": 1
    },
    "description": "Print (to stderr) where a cursor at the given position would move to after formatting.\nThis option cannot be used with --range-start and --range-end.",
    "cliCategory": "Editor"
  },
  "endOfLine": {
    "category": "Global",
    "type": "choice",
    "default": "lf",
    "description": "Which end of line characters to apply.",
    "choices": [
      {
        "value": "lf",
        "description": "Line Feed only (\\n), common on Linux and macOS as well as inside git repos"
      },
      {
        "value": "crlf",
        "description": "Carriage Return + Line Feed characters (\\r\\n), common on Windows"
      },
      {
        "value": "cr",
        "description": "Carriage Return character only (\\r), used very rarely"
      },
      {
        "value": "auto",
        "description": "Maintain existing\n(mixed values within one file are normalised by looking at what's used after the first line)"
      }
    ]
  },
  "filepath": {
    "category": "Special",
    "type": "path",
    "description": "Specify the input filepath. This will be used to do parser inference.",
    "cliName": "stdin-filepath",
    "cliCategory": "Other",
    "cliDescription": "Path to the file to pretend that stdin comes from."
  },
  "insertPragma": {
    "category": "Special",
    "type": "boolean",
    "default": false,
    "description": "Insert @format pragma into file's first docblock comment.",
    "cliCategory": "Other"
  },
  "parser": {
    "category": "Global",
    "type": "choice",
    "default": void 0,
    "description": "Which parser to use.",
    "exception": (value) => typeof value === "string" || typeof value === "function",
    "choices": [
      {
        "value": "flow",
        "description": "Flow"
      },
      {
        "value": "babel",
        "description": "JavaScript"
      },
      {
        "value": "babel-flow",
        "description": "Flow"
      },
      {
        "value": "babel-ts",
        "description": "TypeScript"
      },
      {
        "value": "typescript",
        "description": "TypeScript"
      },
      {
        "value": "acorn",
        "description": "JavaScript"
      },
      {
        "value": "espree",
        "description": "JavaScript"
      },
      {
        "value": "meriyah",
        "description": "JavaScript"
      },
      {
        "value": "css",
        "description": "CSS"
      },
      {
        "value": "less",
        "description": "Less"
      },
      {
        "value": "scss",
        "description": "SCSS"
      },
      {
        "value": "json",
        "description": "JSON"
      },
      {
        "value": "json5",
        "description": "JSON5"
      },
      {
        "value": "json-stringify",
        "description": "JSON.stringify"
      },
      {
        "value": "graphql",
        "description": "GraphQL"
      },
      {
        "value": "markdown",
        "description": "Markdown"
      },
      {
        "value": "mdx",
        "description": "MDX"
      },
      {
        "value": "vue",
        "description": "Vue"
      },
      {
        "value": "yaml",
        "description": "YAML"
      },
      {
        "value": "glimmer",
        "description": "Ember / Handlebars"
      },
      {
        "value": "html",
        "description": "HTML"
      },
      {
        "value": "angular",
        "description": "Angular"
      },
      {
        "value": "lwc",
        "description": "Lightning Web Components"
      }
    ]
  },
  "plugins": {
    "type": "path",
    "array": true,
    "default": [
      {
        "value": []
      }
    ],
    "category": "Global",
    "description": "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.",
    "exception": (value) => typeof value === "string" || typeof value === "object",
    "cliName": "plugin",
    "cliCategory": "Config"
  },
  "pluginSearchDirs": {
    "type": "path",
    "array": true,
    "default": [
      {
        "value": []
      }
    ],
    "category": "Global",
    "description": "Custom directory that contains prettier plugins in node_modules subdirectory.\nOverrides default behavior when plugins are searched relatively to the location of Prettier.\nMultiple values are accepted.",
    "exception": (value) => typeof value === "string" || typeof value === "object",
    "cliName": "plugin-search-dir",
    "cliCategory": "Config"
  },
  "printWidth": {
    "category": "Global",
    "type": "int",
    "default": 80,
    "description": "The line length where Prettier will try wrap.",
    "range": {
      "start": 0,
      "end": Infinity,
      "step": 1
    }
  },
  "rangeEnd": {
    "category": "Special",
    "type": "int",
    "default": Infinity,
    "range": {
      "start": 0,
      "end": Infinity,
      "step": 1
    },
    "description": "Format code ending at a given character offset (exclusive).\nThe range will extend forwards to the end of the selected statement.\nThis option cannot be used with --cursor-offset.",
    "cliCategory": "Editor"
  },
  "rangeStart": {
    "category": "Special",
    "type": "int",
    "default": 0,
    "range": {
      "start": 0,
      "end": Infinity,
      "step": 1
    },
    "description": "Format code starting at a given character offset.\nThe range will extend backwards to the start of the first line containing the selected statement.\nThis option cannot be used with --cursor-offset.",
    "cliCategory": "Editor"
  },
  "requirePragma": {
    "category": "Special",
    "type": "boolean",
    "default": false,
    "description": "Require either '@prettier' or '@format' to be present in the file's first docblock comment\nin order for it to be formatted.",
    "cliCategory": "Other"
  },
  "tabWidth": {
    "type": "int",
    "category": "Global",
    "default": 2,
    "description": "Number of spaces per indentation level.",
    "range": {
      "start": 0,
      "end": Infinity,
      "step": 1
    }
  },
  "useTabs": {
    "category": "Global",
    "type": "boolean",
    "default": false,
    "description": "Indent with tabs instead of spaces."
  },
  "embeddedLanguageFormatting": {
    "category": "Global",
    "type": "choice",
    "default": "auto",
    "description": "Control how Prettier formats quoted code embedded in the file.",
    "choices": [
      {
        "value": "auto",
        "description": "Format embedded code if Prettier can automatically identify it."
      },
      {
        "value": "off",
        "description": "Never automatically format embedded code."
      }
    ]
  }
};

// src/main/support.js
function getSupportInfo({
  plugins = [],
  showDeprecated = false,
  showInternal = false
} = {}) {
  const languages = plugins.flatMap((plugin) => plugin.languages || []);
  const options9 = arrayify_default(Object.assign({}, ...plugins.map(({
    options: options10
  }) => options10), options), "name").filter((option) => filterDeprecated(option)).sort((a, b) => a.name === b.name ? 0 : a.name < b.name ? -1 : 1).map(mapInternal).map((option) => {
    option = {
      ...option
    };
    if (Array.isArray(option.default)) {
      option.default = at_default(
        /* isOptionalObject*/
        false,
        option.default,
        -1
      ).value;
    }
    if (Array.isArray(option.choices)) {
      option.choices = option.choices.filter((option2) => filterDeprecated(option2));
      if (option.name === "parser") {
        collectParsersFromLanguages(option, languages, plugins);
      }
    }
    const pluginDefaults = Object.fromEntries(plugins.filter((plugin) => {
      var _a;
      return ((_a = plugin.defaultOptions) == null ? void 0 : _a[option.name]) !== void 0;
    }).map((plugin) => [plugin.name, plugin.defaultOptions[option.name]]));
    return {
      ...option,
      pluginDefaults
    };
  });
  return {
    languages,
    options: options9
  };
  function filterDeprecated(object) {
    return showDeprecated || !object.deprecated;
  }
  function mapInternal(object) {
    if (showInternal) {
      return object;
    }
    const {
      cliName,
      cliCategory,
      cliDescription,
      ...newObject
    } = object;
    return newObject;
  }
}
function collectParsersFromLanguages(option, languages, plugins) {
  const existingValues = new Set(option.choices.map((choice) => choice.value));
  for (const language of languages) {
    if (language.parsers) {
      for (const value of language.parsers) {
        if (!existingValues.has(value)) {
          existingValues.add(value);
          const plugin = plugins.find((plugin2) => {
            var _a;
            return (_a = plugin2.parsers) == null ? void 0 : _a[value];
          });
          let description = language.name;
          if (plugin == null ? void 0 : plugin.name) {
            description += ` (plugin: ${plugin.name})`;
          }
          option.choices.push({
            value,
            description
          });
        }
      }
    }
  }
}

// src/main/normalize-options.js
var import_vnopts = __toESM(require_lib(), 1);
var hasDeprecationWarned;
function normalizeOptions(options9, optionInfos, {
  logger = false,
  isCLI = false,
  passThrough = false,
  FlagSchema,
  descriptor
} = {}) {
  if (isCLI) {
    if (!FlagSchema) {
      throw new Error("'FlagSchema' option is required.");
    }
    if (!descriptor) {
      throw new Error("'descriptor' option is required.");
    }
  } else {
    descriptor = import_vnopts.default.apiDescriptor;
  }
  const unknown = !passThrough ? (key, value, options10) => {
    const {
      _,
      ...schemas2
    } = options10.schemas;
    return import_vnopts.default.levenUnknownHandler(key, value, {
      ...options10,
      schemas: schemas2
    });
  } : Array.isArray(passThrough) ? (key, value) => !passThrough.includes(key) ? void 0 : {
    [key]: value
  } : (key, value) => ({
    [key]: value
  });
  const schemas = optionInfosToSchemas(optionInfos, {
    isCLI,
    FlagSchema
  });
  const normalizer = new import_vnopts.default.Normalizer(schemas, {
    logger,
    unknown,
    descriptor
  });
  const shouldSuppressDuplicateDeprecationWarnings = logger !== false;
  if (shouldSuppressDuplicateDeprecationWarnings && hasDeprecationWarned) {
    normalizer._hasDeprecationWarned = hasDeprecationWarned;
  }
  const normalized = normalizer.normalize(options9);
  if (shouldSuppressDuplicateDeprecationWarnings) {
    hasDeprecationWarned = normalizer._hasDeprecationWarned;
  }
  if (isCLI && normalized["plugin-search"] === false) {
    normalized["plugin-search-dir"] = false;
  }
  return normalized;
}
function optionInfosToSchemas(optionInfos, {
  isCLI,
  FlagSchema
}) {
  const schemas = [];
  if (isCLI) {
    schemas.push(import_vnopts.default.AnySchema.create({
      name: "_"
    }));
  }
  for (const optionInfo of optionInfos) {
    schemas.push(optionInfoToSchema(optionInfo, {
      isCLI,
      optionInfos,
      FlagSchema
    }));
    if (optionInfo.alias && isCLI) {
      schemas.push(import_vnopts.default.AliasSchema.create({
        // @ts-expect-error
        name: optionInfo.alias,
        sourceName: optionInfo.name
      }));
    }
  }
  return schemas;
}
function optionInfoToSchema(optionInfo, {
  isCLI,
  optionInfos,
  FlagSchema
}) {
  const {
    name
  } = optionInfo;
  if (name === "plugin-search-dir" || name === "pluginSearchDirs") {
    return import_vnopts.default.AnySchema.create({
      // @ts-expect-error
      name,
      preprocess(value) {
        if (value === false) {
          return value;
        }
        value = Array.isArray(value) ? value : [value];
        return value;
      },
      /**
       * @param {Array<unknown> | false} value
       */
      validate(value) {
        if (value === false) {
          return true;
        }
        return value.every((dir) => typeof dir === "string");
      },
      expected() {
        return "false or paths to plugin search dir";
      }
    });
  }
  const parameters = {
    name
  };
  let SchemaConstructor;
  const handlers = {};
  switch (optionInfo.type) {
    case "int":
      SchemaConstructor = import_vnopts.default.IntegerSchema;
      if (isCLI) {
        parameters.preprocess = Number;
      }
      break;
    case "string":
      SchemaConstructor = import_vnopts.default.StringSchema;
      break;
    case "choice":
      SchemaConstructor = import_vnopts.default.ChoiceSchema;
      parameters.choices = optionInfo.choices.map((choiceInfo) => (choiceInfo == null ? void 0 : choiceInfo.redirect) ? {
        ...choiceInfo,
        redirect: {
          to: {
            key: optionInfo.name,
            value: choiceInfo.redirect
          }
        }
      } : choiceInfo);
      break;
    case "boolean":
      SchemaConstructor = import_vnopts.default.BooleanSchema;
      break;
    case "flag":
      SchemaConstructor = FlagSchema;
      parameters.flags = optionInfos.flatMap((optionInfo2) => [optionInfo2.alias, optionInfo2.description && optionInfo2.name, optionInfo2.oppositeDescription && `no-${optionInfo2.name}`].filter(Boolean));
      break;
    case "path":
      SchemaConstructor = import_vnopts.default.StringSchema;
      break;
    default:
      throw new Error(`Unexpected type ${optionInfo.type}`);
  }
  if (optionInfo.exception) {
    parameters.validate = (value, schema, utils2) => optionInfo.exception(value) || schema.validate(value, utils2);
  } else {
    parameters.validate = (value, schema, utils2) => value === void 0 || schema.validate(value, utils2);
  }
  if (optionInfo.redirect) {
    handlers.redirect = (value) => !value ? void 0 : {
      to: {
        key: optionInfo.redirect.option,
        value: optionInfo.redirect.value
      }
    };
  }
  if (optionInfo.deprecated) {
    handlers.deprecated = true;
  }
  if (isCLI && !optionInfo.array) {
    const originalPreprocess = parameters.preprocess || ((x) => x);
    parameters.preprocess = (value, schema, utils2) => schema.preprocess(originalPreprocess(Array.isArray(value) ? at_default(
      /* isOptionalObject*/
      false,
      value,
      -1
    ) : value), utils2);
  }
  return optionInfo.array ? import_vnopts.default.ArraySchema.create({
    ...isCLI ? {
      preprocess: (v) => Array.isArray(v) ? v : [v]
    } : {},
    ...handlers,
    // @ts-expect-error
    valueSchema: SchemaConstructor.create(parameters)
  }) : SchemaConstructor.create({
    ...parameters,
    ...handlers
  });
}
var normalize_options_default = normalizeOptions;

// src/main/parser.js
var import_code_frame = __toESM(require_lib4(), 1);
function resolveParser({
  plugins,
  parser
}) {
  for (let index = plugins.length - 1; index >= 0; index--) {
    const {
      parsers: parsers15
    } = plugins[index];
    if (parsers15 && Object.prototype.hasOwnProperty.call(parsers15, parser)) {
      const parserOrParserInitFunction = parsers15[parser];
      return typeof parserOrParserInitFunction === "function" ? parserOrParserInitFunction() : parserOrParserInitFunction;
    }
  }
  if (false) {
    throw new ConfigError(`Couldn't resolve parser "${parser}". Parsers must be explicitly added to the standalone bundle.`);
  }
}
async function parse(originalText, options9) {
  const parser = await resolveParser(options9);
  const text = parser.preprocess ? parser.preprocess(originalText, options9) : originalText;
  let ast;
  try {
    ast = await parser.parse(
      text,
      options9,
      // TODO: remove the third argument in v4
      // The duplicated argument is passed as intended, see #10156
      options9
    );
  } catch (error) {
    handleParseError(error, originalText);
  }
  return {
    text,
    ast
  };
}
function handleParseError(error, text) {
  const {
    loc
  } = error;
  if (loc) {
    const codeFrame = (0, import_code_frame.codeFrameColumns)(text, loc, {
      highlightCode: true
    });
    error.message += "\n" + codeFrame;
    error.codeFrame = codeFrame;
    throw error;
  }
  throw error;
}

// src/main/infer-parser.js
import path from "path";

// src/utils/get-interpreter.js
var import_n_readlines = __toESM(require_readlines(), 1);
import fs from "fs";
function getInterpreter(filepath) {
  if (typeof filepath !== "string") {
    return "";
  }
  let fd;
  try {
    fd = fs.openSync(filepath, "r");
  } catch {
    return "";
  }
  try {
    const liner = new import_n_readlines.default(fd);
    const firstLine = liner.next().toString("utf8");
    const m1 = firstLine.match(/^#!\/(?:usr\/)?bin\/env\s+(\S+)/);
    if (m1) {
      return m1[1];
    }
    const m2 = firstLine.match(/^#!\/(?:usr\/(?:local\/)?)?bin\/(\S+)/);
    if (m2) {
      return m2[1];
    }
    return "";
  } catch {
    return "";
  } finally {
    try {
      fs.closeSync(fd);
    } catch {
    }
  }
}
var get_interpreter_default = getInterpreter;

// src/main/infer-parser.js
function inferParser(filepath, plugins) {
  const filename = path.basename(filepath).toLowerCase();
  const { languages } = getSupportInfo({ plugins });
  let language = languages.find(
    (language2) => {
      var _a, _b;
      return ((_a = language2.extensions) == null ? void 0 : _a.some((extension) => filename.endsWith(extension))) || ((_b = language2.filenames) == null ? void 0 : _b.some((name) => name.toLowerCase() === filename));
    }
  );
  if (!language && !filename.includes(".")) {
    const interpreter = get_interpreter_default(filepath);
    if (interpreter) {
      language = languages.find(
        (language2) => {
          var _a;
          return (_a = language2.interpreters) == null ? void 0 : _a.includes(interpreter);
        }
      );
    }
  }
  return language == null ? void 0 : language.parsers[0];
}
var infer_parser_default = inferParser;

// src/main/normalize-format-options.js
var formatOptionsHiddenDefaults = {
  astFormat: "estree",
  printer: {},
  originalText: void 0,
  locStart: null,
  locEnd: null
};
async function normalizeFormatOptions(options9, opts = {}) {
  const rawOptions = { ...options9 };
  const supportOptions = getSupportInfo({
    plugins: options9.plugins,
    showDeprecated: true
  }).options;
  const defaults = {
    ...formatOptionsHiddenDefaults,
    ...Object.fromEntries(
      supportOptions.filter((optionInfo) => optionInfo.default !== void 0).map((option) => [option.name, option.default])
    )
  };
  if (!rawOptions.parser) {
    if (!rawOptions.filepath) {
      const logger = opts.logger || console;
      logger.warn(
        "No parser and no filepath given, using 'babel' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred."
      );
      rawOptions.parser = "babel";
    } else {
      rawOptions.parser = infer_parser_default(rawOptions.filepath, rawOptions.plugins);
      if (!rawOptions.parser) {
        throw new UndefinedParserError(
          `No parser could be inferred for file: ${rawOptions.filepath}`
        );
      }
    }
  }
  const parser = await resolveParser(
    // @ts-expect-error
    normalize_options_default(
      rawOptions,
      [supportOptions.find((x) => x.name === "parser")],
      { passThrough: true, logger: false }
    )
  );
  rawOptions.astFormat = parser.astFormat;
  rawOptions.locEnd = parser.locEnd;
  rawOptions.locStart = parser.locStart;
  const plugin = getPlugin(rawOptions);
  rawOptions.printer = plugin.printers[rawOptions.astFormat];
  const pluginDefaults = Object.fromEntries(
    supportOptions.filter(
      (optionInfo) => {
        var _a;
        return ((_a = optionInfo.pluginDefaults) == null ? void 0 : _a[plugin.name]) !== void 0;
      }
    ).map((optionInfo) => [
      optionInfo.name,
      optionInfo.pluginDefaults[plugin.name]
    ])
  );
  const mixedDefaults = { ...defaults, ...pluginDefaults };
  for (const [k, value] of Object.entries(mixedDefaults)) {
    if (rawOptions[k] === null || rawOptions[k] === void 0) {
      rawOptions[k] = value;
    }
  }
  if (rawOptions.parser === "json") {
    rawOptions.trailingComma = "none";
  }
  return normalize_options_default(rawOptions, supportOptions, {
    passThrough: Object.keys(formatOptionsHiddenDefaults),
    ...opts
  });
}
function getPlugin(options9) {
  const { astFormat } = options9;
  if (!astFormat) {
    throw new Error("getPlugin() requires astFormat to be set");
  }
  const printerPlugin = options9.plugins.find(
    (plugin) => {
      var _a;
      return (_a = plugin.printers) == null ? void 0 : _a[astFormat];
    }
  );
  if (!printerPlugin) {
    throw new Error(`Couldn't find plugin for AST format "${astFormat}"`);
  }
  return printerPlugin;
}
var normalize_format_options_default = normalizeFormatOptions;

// src/main/create-get-visitor-keys-function.js
var nonTraversableKeys = /* @__PURE__ */ new Set([
  "tokens",
  "comments",
  "parent",
  "enclosingNode",
  "precedingNode",
  "followingNode"
]);
var defaultGetVisitorKeys = (node) => Object.keys(node).filter((key) => !nonTraversableKeys.has(key));
function createGetVisitorKeysFunction(printerGetVisitorKeys) {
  return printerGetVisitorKeys ? (node) => printerGetVisitorKeys(node, nonTraversableKeys) : defaultGetVisitorKeys;
}
var create_get_visitor_keys_function_default = createGetVisitorKeysFunction;

// src/main/massage-ast.js
function massageAst(ast, options9) {
  const {
    printer: {
      massageAstNode: cleanFunction,
      getVisitorKeys: printerGetVisitorKeys
    }
  } = options9;
  if (!cleanFunction) {
    return ast;
  }
  const getVisitorKeys9 = create_get_visitor_keys_function_default(printerGetVisitorKeys);
  const ignoredProperties6 = cleanFunction.ignoredProperties ?? /* @__PURE__ */ new Set();
  return recurse(ast);
  function recurse(node, parent) {
    if (!(node !== null && typeof node === "object")) {
      return node;
    }
    if (Array.isArray(node)) {
      return node.map((child) => recurse(child, parent)).filter(Boolean);
    }
    const newObj = {};
    const childrenKeys = new Set(getVisitorKeys9(node));
    for (const key in node) {
      if (!Object.prototype.hasOwnProperty.call(node, key) || ignoredProperties6.has(key)) {
        continue;
      }
      if (childrenKeys.has(key)) {
        newObj[key] = recurse(node[key], node);
      } else {
        newObj[key] = node[key];
      }
    }
    const result = cleanFunction(node, newObj, parent);
    if (result === null) {
      return;
    }
    return result ?? newObj;
  }
}
var massage_ast_default = massageAst;

// src/main/comments/attach.js
import assert from "assert";

// src/utils/skip.js
function skip(characters) {
  return (text, startIndex, options9) => {
    const backwards = Boolean(options9 == null ? void 0 : options9.backwards);
    if (startIndex === false) {
      return false;
    }
    const { length } = text;
    let cursor2 = startIndex;
    while (cursor2 >= 0 && cursor2 < length) {
      const character = text.charAt(cursor2);
      if (characters instanceof RegExp) {
        if (!characters.test(character)) {
          return cursor2;
        }
      } else if (!characters.includes(character)) {
        return cursor2;
      }
      backwards ? cursor2-- : cursor2++;
    }
    if (cursor2 === -1 || cursor2 === length) {
      return cursor2;
    }
    return false;
  };
}
var skipWhitespace = skip(/\s/);
var skipSpaces = skip(" 	");
var skipToLineEnd = skip(",; 	");
var skipEverythingButNewLine = skip(/[^\n\r]/);

// src/utils/skip-newline.js
function skipNewline(text, startIndex, options9) {
  const backwards = Boolean(options9 == null ? void 0 : options9.backwards);
  if (startIndex === false) {
    return false;
  }
  const character = text.charAt(startIndex);
  if (backwards) {
    if (text.charAt(startIndex - 1) === "\r" && character === "\n") {
      return startIndex - 2;
    }
    if (character === "\n" || character === "\r" || character === "\u2028" || character === "\u2029") {
      return startIndex - 1;
    }
  } else {
    if (character === "\r" && text.charAt(startIndex + 1) === "\n") {
      return startIndex + 2;
    }
    if (character === "\n" || character === "\r" || character === "\u2028" || character === "\u2029") {
      return startIndex + 1;
    }
  }
  return startIndex;
}
var skip_newline_default = skipNewline;

// src/utils/has-newline.js
function hasNewline(text, startIndex, options9 = {}) {
  const idx = skipSpaces(
    text,
    options9.backwards ? startIndex - 1 : startIndex,
    options9
  );
  const idx2 = skip_newline_default(text, idx, options9);
  return idx !== idx2;
}
var has_newline_default = hasNewline;

// src/utils/is-non-empty-array.js
function isNonEmptyArray(object) {
  return Array.isArray(object) && object.length > 0;
}
var is_non_empty_array_default = isNonEmptyArray;

// src/main/comments/utils.js
function describeNodeForDebugging(node) {
  const nodeType = node.type || node.kind || "(unknown type)";
  let nodeName = String(
    node.name || node.id && (typeof node.id === "object" ? node.id.name : node.id) || node.key && (typeof node.key === "object" ? node.key.name : node.key) || node.value && (typeof node.value === "object" ? "" : String(node.value)) || node.operator || ""
  );
  if (nodeName.length > 20) {
    nodeName = nodeName.slice(0, 19) + "\u2026";
  }
  return nodeType + (nodeName ? " " + nodeName : "");
}
function addCommentHelper(node, comment) {
  const comments = node.comments ?? (node.comments = []);
  comments.push(comment);
  comment.printed = false;
  comment.nodeDescription = describeNodeForDebugging(node);
}
function addLeadingComment(node, comment) {
  comment.leading = true;
  comment.trailing = false;
  addCommentHelper(node, comment);
}
function addDanglingComment(node, comment, marker) {
  comment.leading = false;
  comment.trailing = false;
  if (marker) {
    comment.marker = marker;
  }
  addCommentHelper(node, comment);
}
function addTrailingComment(node, comment) {
  comment.leading = false;
  comment.trailing = true;
  addCommentHelper(node, comment);
}

// src/main/comments/attach.js
var childNodesCache = /* @__PURE__ */ new WeakMap();
function getSortedChildNodes(node, options9) {
  if (childNodesCache.has(node)) {
    return childNodesCache.get(node);
  }
  const {
    printer: {
      getCommentChildNodes: getCommentChildNodes2,
      canAttachComment: canAttachComment3,
      getVisitorKeys: printerGetVisitorKeys
    },
    locStart: locStart8,
    locEnd: locEnd7
  } = options9;
  if (!canAttachComment3) {
    return [];
  }
  const childNodes = ((getCommentChildNodes2 == null ? void 0 : getCommentChildNodes2(node, options9)) ?? create_get_visitor_keys_function_default(printerGetVisitorKeys)(node).flatMap(
    (key) => node[key]
  )).flatMap((childNode) => {
    if (!(childNode !== null && typeof childNode === "object")) {
      return [];
    }
    return canAttachComment3(childNode) ? childNode : getSortedChildNodes(childNode, options9);
  });
  childNodes.sort(
    (nodeA, nodeB) => locStart8(nodeA) - locStart8(nodeB) || locEnd7(nodeA) - locEnd7(nodeB)
  );
  childNodesCache.set(node, childNodes);
  return childNodes;
}
function decorateComment(node, comment, options9, enclosingNode) {
  const { locStart: locStart8, locEnd: locEnd7 } = options9;
  const commentStart = locStart8(comment);
  const commentEnd = locEnd7(comment);
  const childNodes = getSortedChildNodes(node, options9);
  let precedingNode;
  let followingNode;
  let left = 0;
  let right = childNodes.length;
  while (left < right) {
    const middle = left + right >> 1;
    const child = childNodes[middle];
    const start = locStart8(child);
    const end = locEnd7(child);
    if (start <= commentStart && commentEnd <= end) {
      return decorateComment(child, comment, options9, child);
    }
    if (end <= commentStart) {
      precedingNode = child;
      left = middle + 1;
      continue;
    }
    if (commentEnd <= start) {
      followingNode = child;
      right = middle;
      continue;
    }
    throw new Error("Comment location overlaps with node location");
  }
  if ((enclosingNode == null ? void 0 : enclosingNode.type) === "TemplateLiteral") {
    const { quasis } = enclosingNode;
    const commentIndex = findExpressionIndexForComment(
      quasis,
      comment,
      options9
    );
    if (precedingNode && findExpressionIndexForComment(quasis, precedingNode, options9) !== commentIndex) {
      precedingNode = null;
    }
    if (followingNode && findExpressionIndexForComment(quasis, followingNode, options9) !== commentIndex) {
      followingNode = null;
    }
  }
  return { enclosingNode, precedingNode, followingNode };
}
var returnFalse = () => false;
function attach(comments, ast, text, options9) {
  if (!is_non_empty_array_default(comments) || !options9.printer.canAttachComment) {
    return;
  }
  const tiesToBreak = [];
  const {
    locStart: locStart8,
    locEnd: locEnd7,
    printer: { handleComments = {} }
  } = options9;
  const {
    avoidAstMutation: avoidAstMutation2,
    ownLine: handleOwnLineComment2 = returnFalse,
    endOfLine: handleEndOfLineComment2 = returnFalse,
    remaining: handleRemainingComment2 = returnFalse
  } = handleComments;
  const decoratedComments = comments.map((comment, index) => ({
    ...decorateComment(ast, comment, options9),
    comment,
    text,
    options: options9,
    ast,
    isLastComment: comments.length - 1 === index
  }));
  for (const [index, context] of decoratedComments.entries()) {
    const {
      comment,
      precedingNode,
      enclosingNode,
      followingNode,
      text: text2,
      options: options10,
      ast: ast2,
      isLastComment
    } = context;
    if (options10.parser === "json" || options10.parser === "json5" || options10.parser === "__js_expression" || options10.parser === "__vue_expression" || options10.parser === "__vue_ts_expression") {
      if (locStart8(comment) - locStart8(ast2) <= 0) {
        addLeadingComment(ast2, comment);
        continue;
      }
      if (locEnd7(comment) - locEnd7(ast2) >= 0) {
        addTrailingComment(ast2, comment);
        continue;
      }
    }
    let args;
    if (avoidAstMutation2) {
      args = [context];
    } else {
      comment.enclosingNode = enclosingNode;
      comment.precedingNode = precedingNode;
      comment.followingNode = followingNode;
      args = [comment, text2, options10, ast2, isLastComment];
    }
    if (isOwnLineComment(text2, options10, decoratedComments, index)) {
      comment.placement = "ownLine";
      if (handleOwnLineComment2(...args)) {
      } else if (followingNode) {
        addLeadingComment(followingNode, comment);
      } else if (precedingNode) {
        addTrailingComment(precedingNode, comment);
      } else if (enclosingNode) {
        addDanglingComment(enclosingNode, comment);
      } else {
        addDanglingComment(ast2, comment);
      }
    } else if (isEndOfLineComment(text2, options10, decoratedComments, index)) {
      comment.placement = "endOfLine";
      if (handleEndOfLineComment2(...args)) {
      } else if (precedingNode) {
        addTrailingComment(precedingNode, comment);
      } else if (followingNode) {
        addLeadingComment(followingNode, comment);
      } else if (enclosingNode) {
        addDanglingComment(enclosingNode, comment);
      } else {
        addDanglingComment(ast2, comment);
      }
    } else {
      comment.placement = "remaining";
      if (handleRemainingComment2(...args)) {
      } else if (precedingNode && followingNode) {
        const tieCount = tiesToBreak.length;
        if (tieCount > 0) {
          const lastTie = tiesToBreak[tieCount - 1];
          if (lastTie.followingNode !== followingNode) {
            breakTies(tiesToBreak, text2, options10);
          }
        }
        tiesToBreak.push(context);
      } else if (precedingNode) {
        addTrailingComment(precedingNode, comment);
      } else if (followingNode) {
        addLeadingComment(followingNode, comment);
      } else if (enclosingNode) {
        addDanglingComment(enclosingNode, comment);
      } else {
        addDanglingComment(ast2, comment);
      }
    }
  }
  breakTies(tiesToBreak, text, options9);
  if (!avoidAstMutation2) {
    for (const comment of comments) {
      delete comment.precedingNode;
      delete comment.enclosingNode;
      delete comment.followingNode;
    }
  }
}
var isAllEmptyAndNoLineBreak = (text) => !/[\S\n\u2028\u2029]/.test(text);
function isOwnLineComment(text, options9, decoratedComments, commentIndex) {
  const { comment, precedingNode } = decoratedComments[commentIndex];
  const { locStart: locStart8, locEnd: locEnd7 } = options9;
  let start = locStart8(comment);
  if (precedingNode) {
    for (let index = commentIndex - 1; index >= 0; index--) {
      const { comment: comment2, precedingNode: currentCommentPrecedingNode } = decoratedComments[index];
      if (currentCommentPrecedingNode !== precedingNode || !isAllEmptyAndNoLineBreak(text.slice(locEnd7(comment2), start))) {
        break;
      }
      start = locStart8(comment2);
    }
  }
  return has_newline_default(text, start, { backwards: true });
}
function isEndOfLineComment(text, options9, decoratedComments, commentIndex) {
  const { comment, followingNode } = decoratedComments[commentIndex];
  const { locStart: locStart8, locEnd: locEnd7 } = options9;
  let end = locEnd7(comment);
  if (followingNode) {
    for (let index = commentIndex + 1; index < decoratedComments.length; index++) {
      const { comment: comment2, followingNode: currentCommentFollowingNode } = decoratedComments[index];
      if (currentCommentFollowingNode !== followingNode || !isAllEmptyAndNoLineBreak(text.slice(end, locStart8(comment2)))) {
        break;
      }
      end = locEnd7(comment2);
    }
  }
  return has_newline_default(text, end);
}
function breakTies(tiesToBreak, text, options9) {
  var _a, _b;
  const tieCount = tiesToBreak.length;
  if (tieCount === 0) {
    return;
  }
  const { precedingNode, followingNode } = tiesToBreak[0];
  let gapEndPos = options9.locStart(followingNode);
  let indexOfFirstLeadingComment;
  for (indexOfFirstLeadingComment = tieCount; indexOfFirstLeadingComment > 0; --indexOfFirstLeadingComment) {
    const {
      comment,
      precedingNode: currentCommentPrecedingNode,
      followingNode: currentCommentFollowingNode
    } = tiesToBreak[indexOfFirstLeadingComment - 1];
    assert.strictEqual(currentCommentPrecedingNode, precedingNode);
    assert.strictEqual(currentCommentFollowingNode, followingNode);
    const gap = text.slice(options9.locEnd(comment), gapEndPos);
    if (((_b = (_a = options9.printer).isGap) == null ? void 0 : _b.call(_a, gap, options9)) ?? /^[\s(]*$/.test(gap)) {
      gapEndPos = options9.locStart(comment);
    } else {
      break;
    }
  }
  for (const [i, { comment }] of tiesToBreak.entries()) {
    if (i < indexOfFirstLeadingComment) {
      addTrailingComment(precedingNode, comment);
    } else {
      addLeadingComment(followingNode, comment);
    }
  }
  for (const node of [precedingNode, followingNode]) {
    if (node.comments && node.comments.length > 1) {
      node.comments.sort((a, b) => options9.locStart(a) - options9.locStart(b));
    }
  }
  tiesToBreak.length = 0;
}
function findExpressionIndexForComment(quasis, comment, options9) {
  const startPos = options9.locStart(comment) - 1;
  for (let i = 1; i < quasis.length; ++i) {
    if (startPos < options9.locStart(quasis[i])) {
      return i - 1;
    }
  }
  return 0;
}
function attachComments(text, ast, opts) {
  const { comments } = ast;
  if (comments) {
    delete ast.comments;
    attach(comments, ast, text, opts);
  }
  opts[Symbol.for("comments")] = comments || [];
  opts[Symbol.for("tokens")] = ast.tokens || [];
  opts.originalText = text;
  return comments;
}

// src/document/builders.js
import { builders } from "./doc.mjs";
var {
  addAlignmentToDoc,
  align,
  breakParent,
  concat,
  conditionalGroup,
  cursor,
  dedent,
  dedentToRoot,
  fill,
  group,
  hardline,
  hardlineWithoutBreakParent,
  ifBreak,
  indent,
  indentIfBreak,
  join,
  label,
  line,
  lineSuffix,
  lineSuffixBoundary,
  literalline,
  literallineWithoutBreakParent,
  markAsRoot,
  softline,
  trim
} = builders;

// src/utils/is-previous-line-empty.js
function isPreviousLineEmpty(text, startIndex) {
  let idx = startIndex - 1;
  idx = skipSpaces(text, idx, { backwards: true });
  idx = skip_newline_default(text, idx, { backwards: true });
  idx = skipSpaces(text, idx, { backwards: true });
  const idx2 = skip_newline_default(text, idx, { backwards: true });
  return idx !== idx2;
}
var is_previous_line_empty_default = isPreviousLineEmpty;

// src/main/comments/print.js
var returnTrue = () => true;
function printComment(path11, options9) {
  const comment = path11.node;
  comment.printed = true;
  return options9.printer.printComment(path11, options9);
}
function printLeadingComment(path11, options9) {
  var _a;
  const comment = path11.node;
  const parts = [printComment(path11, options9)];
  const { printer: printer10, originalText, locStart: locStart8, locEnd: locEnd7 } = options9;
  const isBlock = (_a = printer10.isBlockComment) == null ? void 0 : _a.call(printer10, comment);
  if (isBlock) {
    const lineBreak = has_newline_default(originalText, locEnd7(comment)) ? has_newline_default(originalText, locStart8(comment), {
      backwards: true
    }) ? hardline : line : " ";
    parts.push(lineBreak);
  } else {
    parts.push(hardline);
  }
  const index = skip_newline_default(
    originalText,
    skipSpaces(originalText, locEnd7(comment))
  );
  if (index !== false && has_newline_default(originalText, index)) {
    parts.push(hardline);
  }
  return parts;
}
function printTrailingComment(path11, options9, previousComment) {
  var _a;
  const comment = path11.node;
  const printed = printComment(path11, options9);
  const { printer: printer10, originalText, locStart: locStart8 } = options9;
  const isBlock = (_a = printer10.isBlockComment) == null ? void 0 : _a.call(printer10, comment);
  if ((previousComment == null ? void 0 : previousComment.hasLineSuffix) && !(previousComment == null ? void 0 : previousComment.isBlock) || has_newline_default(originalText, locStart8(comment), { backwards: true })) {
    const isLineBeforeEmpty = is_previous_line_empty_default(
      originalText,
      locStart8(comment)
    );
    return {
      doc: lineSuffix([hardline, isLineBeforeEmpty ? hardline : "", printed]),
      isBlock,
      hasLineSuffix: true
    };
  }
  if (!isBlock || (previousComment == null ? void 0 : previousComment.hasLineSuffix)) {
    return {
      doc: [lineSuffix([" ", printed]), breakParent],
      isBlock,
      hasLineSuffix: true
    };
  }
  return { doc: [" ", printed], isBlock, hasLineSuffix: false };
}
function printDanglingComments(path11, options9, danglingCommentsPrintOptions = {}) {
  const { node } = path11;
  if (!is_non_empty_array_default(node == null ? void 0 : node.comments)) {
    return "";
  }
  const {
    indent: shouldIndent = false,
    marker,
    filter = returnTrue
  } = danglingCommentsPrintOptions;
  const parts = [];
  path11.each(({ node: comment }) => {
    if (comment.leading || comment.trailing || comment.marker !== marker || !filter(comment)) {
      return;
    }
    parts.push(printComment(path11, options9));
  }, "comments");
  if (parts.length === 0) {
    return "";
  }
  const doc2 = join(hardline, parts);
  return shouldIndent ? indent([hardline, doc2]) : doc2;
}
function printCommentsSeparately(path11, options9, ignored) {
  const value = path11.node;
  if (!value) {
    return {};
  }
  let comments = value.comments || [];
  if (ignored) {
    comments = comments.filter((comment) => !ignored.has(comment));
  }
  if (comments.length === 0) {
    return { leading: "", trailing: "" };
  }
  const leadingParts = [];
  const trailingParts = [];
  let printedTrailingComment;
  path11.each(() => {
    const comment = path11.node;
    if (ignored == null ? void 0 : ignored.has(comment)) {
      return;
    }
    const { leading, trailing } = comment;
    if (leading) {
      leadingParts.push(printLeadingComment(path11, options9));
    } else if (trailing) {
      printedTrailingComment = printTrailingComment(
        path11,
        options9,
        printedTrailingComment
      );
      trailingParts.push(printedTrailingComment.doc);
    }
  }, "comments");
  return { leading: leadingParts, trailing: trailingParts };
}
function printComments(path11, doc2, options9, ignored) {
  const { leading, trailing } = printCommentsSeparately(path11, options9, ignored);
  if (!leading && !trailing) {
    return doc2;
  }
  return label(
    // Propagate object labels so that the printing logic for ancestor nodes
    // could easily check them.
    typeof doc2.label === "object" && { commented: true, ...doc2.label },
    [leading, doc2, trailing]
  );
}
function ensureAllCommentsPrinted(astComments) {
  if (!astComments) {
    return;
  }
  for (const comment of astComments) {
    if (!comment.printed) {
      throw new Error(
        'Comment "' + comment.value.trim() + '" was not printed. Please report this error!'
      );
    }
    delete comment.printed;
  }
}

// src/common/ast-path.js
var _getNodeStackIndex, getNodeStackIndex_fn, _getAncestors, getAncestors_fn;
var AstPath = class {
  constructor(value) {
    __privateAdd(this, _getNodeStackIndex);
    __privateAdd(this, _getAncestors);
    this.stack = [value];
  }
  /** @type {string | null} */
  get key() {
    const {
      stack,
      siblings
    } = this;
    return at_default(
      /* isOptionalObject*/
      false,
      stack,
      siblings === null ? -2 : -4
    ) ?? null;
  }
  /** @type {number | null} */
  get index() {
    return this.siblings === null ? null : at_default(
      /* isOptionalObject*/
      false,
      this.stack,
      -2
    );
  }
  /** @type {object} */
  get node() {
    return this.stack[this.stack.length - 1];
  }
  /** @type {object | null} */
  get parent() {
    return this.getNode(1);
  }
  /** @type {object | null} */
  get grandparent() {
    return this.getNode(2);
  }
  /** @type {boolean} */
  get isInArray() {
    return this.siblings !== null;
  }
  /** @type {object[] | null} */
  get siblings() {
    const {
      stack
    } = this;
    const maybeArray = at_default(
      /* isOptionalObject*/
      false,
      stack,
      -3
    );
    return Array.isArray(maybeArray) ? maybeArray : null;
  }
  /** @type {object | null} */
  get next() {
    const {
      siblings
    } = this;
    return siblings === null ? null : siblings[this.index + 1];
  }
  /** @type {object | null} */
  get previous() {
    const {
      siblings
    } = this;
    return siblings === null ? null : siblings[this.index - 1];
  }
  /** @type {boolean} */
  get isFirst() {
    return this.index === 0;
  }
  /** @type {boolean} */
  get isLast() {
    const {
      siblings,
      index
    } = this;
    return siblings !== null && index === siblings.length - 1;
  }
  /** @type {boolean} */
  get isRoot() {
    return this.stack.length === 1;
  }
  /** @type {object} */
  get root() {
    return this.stack[0];
  }
  /** @type {object[]} */
  get ancestors() {
    return [...__privateMethod(this, _getAncestors, getAncestors_fn).call(this)];
  }
  // The name of the current property is always the penultimate element of
  // this.stack, and always a string/number/symbol.
  getName() {
    const {
      stack
    } = this;
    const {
      length
    } = stack;
    if (length > 1) {
      return at_default(
        /* isOptionalObject*/
        false,
        stack,
        -2
      );
    }
    return null;
  }
  // The value of the current property is always the final element of
  // this.stack.
  getValue() {
    return at_default(
      /* isOptionalObject*/
      false,
      this.stack,
      -1
    );
  }
  getNode(count = 0) {
    const stackIndex = __privateMethod(this, _getNodeStackIndex, getNodeStackIndex_fn).call(this, count);
    return stackIndex === -1 ? null : this.stack[stackIndex];
  }
  getParentNode(count = 0) {
    return this.getNode(count + 1);
  }
  // Temporarily push properties named by string arguments given after the
  // callback function onto this.stack, then call the callback with a
  // reference to this (modified) AstPath object. Note that the stack will
  // be restored to its original state after the callback is finished, so it
  // is probably a mistake to retain a reference to the path.
  call(callback, ...names) {
    const {
      stack
    } = this;
    const {
      length
    } = stack;
    let value = at_default(
      /* isOptionalObject*/
      false,
      stack,
      -1
    );
    for (const name of names) {
      value = value[name];
      stack.push(name, value);
    }
    try {
      return callback(this);
    } finally {
      stack.length = length;
    }
  }
  callParent(callback, count = 0) {
    const stackIndex = __privateMethod(this, _getNodeStackIndex, getNodeStackIndex_fn).call(this, count + 1);
    const parentValues = this.stack.splice(stackIndex + 1);
    try {
      return callback(this);
    } finally {
      this.stack.push(...parentValues);
    }
  }
  // Similar to AstPath.prototype.call, except that the value obtained by
  // accessing this.getValue()[name1][name2]... should be array. The
  // callback will be called with a reference to this path object for each
  // element of the array.
  each(callback, ...names) {
    const {
      stack
    } = this;
    const {
      length
    } = stack;
    let value = at_default(
      /* isOptionalObject*/
      false,
      stack,
      -1
    );
    for (const name of names) {
      value = value[name];
      stack.push(name, value);
    }
    try {
      for (let i = 0; i < value.length; ++i) {
        stack.push(i, value[i]);
        callback(this, i, value);
        stack.length -= 2;
      }
    } finally {
      stack.length = length;
    }
  }
  // Similar to AstPath.prototype.each, except that the results of the
  // callback function invocations are stored in an array and returned at
  // the end of the iteration.
  map(callback, ...names) {
    const result = [];
    this.each((path11, index, value) => {
      result[index] = callback(path11, index, value);
    }, ...names);
    return result;
  }
  /**
   * @param {...(
   *   | ((node: any, name: string | null, number: number | null) => boolean)
   *   | undefined
   * )} predicates
   */
  match(...predicates) {
    let stackPointer = this.stack.length - 1;
    let name = null;
    let node = this.stack[stackPointer--];
    for (const predicate of predicates) {
      if (node === void 0) {
        return false;
      }
      let number = null;
      if (typeof name === "number") {
        number = name;
        name = this.stack[stackPointer--];
        node = this.stack[stackPointer--];
      }
      if (predicate && !predicate(node, name, number)) {
        return false;
      }
      name = this.stack[stackPointer--];
      node = this.stack[stackPointer--];
    }
    return true;
  }
  /**
   * Traverses the ancestors of the current node heading toward the tree root
   * until it finds a node that matches the provided predicate function. Will
   * return the first matching ancestor. If no such node exists, returns undefined.
   * @param {(node: any) => boolean} predicate
   * @internal Unstable API. Don't use in plugins for now.
   */
  findAncestor(predicate) {
    for (const node of __privateMethod(this, _getAncestors, getAncestors_fn).call(this)) {
      if (predicate(node)) {
        return node;
      }
    }
  }
  /**
   * Traverses the ancestors of the current node heading toward the tree root
   * until it finds a node that matches the provided predicate function.
   * returns true if matched node found.
   * @param {(node: any) => boolean} predicate
   * @returns {boolean}
   * @internal Unstable API. Don't use in plugins for now.
   */
  hasAncestor(predicate) {
    for (const node of __privateMethod(this, _getAncestors, getAncestors_fn).call(this)) {
      if (predicate(node)) {
        return true;
      }
    }
    return false;
  }
};
_getNodeStackIndex = new WeakSet();
getNodeStackIndex_fn = function(count) {
  const {
    stack
  } = this;
  for (let i = stack.length - 1; i >= 0; i -= 2) {
    if (!Array.isArray(stack[i]) && --count < 0) {
      return i;
    }
  }
  return -1;
};
_getAncestors = new WeakSet();
getAncestors_fn = function* () {
  const {
    stack
  } = this;
  for (let index = stack.length - 3; index >= 0; index -= 2) {
    const value = stack[index];
    if (!Array.isArray(value)) {
      yield value;
    }
  }
};
var ast_path_default = AstPath;

// src/document/utils.js
import { utils } from "./doc.mjs";
var {
  canBreak,
  cleanDoc,
  findInDoc,
  getDocParts,
  getDocType,
  mapDoc,
  normalizeDoc,
  normalizeParts,
  propagateBreaks,
  removeLines,
  replaceEndOfLine,
  stripTrailingHardline,
  traverseDoc,
  willBreak
} = utils;

// src/main/multiparser.js
async function printEmbeddedLanguages(path11, genericPrint8, options9, printAstToDoc2, embeds) {
  const {
    embeddedLanguageFormatting,
    printer: {
      embed: embed6,
      hasPrettierIgnore: hasPrettierIgnore7 = () => false,
      getVisitorKeys: printerGetVisitorKeys
    }
  } = options9;
  if (!embed6 || embeddedLanguageFormatting !== "auto") {
    return;
  }
  if (embed6.length > 2) {
    throw new Error(
      "printer.embed has too many parameters. The API changed in Prettier v3. Please update your plugin. See https://prettier.io/docs/en/plugins.html#optional-embed"
    );
  }
  const getVisitorKeys9 = create_get_visitor_keys_function_default(
    embed6.getVisitorKeys ?? printerGetVisitorKeys
  );
  const embedCallResults = [];
  recurse();
  const originalPathStack = path11.stack;
  for (const { print: print4, node, pathStack } of embedCallResults) {
    try {
      path11.stack = pathStack;
      const doc2 = await print4(textToDocForEmbed, genericPrint8, path11, options9);
      if (doc2) {
        embeds.set(node, doc2);
      }
    } catch (error) {
      if (process.env.PRETTIER_DEBUG) {
        throw error;
      }
    }
  }
  path11.stack = originalPathStack;
  function textToDocForEmbed(text, partialNextOptions) {
    return textToDoc(text, partialNextOptions, options9, printAstToDoc2);
  }
  function recurse() {
    const { node } = path11;
    if (node === null || typeof node !== "object" || hasPrettierIgnore7(path11)) {
      return;
    }
    for (const key of getVisitorKeys9(node)) {
      if (Array.isArray(node[key])) {
        path11.each(recurse, key);
      } else {
        path11.call(recurse, key);
      }
    }
    const result = embed6(path11, options9);
    if (!result) {
      return;
    }
    if (typeof result === "function") {
      embedCallResults.push({
        print: result,
        node,
        pathStack: [...path11.stack]
      });
      return;
    }
    if (false) {
      throw new Error(
        "`embed` should return an async function instead of Promise."
      );
    }
    embeds.set(node, result);
  }
}
async function textToDoc(text, partialNextOptions, parentOptions, printAstToDoc2) {
  const options9 = await normalize_format_options_default(
    {
      ...parentOptions,
      ...partialNextOptions,
      parentParser: parentOptions.parser,
      originalText: text
    },
    { passThrough: true }
  );
  const result = await parse(text, options9);
  const { ast } = result;
  text = result.text;
  const astComments = attachComments(text, ast, options9);
  const doc2 = await printAstToDoc2(ast, options9);
  ensureAllCommentsPrinted(astComments);
  return stripTrailingHardline(doc2);
}

// src/main/create-print-pre-check-function.js
function createPrintPreCheckFunction(options9) {
  if (true) {
    return () => {
    };
  }
  const getVisitorKeys9 = create_get_visitor_keys_function_default(
    options9.printer.getVisitorKeys
  );
  return function(path11) {
    if (path11.isRoot) {
      return;
    }
    const { key, parent } = path11;
    const visitorKeys6 = getVisitorKeys9(parent);
    if (visitorKeys6.includes(key)) {
      return;
    }
    throw Object.assign(new Error("Calling `print()` on non-node object."), {
      parentNode: parent,
      allowedProperties: visitorKeys6,
      printingProperty: key,
      printingValue: path11.node,
      pathStack: path11.stack.length > 5 ? ["...", ...path11.stack.slice(-5)] : [...path11.stack]
    });
  };
}
var create_print_pre_check_function_default = createPrintPreCheckFunction;

// src/main/ast-to-doc.js
async function printAstToDoc(ast, options9, alignmentSize = 0) {
  const { printer: printer10 } = options9;
  if (printer10.preprocess) {
    ast = await printer10.preprocess(ast, options9);
  }
  const cache = /* @__PURE__ */ new Map();
  const path11 = new ast_path_default(ast);
  const ensurePrintingNode = create_print_pre_check_function_default(options9);
  const embeds = /* @__PURE__ */ new Map();
  await printEmbeddedLanguages(path11, mainPrint, options9, printAstToDoc, embeds);
  let doc2 = await callPluginPrintFunction(
    path11,
    options9,
    mainPrint,
    void 0,
    embeds
  );
  if (alignmentSize > 0) {
    doc2 = addAlignmentToDoc([hardline, doc2], alignmentSize, options9.tabWidth);
  }
  propagateBreaks(doc2);
  return doc2;
  function mainPrint(selector, args) {
    if (selector === void 0 || selector === path11) {
      return mainPrintInternal(args);
    }
    if (Array.isArray(selector)) {
      return path11.call(() => mainPrintInternal(args), ...selector);
    }
    return path11.call(() => mainPrintInternal(args), selector);
  }
  function mainPrintInternal(args) {
    ensurePrintingNode(path11);
    const value = path11.node;
    if (value === void 0 || value === null) {
      return "";
    }
    const shouldCache = value && typeof value === "object" && args === void 0;
    if (shouldCache && cache.has(value)) {
      return cache.get(value);
    }
    const doc3 = callPluginPrintFunction(path11, options9, mainPrint, args, embeds);
    if (shouldCache) {
      cache.set(value, doc3);
    }
    return doc3;
  }
}
function printPrettierIgnoredNode(node, options9) {
  const {
    originalText,
    [Symbol.for("comments")]: comments,
    locStart: locStart8,
    locEnd: locEnd7
  } = options9;
  const start = locStart8(node);
  const end = locEnd7(node);
  const printedComments = /* @__PURE__ */ new Set();
  for (const comment of comments) {
    if (locStart8(comment) >= start && locEnd7(comment) <= end) {
      comment.printed = true;
      printedComments.add(comment);
    }
  }
  return { doc: originalText.slice(start, end), printedComments };
}
function callPluginPrintFunction(path11, options9, printPath2, args, embeds) {
  var _a;
  const { node } = path11;
  const { printer: printer10 } = options9;
  let doc2;
  let printedComments;
  if ((_a = printer10.hasPrettierIgnore) == null ? void 0 : _a.call(printer10, path11)) {
    ({ doc: doc2, printedComments } = printPrettierIgnoredNode(node, options9));
  } else if (embeds.has(node)) {
    doc2 = embeds.get(node);
  } else {
    doc2 = printer10.print(path11, options9, printPath2, args);
  }
  if (!printer10.willPrintOwnComments || !printer10.willPrintOwnComments(path11, options9)) {
    doc2 = printComments(path11, doc2, options9, printedComments);
  }
  if (node === options9.cursorNode) {
    doc2 = label(
      // Propagate object labels so that the printing logic for ancestor nodes
      // could easily check them.
      typeof doc2.label === "object" && { commented: true, ...doc2.label },
      [cursor, doc2, cursor]
    );
  }
  return doc2;
}
var ast_to_doc_default = printAstToDoc;

// src/main/range-util.js
import assert2 from "assert";
var isJsonParser = ({ parser }) => parser === "json" || parser === "json5" || parser === "json-stringify";
function findCommonAncestor(startNodeAndParents, endNodeAndParents) {
  const startNodeAndAncestors = [
    startNodeAndParents.node,
    ...startNodeAndParents.parentNodes
  ];
  const endNodeAndAncestors = /* @__PURE__ */ new Set([
    endNodeAndParents.node,
    ...endNodeAndParents.parentNodes
  ]);
  return startNodeAndAncestors.find(
    (node) => jsonSourceElements.has(node.type) && endNodeAndAncestors.has(node)
  );
}
function dropRootParents(parents) {
  let lastParentIndex = parents.length - 1;
  for (; ; ) {
    const parent = parents[lastParentIndex];
    if ((parent == null ? void 0 : parent.type) === "Program" || (parent == null ? void 0 : parent.type) === "File") {
      lastParentIndex--;
    } else {
      break;
    }
  }
  return parents.slice(0, lastParentIndex + 1);
}
function findSiblingAncestors(startNodeAndParents, endNodeAndParents, { locStart: locStart8, locEnd: locEnd7 }) {
  let resultStartNode = startNodeAndParents.node;
  let resultEndNode = endNodeAndParents.node;
  if (resultStartNode === resultEndNode) {
    return {
      startNode: resultStartNode,
      endNode: resultEndNode
    };
  }
  const startNodeStart = locStart8(startNodeAndParents.node);
  for (const endParent of dropRootParents(endNodeAndParents.parentNodes)) {
    if (locStart8(endParent) >= startNodeStart) {
      resultEndNode = endParent;
    } else {
      break;
    }
  }
  const endNodeEnd = locEnd7(endNodeAndParents.node);
  for (const startParent of dropRootParents(startNodeAndParents.parentNodes)) {
    if (locEnd7(startParent) <= endNodeEnd) {
      resultStartNode = startParent;
    } else {
      break;
    }
    if (resultStartNode === resultEndNode) {
      break;
    }
  }
  return {
    startNode: resultStartNode,
    endNode: resultEndNode
  };
}
function findNodeAtOffset(node, offset, options9, predicate, parentNodes = [], type) {
  const { locStart: locStart8, locEnd: locEnd7 } = options9;
  const start = locStart8(node);
  const end = locEnd7(node);
  if (offset > end || offset < start || type === "rangeEnd" && offset === start || type === "rangeStart" && offset === end) {
    return;
  }
  for (const childNode of getSortedChildNodes(node, options9)) {
    const childResult = findNodeAtOffset(
      childNode,
      offset,
      options9,
      predicate,
      [node, ...parentNodes],
      type
    );
    if (childResult) {
      return childResult;
    }
  }
  if (!predicate || predicate(node, parentNodes[0])) {
    return {
      node,
      parentNodes
    };
  }
}
function isJsSourceElement(type, parentType) {
  return parentType !== "DeclareExportDeclaration" && type !== "TypeParameterDeclaration" && (type === "Directive" || type === "TypeAlias" || type === "TSExportAssignment" || type.startsWith("Declare") || type.startsWith("TSDeclare") || type.endsWith("Statement") || type.endsWith("Declaration"));
}
var jsonSourceElements = /* @__PURE__ */ new Set([
  "JsonRoot",
  "ObjectExpression",
  "ArrayExpression",
  "StringLiteral",
  "NumericLiteral",
  "BooleanLiteral",
  "NullLiteral",
  "UnaryExpression",
  "TemplateLiteral"
]);
var graphqlSourceElements = /* @__PURE__ */ new Set([
  "OperationDefinition",
  "FragmentDefinition",
  "VariableDefinition",
  "TypeExtensionDefinition",
  "ObjectTypeDefinition",
  "FieldDefinition",
  "DirectiveDefinition",
  "EnumTypeDefinition",
  "EnumValueDefinition",
  "InputValueDefinition",
  "InputObjectTypeDefinition",
  "SchemaDefinition",
  "OperationTypeDefinition",
  "InterfaceTypeDefinition",
  "UnionTypeDefinition",
  "ScalarTypeDefinition"
]);
function isSourceElement(opts, node, parentNode) {
  if (!node) {
    return false;
  }
  switch (opts.parser) {
    case "flow":
    case "babel":
    case "babel-flow":
    case "babel-ts":
    case "typescript":
    case "acorn":
    case "espree":
    case "meriyah":
    case "__babel_estree":
      return isJsSourceElement(node.type, parentNode == null ? void 0 : parentNode.type);
    case "json":
    case "json5":
    case "json-stringify":
      return jsonSourceElements.has(node.type);
    case "graphql":
      return graphqlSourceElements.has(node.kind);
    case "vue":
      return node.tag !== "root";
  }
  return false;
}
function calculateRange(text, opts, ast) {
  let { rangeStart: start, rangeEnd: end, locStart: locStart8, locEnd: locEnd7 } = opts;
  assert2.ok(end > start);
  const firstNonWhitespaceCharacterIndex = text.slice(start, end).search(/\S/);
  const isAllWhitespace = firstNonWhitespaceCharacterIndex === -1;
  if (!isAllWhitespace) {
    start += firstNonWhitespaceCharacterIndex;
    for (; end > start; --end) {
      if (/\S/.test(text[end - 1])) {
        break;
      }
    }
  }
  const startNodeAndParents = findNodeAtOffset(
    ast,
    start,
    opts,
    (node, parentNode) => isSourceElement(opts, node, parentNode),
    [],
    "rangeStart"
  );
  const endNodeAndParents = (
    // No need find Node at `end`, it will be the same as `startNodeAndParents`
    isAllWhitespace ? startNodeAndParents : findNodeAtOffset(
      ast,
      end,
      opts,
      (node) => isSourceElement(opts, node),
      [],
      "rangeEnd"
    )
  );
  if (!startNodeAndParents || !endNodeAndParents) {
    return {
      rangeStart: 0,
      rangeEnd: 0
    };
  }
  let startNode;
  let endNode;
  if (isJsonParser(opts)) {
    const commonAncestor = findCommonAncestor(
      startNodeAndParents,
      endNodeAndParents
    );
    startNode = commonAncestor;
    endNode = commonAncestor;
  } else {
    ({ startNode, endNode } = findSiblingAncestors(
      startNodeAndParents,
      endNodeAndParents,
      opts
    ));
  }
  return {
    rangeStart: Math.min(locStart8(startNode), locStart8(endNode)),
    rangeEnd: Math.max(locEnd7(startNode), locEnd7(endNode))
  };
}

// src/main/core.js
var BOM = "\uFEFF";
var CURSOR = Symbol("cursor");
async function coreFormat(originalText, opts, addAlignmentSize = 0) {
  if (!originalText || originalText.trim().length === 0) {
    return {
      formatted: "",
      cursorOffset: -1,
      comments: []
    };
  }
  const {
    ast,
    text
  } = await parse(originalText, opts);
  if (opts.cursorOffset >= 0) {
    const nodeResult = findNodeAtOffset(ast, opts.cursorOffset, opts);
    if (nodeResult == null ? void 0 : nodeResult.node) {
      opts.cursorNode = nodeResult.node;
    }
  }
  const astComments = attachComments(text, ast, opts);
  const doc2 = await ast_to_doc_default(ast, opts, addAlignmentSize);
  const result = printDocToString(doc2, opts);
  ensureAllCommentsPrinted(astComments);
  if (addAlignmentSize > 0) {
    const trimmed = result.formatted.trim();
    if (result.cursorNodeStart !== void 0) {
      result.cursorNodeStart -= result.formatted.indexOf(trimmed);
    }
    result.formatted = trimmed + convertEndOfLineToChars(opts.endOfLine);
  }
  if (opts.cursorOffset >= 0) {
    let oldCursorNodeStart;
    let oldCursorNodeText;
    let cursorOffsetRelativeToOldCursorNode;
    let newCursorNodeStart;
    let newCursorNodeText;
    if (opts.cursorNode && result.cursorNodeText) {
      oldCursorNodeStart = opts.locStart(opts.cursorNode);
      oldCursorNodeText = text.slice(oldCursorNodeStart, opts.locEnd(opts.cursorNode));
      cursorOffsetRelativeToOldCursorNode = opts.cursorOffset - oldCursorNodeStart;
      newCursorNodeStart = result.cursorNodeStart;
      newCursorNodeText = result.cursorNodeText;
    } else {
      oldCursorNodeStart = 0;
      oldCursorNodeText = text;
      cursorOffsetRelativeToOldCursorNode = opts.cursorOffset;
      newCursorNodeStart = 0;
      newCursorNodeText = result.formatted;
    }
    if (oldCursorNodeText === newCursorNodeText) {
      return {
        formatted: result.formatted,
        cursorOffset: newCursorNodeStart + cursorOffsetRelativeToOldCursorNode,
        comments: astComments
      };
    }
    const oldCursorNodeCharArray = oldCursorNodeText.split("");
    oldCursorNodeCharArray.splice(cursorOffsetRelativeToOldCursorNode, 0, CURSOR);
    const newCursorNodeCharArray = newCursorNodeText.split("");
    const cursorNodeDiff = (0, import_diff.diffArrays)(oldCursorNodeCharArray, newCursorNodeCharArray);
    let cursorOffset = newCursorNodeStart;
    for (const entry of cursorNodeDiff) {
      if (entry.removed) {
        if (entry.value.includes(CURSOR)) {
          break;
        }
      } else {
        cursorOffset += entry.count;
      }
    }
    return {
      formatted: result.formatted,
      cursorOffset,
      comments: astComments
    };
  }
  return {
    formatted: result.formatted,
    cursorOffset: -1,
    comments: astComments
  };
}
async function formatRange(originalText, opts) {
  const {
    ast,
    text
  } = await parse(originalText, opts);
  const {
    rangeStart,
    rangeEnd
  } = calculateRange(text, opts, ast);
  const rangeString = text.slice(rangeStart, rangeEnd);
  const rangeStart2 = Math.min(rangeStart, text.lastIndexOf("\n", rangeStart) + 1);
  const indentString = text.slice(rangeStart2, rangeStart).match(/^\s*/)[0];
  const alignmentSize = get_alignment_size_default(indentString, opts.tabWidth);
  const rangeResult = await coreFormat(rangeString, {
    ...opts,
    rangeStart: 0,
    rangeEnd: Number.POSITIVE_INFINITY,
    // Track the cursor offset only if it's within our range
    cursorOffset: opts.cursorOffset > rangeStart && opts.cursorOffset <= rangeEnd ? opts.cursorOffset - rangeStart : -1,
    // Always use `lf` to format, we'll replace it later
    endOfLine: "lf"
  }, alignmentSize);
  const rangeTrimmed = rangeResult.formatted.trimEnd();
  let {
    cursorOffset
  } = opts;
  if (cursorOffset > rangeEnd) {
    cursorOffset += rangeTrimmed.length - rangeString.length;
  } else if (rangeResult.cursorOffset >= 0) {
    cursorOffset = rangeResult.cursorOffset + rangeStart;
  }
  let formatted = text.slice(0, rangeStart) + rangeTrimmed + text.slice(rangeEnd);
  if (opts.endOfLine !== "lf") {
    const eol = convertEndOfLineToChars(opts.endOfLine);
    if (cursorOffset >= 0 && eol === "\r\n") {
      cursorOffset += countEndOfLineChars(formatted.slice(0, cursorOffset), "\n");
    }
    formatted = string_replace_all_default(
      /* isOptionalObject*/
      false,
      formatted,
      "\n",
      eol
    );
  }
  return {
    formatted,
    cursorOffset,
    comments: rangeResult.comments
  };
}
function ensureIndexInText(text, index, defaultValue) {
  if (typeof index !== "number" || Number.isNaN(index) || index < 0 || index > text.length) {
    return defaultValue;
  }
  return index;
}
function normalizeIndexes(text, options9) {
  let {
    cursorOffset,
    rangeStart,
    rangeEnd
  } = options9;
  cursorOffset = ensureIndexInText(text, cursorOffset, -1);
  rangeStart = ensureIndexInText(text, rangeStart, 0);
  rangeEnd = ensureIndexInText(text, rangeEnd, text.length);
  return {
    ...options9,
    cursorOffset,
    rangeStart,
    rangeEnd
  };
}
function normalizeInputAndOptions(text, options9) {
  let {
    cursorOffset,
    rangeStart,
    rangeEnd,
    endOfLine
  } = normalizeIndexes(text, options9);
  const hasBOM = text.charAt(0) === BOM;
  if (hasBOM) {
    text = text.slice(1);
    cursorOffset--;
    rangeStart--;
    rangeEnd--;
  }
  if (endOfLine === "auto") {
    endOfLine = guessEndOfLine(text);
  }
  if (text.includes("\r")) {
    const countCrlfBefore = (index) => countEndOfLineChars(text.slice(0, Math.max(index, 0)), "\r\n");
    cursorOffset -= countCrlfBefore(cursorOffset);
    rangeStart -= countCrlfBefore(rangeStart);
    rangeEnd -= countCrlfBefore(rangeEnd);
    text = normalizeEndOfLine(text);
  }
  return {
    hasBOM,
    text,
    options: normalizeIndexes(text, {
      ...options9,
      cursorOffset,
      rangeStart,
      rangeEnd,
      endOfLine
    })
  };
}
async function hasPragma(text, options9) {
  const selectedParser = await resolveParser(options9);
  return !selectedParser.hasPragma || selectedParser.hasPragma(text);
}
async function formatWithCursor(originalText, originalOptions) {
  let {
    hasBOM,
    text,
    options: options9
  } = normalizeInputAndOptions(originalText, await normalize_format_options_default(originalOptions));
  if (options9.rangeStart >= options9.rangeEnd && text !== "" || options9.requirePragma && !await hasPragma(text, options9)) {
    return {
      formatted: originalText,
      cursorOffset: originalOptions.cursorOffset,
      comments: []
    };
  }
  let result;
  if (options9.rangeStart > 0 || options9.rangeEnd < text.length) {
    result = await formatRange(text, options9);
  } else {
    if (!options9.requirePragma && options9.insertPragma && options9.printer.insertPragma && !await hasPragma(text, options9)) {
      text = options9.printer.insertPragma(text);
    }
    result = await coreFormat(text, options9);
  }
  if (hasBOM) {
    result.formatted = BOM + result.formatted;
    if (result.cursorOffset >= 0) {
      result.cursorOffset++;
    }
  }
  return result;
}
async function parse2(originalText, originalOptions, devOptions) {
  const {
    text,
    options: options9
  } = normalizeInputAndOptions(originalText, await normalize_format_options_default(originalOptions));
  const parsed = await parse(text, options9);
  if (devOptions) {
    if (devOptions.massage) {
      parsed.ast = massage_ast_default(parsed.ast, options9);
    }
    if (devOptions.preprocessForPrint) {
      attachComments(parsed.text, parsed.ast, options9);
      if (options9.printer.preprocess) {
        parsed.ast = await options9.printer.preprocess(parsed.ast, options9);
      }
    }
  }
  return parsed;
}
async function formatAst(ast, options9) {
  options9 = await normalize_format_options_default(options9);
  const doc2 = await ast_to_doc_default(ast, options9);
  return printDocToString(doc2, options9);
}
async function formatDoc(doc2, options9) {
  const text = printDocToDebug(doc2);
  const {
    formatted
  } = await formatWithCursor(text, {
    ...options9,
    parser: "__js_expression"
  });
  return formatted;
}
async function printToDoc(originalText, options9) {
  options9 = await normalize_format_options_default(options9);
  const {
    ast,
    text
  } = await parse(originalText, options9);
  attachComments(text, ast, options9);
  return ast_to_doc_default(ast, options9);
}
async function printDocToString2(doc2, options9) {
  return printDocToString(doc2, await normalize_format_options_default(options9));
}

// src/config/resolve-config.js
var import_micromatch = __toESM(require_micromatch(), 1);
import path7 from "path";

// node_modules/mimic-fn/index.js
var copyProperty = (to, from, property, ignoreNonConfigurable) => {
  if (property === "length" || property === "prototype") {
    return;
  }
  if (property === "arguments" || property === "caller") {
    return;
  }
  const toDescriptor = Object.getOwnPropertyDescriptor(to, property);
  const fromDescriptor = Object.getOwnPropertyDescriptor(from, property);
  if (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {
    return;
  }
  Object.defineProperty(to, property, fromDescriptor);
};
var canCopyProperty = function(toDescriptor, fromDescriptor) {
  return toDescriptor === void 0 || toDescriptor.configurable || toDescriptor.writable === fromDescriptor.writable && toDescriptor.enumerable === fromDescriptor.enumerable && toDescriptor.configurable === fromDescriptor.configurable && (toDescriptor.writable || toDescriptor.value === fromDescriptor.value);
};
var changePrototype = (to, from) => {
  const fromPrototype = Object.getPrototypeOf(from);
  if (fromPrototype === Object.getPrototypeOf(to)) {
    return;
  }
  Object.setPrototypeOf(to, fromPrototype);
};
var wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/
${fromBody}`;
var toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, "toString");
var toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, "name");
var changeToString = (to, from, name) => {
  const withName = name === "" ? "" : `with ${name.trim()}() `;
  const newToString = wrappedToString.bind(null, withName, from.toString());
  Object.defineProperty(newToString, "name", toStringName);
  Object.defineProperty(to, "toString", { ...toStringDescriptor, value: newToString });
};
function mimicFunction(to, from, { ignoreNonConfigurable = false } = {}) {
  const { name } = to;
  for (const property of Reflect.ownKeys(from)) {
    copyProperty(to, from, property, ignoreNonConfigurable);
  }
  changePrototype(to, from);
  changeToString(to, from, name);
  return to;
}

// node_modules/mem/dist/index.js
var import_map_age_cleaner = __toESM(require_dist(), 1);
var cacheStore = /* @__PURE__ */ new WeakMap();
function mem(fn, { cacheKey, cache = /* @__PURE__ */ new Map(), maxAge } = {}) {
  if (typeof maxAge === "number") {
    (0, import_map_age_cleaner.default)(cache);
  }
  const memoized = function(...arguments_) {
    const key = cacheKey ? cacheKey(arguments_) : arguments_[0];
    const cacheItem = cache.get(key);
    if (cacheItem) {
      return cacheItem.data;
    }
    const result = fn.apply(this, arguments_);
    cache.set(key, {
      data: result,
      maxAge: maxAge ? Date.now() + maxAge : Number.POSITIVE_INFINITY
    });
    return result;
  };
  mimicFunction(memoized, fn, {
    ignoreNonConfigurable: true
  });
  cacheStore.set(memoized, cache);
  return memoized;
}
function memClear(fn) {
  const cache = cacheStore.get(fn);
  if (!cache) {
    throw new TypeError("Can't clear a function that was not memoized!");
  }
  if (typeof cache.clear !== "function") {
    throw new TypeError("The cache Map can't be cleared!");
  }
  cache.clear();
}

// src/utils/partition.js
function partition(array, predicate) {
  const result = [[], []];
  for (const value of array) {
    result[predicate(value) ? 0 : 1].push(value);
  }
  return result;
}
var partition_default = partition;

// src/config/resolve-editorconfig.js
var import_editorconfig = __toESM(require_src(), 1);
var import_editorconfig_to_prettier = __toESM(require_editorconfig_to_prettier(), 1);
import path3 from "path";

// src/config/find-project-root.js
import fs2 from "fs";
import path2 from "path";
var MARKERS = [".git", ".hg"];
var markerExists = (directory) => MARKERS.some((mark) => fs2.existsSync(path2.join(directory, mark)));
function findProjectRoot(directory) {
  while (!markerExists(directory)) {
    const parentDirectory = path2.resolve(directory, "..");
    if (parentDirectory === directory) {
      break;
    }
    directory = parentDirectory;
  }
  return directory;
}
var find_project_root_default = findProjectRoot;

// src/config/resolve-editorconfig.js
async function loadEditorConfig(filePath) {
  const editorConfig = await import_editorconfig.default.parse(filePath, {
    root: find_project_root_default(path3.dirname(path3.resolve(filePath)))
  });
  const config = (0, import_editorconfig_to_prettier.default)(editorConfig);
  if (config) {
    delete config.insertFinalNewline;
  }
  return config;
}
var resolve_editorconfig_default = loadEditorConfig;

// src/config/get-prettier-config-explorer.js
var import_parse_async = __toESM(require_parse_async(), 1);
var import_parse = __toESM(require_parse3(), 1);
import { pathToFileURL as pathToFileURL3 } from "url";
import thirdParty from "./internal/third-party.mjs";

// src/utils/require-from-file.js
import { createRequire } from "module";
function requireFromFile(id, parent) {
  const require2 = createRequire(parent);
  return require2(id);
}
var require_from_file_default = requireFromFile;

// src/utils/import-from-file.js
import { pathToFileURL as pathToFileURL2 } from "url";

// node_modules/import-meta-resolve/lib/resolve.js
import assert4 from "assert";
import { Stats, statSync, realpathSync } from "fs";
import process3 from "process";
import { URL as URL3, fileURLToPath as fileURLToPath3, pathToFileURL } from "url";
import path6 from "path";
import { builtinModules } from "module";

// node_modules/import-meta-resolve/lib/get-format.js
import path4 from "path";
import { URL, fileURLToPath } from "url";

// node_modules/import-meta-resolve/lib/errors.js
import v8 from "v8";
import process2 from "process";
import assert3 from "assert";
import { format, inspect } from "util";
var isWindows = process2.platform === "win32";
var own = {}.hasOwnProperty;
var codes = {};
function formatList(array, type = "and") {
  return array.length < 3 ? array.join(` ${type} `) : `${array.slice(0, -1).join(", ")}, ${type} ${array[array.length - 1]}`;
}
var messages = /* @__PURE__ */ new Map();
var nodeInternalPrefix = "__node_internal_";
var userStackTraceLimit;
codes.ERR_INVALID_MODULE_SPECIFIER = createError(
  "ERR_INVALID_MODULE_SPECIFIER",
  /**
   * @param {string} request
   * @param {string} reason
   * @param {string} [base]
   */
  (request, reason, base = void 0) => {
    return `Invalid module "${request}" ${reason}${base ? ` imported from ${base}` : ""}`;
  },
  TypeError
);
codes.ERR_INVALID_PACKAGE_CONFIG = createError(
  "ERR_INVALID_PACKAGE_CONFIG",
  /**
   * @param {string} path
   * @param {string} [base]
   * @param {string} [message]
   */
  (path11, base, message) => {
    return `Invalid package config ${path11}${base ? ` while importing ${base}` : ""}${message ? `. ${message}` : ""}`;
  },
  Error
);
codes.ERR_INVALID_PACKAGE_TARGET = createError(
  "ERR_INVALID_PACKAGE_TARGET",
  /**
   * @param {string} pkgPath
   * @param {string} key
   * @param {unknown} target
   * @param {boolean} [isImport=false]
   * @param {string} [base]
   */
  (pkgPath, key, target, isImport = false, base = void 0) => {
    const relError = typeof target === "string" && !isImport && target.length > 0 && !target.startsWith("./");
    if (key === ".") {
      assert3(isImport === false);
      return `Invalid "exports" main target ${JSON.stringify(target)} defined in the package config ${pkgPath}package.json${base ? ` imported from ${base}` : ""}${relError ? '; targets must start with "./"' : ""}`;
    }
    return `Invalid "${isImport ? "imports" : "exports"}" target ${JSON.stringify(
      target
    )} defined for '${key}' in the package config ${pkgPath}package.json${base ? ` imported from ${base}` : ""}${relError ? '; targets must start with "./"' : ""}`;
  },
  Error
);
codes.ERR_MODULE_NOT_FOUND = createError(
  "ERR_MODULE_NOT_FOUND",
  /**
   * @param {string} path
   * @param {string} base
   * @param {string} [type]
   */
  (path11, base, type = "package") => {
    return `Cannot find ${type} '${path11}' imported from ${base}`;
  },
  Error
);
codes.ERR_NETWORK_IMPORT_DISALLOWED = createError(
  "ERR_NETWORK_IMPORT_DISALLOWED",
  "import of '%s' by %s is not supported: %s",
  Error
);
codes.ERR_PACKAGE_IMPORT_NOT_DEFINED = createError(
  "ERR_PACKAGE_IMPORT_NOT_DEFINED",
  /**
   * @param {string} specifier
   * @param {string} packagePath
   * @param {string} base
   */
  (specifier, packagePath, base) => {
    return `Package import specifier "${specifier}" is not defined${packagePath ? ` in package ${packagePath}package.json` : ""} imported from ${base}`;
  },
  TypeError
);
codes.ERR_PACKAGE_PATH_NOT_EXPORTED = createError(
  "ERR_PACKAGE_PATH_NOT_EXPORTED",
  /**
   * @param {string} pkgPath
   * @param {string} subpath
   * @param {string} [base]
   */
  (pkgPath, subpath, base = void 0) => {
    if (subpath === ".")
      return `No "exports" main defined in ${pkgPath}package.json${base ? ` imported from ${base}` : ""}`;
    return `Package subpath '${subpath}' is not defined by "exports" in ${pkgPath}package.json${base ? ` imported from ${base}` : ""}`;
  },
  Error
);
codes.ERR_UNSUPPORTED_DIR_IMPORT = createError(
  "ERR_UNSUPPORTED_DIR_IMPORT",
  "Directory import '%s' is not supported resolving ES modules imported from %s",
  Error
);
codes.ERR_UNKNOWN_FILE_EXTENSION = createError(
  "ERR_UNKNOWN_FILE_EXTENSION",
  /**
   * @param {string} ext
   * @param {string} path
   */
  (ext, path11) => {
    return `Unknown file extension "${ext}" for ${path11}`;
  },
  TypeError
);
codes.ERR_INVALID_ARG_VALUE = createError(
  "ERR_INVALID_ARG_VALUE",
  /**
   * @param {string} name
   * @param {unknown} value
   * @param {string} [reason='is invalid']
   */
  (name, value, reason = "is invalid") => {
    let inspected = inspect(value);
    if (inspected.length > 128) {
      inspected = `${inspected.slice(0, 128)}...`;
    }
    const type = name.includes(".") ? "property" : "argument";
    return `The ${type} '${name}' ${reason}. Received ${inspected}`;
  },
  TypeError
  // Note: extra classes have been shaken out.
  // , RangeError
);
codes.ERR_UNSUPPORTED_ESM_URL_SCHEME = createError(
  "ERR_UNSUPPORTED_ESM_URL_SCHEME",
  /**
   * @param {URL} url
   * @param {Array<string>} supported
   */
  (url, supported) => {
    let message = `Only URLs with a scheme in: ${formatList(
      supported
    )} are supported by the default ESM loader`;
    if (isWindows && url.protocol.length === 2) {
      message += ". On Windows, absolute paths must be valid file:// URLs";
    }
    message += `. Received protocol '${url.protocol}'`;
    return message;
  },
  Error
);
function createError(sym, value, def) {
  messages.set(sym, value);
  return makeNodeErrorWithCode(def, sym);
}
function makeNodeErrorWithCode(Base, key) {
  return NodeError;
  function NodeError(...args) {
    const limit = Error.stackTraceLimit;
    if (isErrorStackTraceLimitWritable())
      Error.stackTraceLimit = 0;
    const error = new Base();
    if (isErrorStackTraceLimitWritable())
      Error.stackTraceLimit = limit;
    const message = getMessage(key, args, error);
    Object.defineProperties(error, {
      // Note: no need to implement `kIsNodeError` symbol, would be hard,
      // probably.
      message: {
        value: message,
        enumerable: false,
        writable: true,
        configurable: true
      },
      toString: {
        /** @this {Error} */
        value() {
          return `${this.name} [${key}]: ${this.message}`;
        },
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    captureLargerStackTrace(error);
    error.code = key;
    return error;
  }
}
function isErrorStackTraceLimitWritable() {
  try {
    if (v8.startupSnapshot.isBuildingSnapshot()) {
      return false;
    }
  } catch {
  }
  const desc = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
  if (desc === void 0) {
    return Object.isExtensible(Error);
  }
  return own.call(desc, "writable") && desc.writable !== void 0 ? desc.writable : desc.set !== void 0;
}
function hideStackFrames(fn) {
  const hidden = nodeInternalPrefix + fn.name;
  Object.defineProperty(fn, "name", { value: hidden });
  return fn;
}
var captureLargerStackTrace = hideStackFrames(
  /**
   * @param {Error} error
   * @returns {Error}
   */
  // @ts-expect-error: fine
  function(error) {
    const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable();
    if (stackTraceLimitIsWritable) {
      userStackTraceLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = Number.POSITIVE_INFINITY;
    }
    Error.captureStackTrace(error);
    if (stackTraceLimitIsWritable)
      Error.stackTraceLimit = userStackTraceLimit;
    return error;
  }
);
function getMessage(key, args, self2) {
  const message = messages.get(key);
  assert3(typeof message !== "undefined", "expected `message` to be found");
  if (typeof message === "function") {
    assert3(
      message.length <= args.length,
      // Default options do not count.
      `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${message.length}).`
    );
    return Reflect.apply(message, self2, args);
  }
  const regex = /%[dfijoOs]/g;
  let expectedLength = 0;
  while (regex.exec(message) !== null)
    expectedLength++;
  assert3(
    expectedLength === args.length,
    `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`
  );
  if (args.length === 0)
    return message;
  args.unshift(message);
  return Reflect.apply(format, null, args);
}

// node_modules/import-meta-resolve/lib/get-format.js
var { ERR_UNKNOWN_FILE_EXTENSION } = codes;
var hasOwnProperty = {}.hasOwnProperty;
var extensionFormatMap = {
  // @ts-expect-error: hush.
  __proto__: null,
  ".cjs": "commonjs",
  ".js": "module",
  ".json": "json",
  ".mjs": "module"
};
function mimeToFormat(mime) {
  if (mime && /\s*(text|application)\/javascript\s*(;\s*charset=utf-?8\s*)?/i.test(mime))
    return "module";
  if (mime === "application/json")
    return "json";
  return null;
}
var protocolHandlers = {
  // @ts-expect-error: hush.
  __proto__: null,
  "data:": getDataProtocolModuleFormat,
  "file:": getFileProtocolModuleFormat,
  "http:": getHttpProtocolModuleFormat,
  "https:": getHttpProtocolModuleFormat,
  "node:"() {
    return "builtin";
  }
};
function getDataProtocolModuleFormat(parsed) {
  const { 1: mime } = /^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(
    parsed.pathname
  ) || [null, null, null];
  return mimeToFormat(mime);
}
function getFileProtocolModuleFormat(url, _context, ignoreErrors) {
  const filepath = fileURLToPath(url);
  const ext = path4.extname(filepath);
  if (ext === ".js") {
    return getPackageType(url) === "module" ? "module" : "commonjs";
  }
  const format3 = extensionFormatMap[ext];
  if (format3)
    return format3;
  if (ignoreErrors) {
    return void 0;
  }
  throw new ERR_UNKNOWN_FILE_EXTENSION(ext, filepath);
}
function getHttpProtocolModuleFormat() {
}
function defaultGetFormatWithoutErrors(url, context) {
  if (!hasOwnProperty.call(protocolHandlers, url.protocol)) {
    return null;
  }
  return protocolHandlers[url.protocol](url, context, true) || null;
}

// node_modules/import-meta-resolve/lib/package-config.js
import { URL as URL2, fileURLToPath as fileURLToPath2 } from "url";

// node_modules/import-meta-resolve/lib/package-json-reader.js
import fs3 from "fs";
import path5 from "path";
var reader = { read };
var package_json_reader_default = reader;
function read(jsonPath) {
  try {
    const string = fs3.readFileSync(
      path5.toNamespacedPath(path5.join(path5.dirname(jsonPath), "package.json")),
      "utf8"
    );
    return { string };
  } catch (error) {
    const exception = (
      /** @type {ErrnoException} */
      error
    );
    if (exception.code === "ENOENT") {
      return { string: void 0 };
    }
    throw exception;
  }
}

// node_modules/import-meta-resolve/lib/package-config.js
var { ERR_INVALID_PACKAGE_CONFIG } = codes;
var packageJsonCache = /* @__PURE__ */ new Map();
function getPackageConfig(path11, specifier, base) {
  const existing = packageJsonCache.get(path11);
  if (existing !== void 0) {
    return existing;
  }
  const source = package_json_reader_default.read(path11).string;
  if (source === void 0) {
    const packageConfig2 = {
      pjsonPath: path11,
      exists: false,
      main: void 0,
      name: void 0,
      type: "none",
      exports: void 0,
      imports: void 0
    };
    packageJsonCache.set(path11, packageConfig2);
    return packageConfig2;
  }
  let packageJson;
  try {
    packageJson = JSON.parse(source);
  } catch (error) {
    const exception = (
      /** @type {ErrnoException} */
      error
    );
    throw new ERR_INVALID_PACKAGE_CONFIG(
      path11,
      (base ? `"${specifier}" from ` : "") + fileURLToPath2(base || specifier),
      exception.message
    );
  }
  const { exports, imports, main, name, type } = packageJson;
  const packageConfig = {
    pjsonPath: path11,
    exists: true,
    main: typeof main === "string" ? main : void 0,
    name: typeof name === "string" ? name : void 0,
    type: type === "module" || type === "commonjs" ? type : "none",
    // @ts-expect-error Assume `Record<string, unknown>`.
    exports,
    // @ts-expect-error Assume `Record<string, unknown>`.
    imports: imports && typeof imports === "object" ? imports : void 0
  };
  packageJsonCache.set(path11, packageConfig);
  return packageConfig;
}
function getPackageScopeConfig(resolved) {
  let packageJsonUrl = new URL2("package.json", resolved);
  while (true) {
    const packageJsonPath2 = packageJsonUrl.pathname;
    if (packageJsonPath2.endsWith("node_modules/package.json"))
      break;
    const packageConfig2 = getPackageConfig(
      fileURLToPath2(packageJsonUrl),
      resolved
    );
    if (packageConfig2.exists)
      return packageConfig2;
    const lastPackageJsonUrl = packageJsonUrl;
    packageJsonUrl = new URL2("../package.json", packageJsonUrl);
    if (packageJsonUrl.pathname === lastPackageJsonUrl.pathname)
      break;
  }
  const packageJsonPath = fileURLToPath2(packageJsonUrl);
  const packageConfig = {
    pjsonPath: packageJsonPath,
    exists: false,
    main: void 0,
    name: void 0,
    type: "none",
    exports: void 0,
    imports: void 0
  };
  packageJsonCache.set(packageJsonPath, packageConfig);
  return packageConfig;
}

// node_modules/import-meta-resolve/lib/utils.js
var { ERR_INVALID_ARG_VALUE } = codes;
var DEFAULT_CONDITIONS = Object.freeze(["node", "import"]);
var DEFAULT_CONDITIONS_SET = new Set(DEFAULT_CONDITIONS);
function getDefaultConditions() {
  return DEFAULT_CONDITIONS;
}
function getDefaultConditionsSet() {
  return DEFAULT_CONDITIONS_SET;
}
function getConditionsSet(conditions) {
  if (conditions !== void 0 && conditions !== getDefaultConditions()) {
    if (!Array.isArray(conditions)) {
      throw new ERR_INVALID_ARG_VALUE(
        "conditions",
        conditions,
        "expected an array"
      );
    }
    return new Set(conditions);
  }
  return getDefaultConditionsSet();
}

// node_modules/import-meta-resolve/lib/resolve.js
var RegExpPrototypeSymbolReplace = RegExp.prototype[Symbol.replace];
var experimentalNetworkImports = false;
var {
  ERR_NETWORK_IMPORT_DISALLOWED,
  ERR_INVALID_MODULE_SPECIFIER,
  ERR_INVALID_PACKAGE_CONFIG: ERR_INVALID_PACKAGE_CONFIG2,
  ERR_INVALID_PACKAGE_TARGET,
  ERR_MODULE_NOT_FOUND,
  ERR_PACKAGE_IMPORT_NOT_DEFINED,
  ERR_PACKAGE_PATH_NOT_EXPORTED,
  ERR_UNSUPPORTED_DIR_IMPORT,
  ERR_UNSUPPORTED_ESM_URL_SCHEME
} = codes;
var own2 = {}.hasOwnProperty;
var invalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\|\/|$)/i;
var deprecatedInvalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i;
var invalidPackageNameRegEx = /^\.|%|\\/;
var patternRegEx = /\*/g;
var encodedSepRegEx = /%2f|%5c/i;
var emittedPackageWarnings = /* @__PURE__ */ new Set();
var doubleSlashRegEx = /[/\\]{2}/;
function emitInvalidSegmentDeprecation(target, request, match, packageJsonUrl, internal, base, isTarget) {
  const pjsonPath = fileURLToPath3(packageJsonUrl);
  const double = doubleSlashRegEx.exec(isTarget ? target : request) !== null;
  process3.emitWarning(
    `Use of deprecated ${double ? "double slash" : "leading or trailing slash matching"} resolving "${target}" for module request "${request}" ${request === match ? "" : `matched to "${match}" `}in the "${internal ? "imports" : "exports"}" field module resolution of the package at ${pjsonPath}${base ? ` imported from ${fileURLToPath3(base)}` : ""}.`,
    "DeprecationWarning",
    "DEP0166"
  );
}
function emitLegacyIndexDeprecation(url, packageJsonUrl, base, main) {
  const format3 = defaultGetFormatWithoutErrors(url, { parentURL: base.href });
  if (format3 !== "module")
    return;
  const path11 = fileURLToPath3(url.href);
  const pkgPath = fileURLToPath3(new URL3(".", packageJsonUrl));
  const basePath = fileURLToPath3(base);
  if (main)
    process3.emitWarning(
      `Package ${pkgPath} has a "main" field set to ${JSON.stringify(main)}, excluding the full filename and extension to the resolved file at "${path11.slice(
        pkgPath.length
      )}", imported from ${basePath}.
 Automatic extension resolution of the "main" field isdeprecated for ES modules.`,
      "DeprecationWarning",
      "DEP0151"
    );
  else
    process3.emitWarning(
      `No "main" or "exports" field defined in the package.json for ${pkgPath} resolving the main entry point "${path11.slice(
        pkgPath.length
      )}", imported from ${basePath}.
Default "index" lookups for the main are deprecated for ES modules.`,
      "DeprecationWarning",
      "DEP0151"
    );
}
function tryStatSync(path11) {
  try {
    return statSync(path11);
  } catch {
    return new Stats();
  }
}
function fileExists(url) {
  const stats = statSync(url, { throwIfNoEntry: false });
  const isFile = stats ? stats.isFile() : void 0;
  return isFile === null || isFile === void 0 ? false : isFile;
}
function legacyMainResolve(packageJsonUrl, packageConfig, base) {
  let guess;
  if (packageConfig.main !== void 0) {
    guess = new URL3(packageConfig.main, packageJsonUrl);
    if (fileExists(guess))
      return guess;
    const tries2 = [
      `./${packageConfig.main}.js`,
      `./${packageConfig.main}.json`,
      `./${packageConfig.main}.node`,
      `./${packageConfig.main}/index.js`,
      `./${packageConfig.main}/index.json`,
      `./${packageConfig.main}/index.node`
    ];
    let i2 = -1;
    while (++i2 < tries2.length) {
      guess = new URL3(tries2[i2], packageJsonUrl);
      if (fileExists(guess))
        break;
      guess = void 0;
    }
    if (guess) {
      emitLegacyIndexDeprecation(
        guess,
        packageJsonUrl,
        base,
        packageConfig.main
      );
      return guess;
    }
  }
  const tries = ["./index.js", "./index.json", "./index.node"];
  let i = -1;
  while (++i < tries.length) {
    guess = new URL3(tries[i], packageJsonUrl);
    if (fileExists(guess))
      break;
    guess = void 0;
  }
  if (guess) {
    emitLegacyIndexDeprecation(guess, packageJsonUrl, base, packageConfig.main);
    return guess;
  }
  throw new ERR_MODULE_NOT_FOUND(
    fileURLToPath3(new URL3(".", packageJsonUrl)),
    fileURLToPath3(base)
  );
}
function finalizeResolution(resolved, base, preserveSymlinks) {
  if (encodedSepRegEx.exec(resolved.pathname) !== null)
    throw new ERR_INVALID_MODULE_SPECIFIER(
      resolved.pathname,
      'must not include encoded "/" or "\\" characters',
      fileURLToPath3(base)
    );
  const filePath = fileURLToPath3(resolved);
  const stats = tryStatSync(
    filePath.endsWith("/") ? filePath.slice(-1) : filePath
  );
  if (stats.isDirectory()) {
    const error = new ERR_UNSUPPORTED_DIR_IMPORT(filePath, fileURLToPath3(base));
    error.url = String(resolved);
    throw error;
  }
  if (!stats.isFile()) {
    throw new ERR_MODULE_NOT_FOUND(
      filePath || resolved.pathname,
      base && fileURLToPath3(base),
      "module"
    );
  }
  if (!preserveSymlinks) {
    const real = realpathSync(filePath);
    const { search, hash } = resolved;
    resolved = pathToFileURL(real + (filePath.endsWith(path6.sep) ? "/" : ""));
    resolved.search = search;
    resolved.hash = hash;
  }
  return resolved;
}
function importNotDefined(specifier, packageJsonUrl, base) {
  return new ERR_PACKAGE_IMPORT_NOT_DEFINED(
    specifier,
    packageJsonUrl && fileURLToPath3(new URL3(".", packageJsonUrl)),
    fileURLToPath3(base)
  );
}
function exportsNotFound(subpath, packageJsonUrl, base) {
  return new ERR_PACKAGE_PATH_NOT_EXPORTED(
    fileURLToPath3(new URL3(".", packageJsonUrl)),
    subpath,
    base && fileURLToPath3(base)
  );
}
function throwInvalidSubpath(request, match, packageJsonUrl, internal, base) {
  const reason = `request is not a valid match in pattern "${match}" for the "${internal ? "imports" : "exports"}" resolution of ${fileURLToPath3(packageJsonUrl)}`;
  throw new ERR_INVALID_MODULE_SPECIFIER(
    request,
    reason,
    base && fileURLToPath3(base)
  );
}
function invalidPackageTarget(subpath, target, packageJsonUrl, internal, base) {
  target = typeof target === "object" && target !== null ? JSON.stringify(target, null, "") : `${target}`;
  return new ERR_INVALID_PACKAGE_TARGET(
    fileURLToPath3(new URL3(".", packageJsonUrl)),
    subpath,
    target,
    internal,
    base && fileURLToPath3(base)
  );
}
function resolvePackageTargetString(target, subpath, match, packageJsonUrl, base, pattern, internal, isPathMap, conditions) {
  if (subpath !== "" && !pattern && target[target.length - 1] !== "/")
    throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
  if (!target.startsWith("./")) {
    if (internal && !target.startsWith("../") && !target.startsWith("/")) {
      let isURL = false;
      try {
        new URL3(target);
        isURL = true;
      } catch {
      }
      if (!isURL) {
        const exportTarget = pattern ? RegExpPrototypeSymbolReplace.call(
          patternRegEx,
          target,
          () => subpath
        ) : target + subpath;
        return packageResolve(exportTarget, packageJsonUrl, conditions);
      }
    }
    throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
  }
  if (invalidSegmentRegEx.exec(target.slice(2)) !== null) {
    if (deprecatedInvalidSegmentRegEx.exec(target.slice(2)) === null) {
      if (!isPathMap) {
        const request = pattern ? match.replace("*", () => subpath) : match + subpath;
        const resolvedTarget = pattern ? RegExpPrototypeSymbolReplace.call(
          patternRegEx,
          target,
          () => subpath
        ) : target;
        emitInvalidSegmentDeprecation(
          resolvedTarget,
          request,
          match,
          packageJsonUrl,
          internal,
          base,
          true
        );
      }
    } else {
      throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
    }
  }
  const resolved = new URL3(target, packageJsonUrl);
  const resolvedPath = resolved.pathname;
  const packagePath = new URL3(".", packageJsonUrl).pathname;
  if (!resolvedPath.startsWith(packagePath))
    throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
  if (subpath === "")
    return resolved;
  if (invalidSegmentRegEx.exec(subpath) !== null) {
    const request = pattern ? match.replace("*", () => subpath) : match + subpath;
    if (deprecatedInvalidSegmentRegEx.exec(subpath) === null) {
      if (!isPathMap) {
        const resolvedTarget = pattern ? RegExpPrototypeSymbolReplace.call(
          patternRegEx,
          target,
          () => subpath
        ) : target;
        emitInvalidSegmentDeprecation(
          resolvedTarget,
          request,
          match,
          packageJsonUrl,
          internal,
          base,
          false
        );
      }
    } else {
      throwInvalidSubpath(request, match, packageJsonUrl, internal, base);
    }
  }
  if (pattern) {
    return new URL3(
      RegExpPrototypeSymbolReplace.call(
        patternRegEx,
        resolved.href,
        () => subpath
      )
    );
  }
  return new URL3(subpath, resolved);
}
function isArrayIndex(key) {
  const keyNumber = Number(key);
  if (`${keyNumber}` !== key)
    return false;
  return keyNumber >= 0 && keyNumber < 4294967295;
}
function resolvePackageTarget(packageJsonUrl, target, subpath, packageSubpath, base, pattern, internal, isPathMap, conditions) {
  if (typeof target === "string") {
    return resolvePackageTargetString(
      target,
      subpath,
      packageSubpath,
      packageJsonUrl,
      base,
      pattern,
      internal,
      isPathMap,
      conditions
    );
  }
  if (Array.isArray(target)) {
    const targetList = target;
    if (targetList.length === 0)
      return null;
    let lastException;
    let i = -1;
    while (++i < targetList.length) {
      const targetItem = targetList[i];
      let resolveResult;
      try {
        resolveResult = resolvePackageTarget(
          packageJsonUrl,
          targetItem,
          subpath,
          packageSubpath,
          base,
          pattern,
          internal,
          isPathMap,
          conditions
        );
      } catch (error) {
        const exception = (
          /** @type {ErrnoException} */
          error
        );
        lastException = exception;
        if (exception.code === "ERR_INVALID_PACKAGE_TARGET")
          continue;
        throw error;
      }
      if (resolveResult === void 0)
        continue;
      if (resolveResult === null) {
        lastException = null;
        continue;
      }
      return resolveResult;
    }
    if (lastException === void 0 || lastException === null) {
      return null;
    }
    throw lastException;
  }
  if (typeof target === "object" && target !== null) {
    const keys = Object.getOwnPropertyNames(target);
    let i = -1;
    while (++i < keys.length) {
      const key = keys[i];
      if (isArrayIndex(key)) {
        throw new ERR_INVALID_PACKAGE_CONFIG2(
          fileURLToPath3(packageJsonUrl),
          base,
          '"exports" cannot contain numeric property keys.'
        );
      }
    }
    i = -1;
    while (++i < keys.length) {
      const key = keys[i];
      if (key === "default" || conditions && conditions.has(key)) {
        const conditionalTarget = (
          /** @type {unknown} */
          target[key]
        );
        const resolveResult = resolvePackageTarget(
          packageJsonUrl,
          conditionalTarget,
          subpath,
          packageSubpath,
          base,
          pattern,
          internal,
          isPathMap,
          conditions
        );
        if (resolveResult === void 0)
          continue;
        return resolveResult;
      }
    }
    return null;
  }
  if (target === null) {
    return null;
  }
  throw invalidPackageTarget(
    packageSubpath,
    target,
    packageJsonUrl,
    internal,
    base
  );
}
function isConditionalExportsMainSugar(exports, packageJsonUrl, base) {
  if (typeof exports === "string" || Array.isArray(exports))
    return true;
  if (typeof exports !== "object" || exports === null)
    return false;
  const keys = Object.getOwnPropertyNames(exports);
  let isConditionalSugar = false;
  let i = 0;
  let j = -1;
  while (++j < keys.length) {
    const key = keys[j];
    const curIsConditionalSugar = key === "" || key[0] !== ".";
    if (i++ === 0) {
      isConditionalSugar = curIsConditionalSugar;
    } else if (isConditionalSugar !== curIsConditionalSugar) {
      throw new ERR_INVALID_PACKAGE_CONFIG2(
        fileURLToPath3(packageJsonUrl),
        base,
        `"exports" cannot contain some keys starting with '.' and some not. The exports object must either be an object of package subpath keys or an object of main entry condition name keys only.`
      );
    }
  }
  return isConditionalSugar;
}
function emitTrailingSlashPatternDeprecation(match, pjsonUrl, base) {
  const pjsonPath = fileURLToPath3(pjsonUrl);
  if (emittedPackageWarnings.has(pjsonPath + "|" + match))
    return;
  emittedPackageWarnings.add(pjsonPath + "|" + match);
  process3.emitWarning(
    `Use of deprecated trailing slash pattern mapping "${match}" in the "exports" field module resolution of the package at ${pjsonPath}${base ? ` imported from ${fileURLToPath3(base)}` : ""}. Mapping specifiers ending in "/" is no longer supported.`,
    "DeprecationWarning",
    "DEP0155"
  );
}
function packageExportsResolve(packageJsonUrl, packageSubpath, packageConfig, base, conditions) {
  let exports = packageConfig.exports;
  if (isConditionalExportsMainSugar(exports, packageJsonUrl, base)) {
    exports = { ".": exports };
  }
  if (own2.call(exports, packageSubpath) && !packageSubpath.includes("*") && !packageSubpath.endsWith("/")) {
    const target = exports[packageSubpath];
    const resolveResult = resolvePackageTarget(
      packageJsonUrl,
      target,
      "",
      packageSubpath,
      base,
      false,
      false,
      false,
      conditions
    );
    if (resolveResult === null || resolveResult === void 0) {
      throw exportsNotFound(packageSubpath, packageJsonUrl, base);
    }
    return resolveResult;
  }
  let bestMatch = "";
  let bestMatchSubpath = "";
  const keys = Object.getOwnPropertyNames(exports);
  let i = -1;
  while (++i < keys.length) {
    const key = keys[i];
    const patternIndex = key.indexOf("*");
    if (patternIndex !== -1 && packageSubpath.startsWith(key.slice(0, patternIndex))) {
      if (packageSubpath.endsWith("/")) {
        emitTrailingSlashPatternDeprecation(
          packageSubpath,
          packageJsonUrl,
          base
        );
      }
      const patternTrailer = key.slice(patternIndex + 1);
      if (packageSubpath.length >= key.length && packageSubpath.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && key.lastIndexOf("*") === patternIndex) {
        bestMatch = key;
        bestMatchSubpath = packageSubpath.slice(
          patternIndex,
          packageSubpath.length - patternTrailer.length
        );
      }
    }
  }
  if (bestMatch) {
    const target = (
      /** @type {unknown} */
      exports[bestMatch]
    );
    const resolveResult = resolvePackageTarget(
      packageJsonUrl,
      target,
      bestMatchSubpath,
      bestMatch,
      base,
      true,
      false,
      packageSubpath.endsWith("/"),
      conditions
    );
    if (resolveResult === null || resolveResult === void 0) {
      throw exportsNotFound(packageSubpath, packageJsonUrl, base);
    }
    return resolveResult;
  }
  throw exportsNotFound(packageSubpath, packageJsonUrl, base);
}
function patternKeyCompare(a, b) {
  const aPatternIndex = a.indexOf("*");
  const bPatternIndex = b.indexOf("*");
  const baseLengthA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;
  const baseLengthB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;
  if (baseLengthA > baseLengthB)
    return -1;
  if (baseLengthB > baseLengthA)
    return 1;
  if (aPatternIndex === -1)
    return 1;
  if (bPatternIndex === -1)
    return -1;
  if (a.length > b.length)
    return -1;
  if (b.length > a.length)
    return 1;
  return 0;
}
function packageImportsResolve(name, base, conditions) {
  if (name === "#" || name.startsWith("#/") || name.endsWith("/")) {
    const reason = "is not a valid internal imports specifier name";
    throw new ERR_INVALID_MODULE_SPECIFIER(name, reason, fileURLToPath3(base));
  }
  let packageJsonUrl;
  const packageConfig = getPackageScopeConfig(base);
  if (packageConfig.exists) {
    packageJsonUrl = pathToFileURL(packageConfig.pjsonPath);
    const imports = packageConfig.imports;
    if (imports) {
      if (own2.call(imports, name) && !name.includes("*")) {
        const resolveResult = resolvePackageTarget(
          packageJsonUrl,
          imports[name],
          "",
          name,
          base,
          false,
          true,
          false,
          conditions
        );
        if (resolveResult !== null && resolveResult !== void 0) {
          return resolveResult;
        }
      } else {
        let bestMatch = "";
        let bestMatchSubpath = "";
        const keys = Object.getOwnPropertyNames(imports);
        let i = -1;
        while (++i < keys.length) {
          const key = keys[i];
          const patternIndex = key.indexOf("*");
          if (patternIndex !== -1 && name.startsWith(key.slice(0, -1))) {
            const patternTrailer = key.slice(patternIndex + 1);
            if (name.length >= key.length && name.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && key.lastIndexOf("*") === patternIndex) {
              bestMatch = key;
              bestMatchSubpath = name.slice(
                patternIndex,
                name.length - patternTrailer.length
              );
            }
          }
        }
        if (bestMatch) {
          const target = imports[bestMatch];
          const resolveResult = resolvePackageTarget(
            packageJsonUrl,
            target,
            bestMatchSubpath,
            bestMatch,
            base,
            true,
            true,
            false,
            conditions
          );
          if (resolveResult !== null && resolveResult !== void 0) {
            return resolveResult;
          }
        }
      }
    }
  }
  throw importNotDefined(name, packageJsonUrl, base);
}
function getPackageType(url) {
  const packageConfig = getPackageScopeConfig(url);
  return packageConfig.type;
}
function parsePackageName(specifier, base) {
  let separatorIndex = specifier.indexOf("/");
  let validPackageName = true;
  let isScoped = false;
  if (specifier[0] === "@") {
    isScoped = true;
    if (separatorIndex === -1 || specifier.length === 0) {
      validPackageName = false;
    } else {
      separatorIndex = specifier.indexOf("/", separatorIndex + 1);
    }
  }
  const packageName = separatorIndex === -1 ? specifier : specifier.slice(0, separatorIndex);
  if (invalidPackageNameRegEx.exec(packageName) !== null) {
    validPackageName = false;
  }
  if (!validPackageName) {
    throw new ERR_INVALID_MODULE_SPECIFIER(
      specifier,
      "is not a valid package name",
      fileURLToPath3(base)
    );
  }
  const packageSubpath = "." + (separatorIndex === -1 ? "" : specifier.slice(separatorIndex));
  return { packageName, packageSubpath, isScoped };
}
function packageResolve(specifier, base, conditions) {
  if (builtinModules.includes(specifier)) {
    return new URL3("node:" + specifier);
  }
  const { packageName, packageSubpath, isScoped } = parsePackageName(
    specifier,
    base
  );
  const packageConfig = getPackageScopeConfig(base);
  if (packageConfig.exists) {
    const packageJsonUrl2 = pathToFileURL(packageConfig.pjsonPath);
    if (packageConfig.name === packageName && packageConfig.exports !== void 0 && packageConfig.exports !== null) {
      return packageExportsResolve(
        packageJsonUrl2,
        packageSubpath,
        packageConfig,
        base,
        conditions
      );
    }
  }
  let packageJsonUrl = new URL3(
    "./node_modules/" + packageName + "/package.json",
    base
  );
  let packageJsonPath = fileURLToPath3(packageJsonUrl);
  let lastPath;
  do {
    const stat = tryStatSync(packageJsonPath.slice(0, -13));
    if (!stat.isDirectory()) {
      lastPath = packageJsonPath;
      packageJsonUrl = new URL3(
        (isScoped ? "../../../../node_modules/" : "../../../node_modules/") + packageName + "/package.json",
        packageJsonUrl
      );
      packageJsonPath = fileURLToPath3(packageJsonUrl);
      continue;
    }
    const packageConfig2 = getPackageConfig(packageJsonPath, specifier, base);
    if (packageConfig2.exports !== void 0 && packageConfig2.exports !== null) {
      return packageExportsResolve(
        packageJsonUrl,
        packageSubpath,
        packageConfig2,
        base,
        conditions
      );
    }
    if (packageSubpath === ".") {
      return legacyMainResolve(packageJsonUrl, packageConfig2, base);
    }
    return new URL3(packageSubpath, packageJsonUrl);
  } while (packageJsonPath.length !== lastPath.length);
  throw new ERR_MODULE_NOT_FOUND(packageName, fileURLToPath3(base));
}
function isRelativeSpecifier(specifier) {
  if (specifier[0] === ".") {
    if (specifier.length === 1 || specifier[1] === "/")
      return true;
    if (specifier[1] === "." && (specifier.length === 2 || specifier[2] === "/")) {
      return true;
    }
  }
  return false;
}
function shouldBeTreatedAsRelativeOrAbsolutePath(specifier) {
  if (specifier === "")
    return false;
  if (specifier[0] === "/")
    return true;
  return isRelativeSpecifier(specifier);
}
function moduleResolve(specifier, base, conditions, preserveSymlinks) {
  const isRemote = base.protocol === "http:" || base.protocol === "https:";
  let resolved;
  if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {
    resolved = new URL3(specifier, base);
  } else if (!isRemote && specifier[0] === "#") {
    resolved = packageImportsResolve(specifier, base, conditions);
  } else {
    try {
      resolved = new URL3(specifier);
    } catch {
      if (!isRemote) {
        resolved = packageResolve(specifier, base, conditions);
      }
    }
  }
  assert4(typeof resolved !== "undefined", "expected to be defined");
  if (resolved.protocol !== "file:") {
    return resolved;
  }
  return finalizeResolution(resolved, base, preserveSymlinks);
}
function checkIfDisallowedImport(specifier, parsed, parsedParentURL) {
  if (parsed && parsedParentURL && (parsedParentURL.protocol === "http:" || parsedParentURL.protocol === "https:")) {
    if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {
      if (parsed && parsed.protocol !== "https:" && parsed.protocol !== "http:") {
        throw new ERR_NETWORK_IMPORT_DISALLOWED(
          specifier,
          parsedParentURL,
          "remote imports cannot import from a local location."
        );
      }
      return { url: parsed.href };
    }
    if (builtinModules.includes(specifier)) {
      throw new ERR_NETWORK_IMPORT_DISALLOWED(
        specifier,
        parsedParentURL,
        "remote imports cannot import from a local location."
      );
    }
    throw new ERR_NETWORK_IMPORT_DISALLOWED(
      specifier,
      parsedParentURL,
      "only relative and absolute specifiers are supported."
    );
  }
}
function throwIfUnsupportedURLProtocol(url) {
  if (url.protocol !== "file:" && url.protocol !== "data:" && url.protocol !== "node:") {
    throw new ERR_UNSUPPORTED_ESM_URL_SCHEME(url);
  }
}
function throwIfUnsupportedURLScheme(parsed, experimentalNetworkImports2) {
  if (parsed && parsed.protocol !== "file:" && parsed.protocol !== "data:" && (!experimentalNetworkImports2 || parsed.protocol !== "https:" && parsed.protocol !== "http:")) {
    throw new ERR_UNSUPPORTED_ESM_URL_SCHEME(
      parsed,
      ["file", "data"].concat(
        experimentalNetworkImports2 ? ["https", "http"] : []
      )
    );
  }
}
function defaultResolve(specifier, context = {}) {
  const { parentURL } = context;
  assert4(typeof parentURL !== "undefined", "expected `parentURL` to be defined");
  let parsedParentURL;
  if (parentURL) {
    try {
      parsedParentURL = new URL3(parentURL);
    } catch {
    }
  }
  let parsed;
  try {
    parsed = shouldBeTreatedAsRelativeOrAbsolutePath(specifier) ? new URL3(specifier, parsedParentURL) : new URL3(specifier);
    if (parsed.protocol === "data:" || experimentalNetworkImports && (parsed.protocol === "https:" || parsed.protocol === "http:")) {
      return { url: parsed.href, format: null };
    }
  } catch {
  }
  const maybeReturn = checkIfDisallowedImport(
    specifier,
    parsed,
    parsedParentURL
  );
  if (maybeReturn)
    return maybeReturn;
  if (parsed && parsed.protocol === "node:")
    return { url: specifier };
  throwIfUnsupportedURLScheme(parsed, experimentalNetworkImports);
  const conditions = getConditionsSet(context.conditions);
  const url = moduleResolve(specifier, new URL3(parentURL), conditions, false);
  throwIfUnsupportedURLProtocol(url);
  return {
    // Do NOT cast `url` to a string: that will work even when there are real
    // problems, silencing them
    url: url.href,
    format: defaultGetFormatWithoutErrors(url, { parentURL })
  };
}

// node_modules/import-meta-resolve/index.js
async function resolve(specifier, parent) {
  if (!parent) {
    throw new Error(
      "Please pass `parent`: `import-meta-resolve` cannot ponyfill that"
    );
  }
  try {
    return defaultResolve(specifier, { parentURL: parent }).url;
  } catch (error) {
    const exception = (
      /** @type {ErrnoException} */
      error
    );
    return exception.code === "ERR_UNSUPPORTED_DIR_IMPORT" && typeof exception.url === "string" ? exception.url : Promise.reject(error);
  }
}

// src/utils/import-from-file.js
async function importFromFile(specifier, parent) {
  const url = await resolve(specifier, pathToFileURL2(parent).href);
  return import(url);
}
var import_from_file_default = importFromFile;

// src/config/load-external-config.js
async function loadExternalConfig(config, filepath) {
  try {
    return require_from_file_default(config, filepath);
  } catch (error) {
    if ((error == null ? void 0 : error.code) !== "MODULE_NOT_FOUND" && (error == null ? void 0 : error.code) !== "ERR_REQUIRE_ESM") {
      throw error;
    }
  }
  const module = await import_from_file_default(config, filepath);
  return module.default;
}
var load_external_config_default = loadExternalConfig;

// src/config/get-prettier-config-explorer.js
var { cosmiconfig } = thirdParty;
var searchPlaces = [
  "package.json",
  ".prettierrc",
  ".prettierrc.json",
  ".prettierrc.yaml",
  ".prettierrc.yml",
  ".prettierrc.json5",
  ".prettierrc.js",
  ".prettierrc.mjs",
  ".prettierrc.cjs",
  "prettier.config.js",
  "prettier.config.mjs",
  "prettier.config.cjs",
  ".prettierrc.toml"
];
async function loadJs(filepath) {
  const module = await import(pathToFileURL3(filepath).href);
  return module.default;
}
var loaders = {
  async ".toml"(filePath, content) {
    try {
      return await (0, import_parse_async.default)(content);
    } catch (error) {
      error.message = `TOML Error in ${filePath}:
${error.message}`;
      throw error;
    }
  },
  ".json5"(filePath, content) {
    try {
      return (0, import_parse.default)(content);
    } catch (error) {
      error.message = `JSON5 Error in ${filePath}:
${error.message}`;
      throw error;
    }
  },
  ".js": loadJs,
  ".mjs": loadJs,
  ".cjs": loadJs
};
async function transform(result) {
  if (!(result == null ? void 0 : result.config)) {
    return result;
  }
  let { config, filepath } = result;
  if (typeof config === "string") {
    config = await load_external_config_default(config, filepath);
    result.config = config;
  }
  if (typeof config !== "object") {
    throw new TypeError(
      `Config is only allowed to be an object, but received ${typeof config} in "${filepath}"`
    );
  }
  delete config.$schema;
  return result;
}
function getExplorer(options9) {
  return cosmiconfig("prettier", {
    cache: options9.cache,
    transform,
    searchPlaces,
    loaders
  });
}
var get_prettier_config_explorer_default = getExplorer;

// src/config/resolve-config.js
var getPrettierConfigExplorer = mem(get_prettier_config_explorer_default, {
  cacheKey: ([options9]) => options9.cache
});
var memoizedLoadEditorConfig = mem(resolve_editorconfig_default);
function clearCache() {
  memClear(getPrettierConfigExplorer);
  memClear(memoizedLoadEditorConfig);
}
function loadEditorConfig2(filePath, options9) {
  if (!filePath || !options9.editorconfig) {
    return;
  }
  return (options9.useCache ? memoizedLoadEditorConfig : resolve_editorconfig_default)(filePath);
}
function loadPrettierConfig(filePath, options9) {
  const { useCache, config: configPath } = options9;
  const { load: load2, search } = getPrettierConfigExplorer({
    cache: Boolean(useCache)
  });
  return configPath ? load2(configPath) : search(filePath);
}
async function resolveConfig(filePath, options9) {
  options9 = { useCache: true, ...options9 };
  const [result, editorConfigured] = await Promise.all([
    loadPrettierConfig(filePath, options9),
    loadEditorConfig2(filePath, options9)
  ]);
  if (!result && !editorConfigured) {
    return null;
  }
  const merged = {
    ...editorConfigured,
    ...mergeOverrides(result, filePath)
  };
  for (const optionName of ["plugins", "pluginSearchDirs"]) {
    if (Array.isArray(merged[optionName])) {
      merged[optionName] = merged[optionName].map(
        (value) => typeof value === "string" && value.startsWith(".") ? path7.resolve(path7.dirname(result.filepath), value) : value
      );
    }
  }
  return merged;
}
async function resolveConfigFile(filePath) {
  const { search } = getPrettierConfigExplorer({ cache: false });
  const result = await search(filePath);
  return result ? result.filepath : null;
}
function mergeOverrides(configResult, filePath) {
  const { config, filepath: configPath } = configResult || {};
  const { overrides, ...options9 } = config || {};
  if (filePath && overrides) {
    const relativeFilePath = path7.relative(path7.dirname(configPath), filePath);
    for (const override of overrides) {
      if (pathMatchesGlobs(
        relativeFilePath,
        override.files,
        override.excludeFiles
      )) {
        Object.assign(options9, override.options);
      }
    }
  }
  return options9;
}
function pathMatchesGlobs(filePath, patterns, excludedPatterns) {
  const patternList = Array.isArray(patterns) ? patterns : [patterns];
  const [withSlashes, withoutSlashes] = partition_default(
    patternList,
    (pattern) => pattern.includes("/")
  );
  return import_micromatch.default.isMatch(filePath, withoutSlashes, {
    ignore: excludedPatterns,
    basename: true,
    dot: true
  }) || import_micromatch.default.isMatch(filePath, withSlashes, {
    ignore: excludedPatterns,
    basename: false,
    dot: true
  });
}

// src/utils/ignore.js
var import_ignore = __toESM(require_ignore(), 1);
import path8 from "path";

// src/utils/read-file.js
import fs4 from "fs/promises";
async function readFile(filename) {
  try {
    return await fs4.readFile(filename, "utf8");
  } catch (error) {
    if (error.code === "ENOENT") {
      return;
    }
    throw new Error(`Unable to read '${filename}': ${error.message}`);
  }
}
var read_file_default = readFile;

// src/utils/ignore.js
var createIgnore = import_ignore.default.default;
var slash = path8.sep === "\\" ? (filepath) => string_replace_all_default(
  /* isOptionalObject*/
  false,
  filepath,
  "\\",
  "/"
) : (filepath) => filepath;
async function createIsIgnoredFunction(ignoreFilePath, withNodeModules) {
  let content = "";
  if (ignoreFilePath) {
    content += await read_file_default(ignoreFilePath) ?? "";
  }
  if (!withNodeModules) {
    content += "\nnode_modules";
  }
  if (!content) {
    return () => false;
  }
  const ignore = createIgnore({
    allowRelativePaths: true
  }).add(content);
  return (filepath) => {
    filepath = path8.resolve(filepath);
    const relativePath = ignoreFilePath ? path8.relative(path8.dirname(ignoreFilePath), filepath) : path8.relative(process.cwd(), filepath);
    return ignore.ignores(slash(relativePath));
  };
}
async function isIgnored(filepath, options9) {
  const {
    ignorePath,
    withNodeModules
  } = options9;
  const isIgnored2 = await createIsIgnoredFunction(ignorePath, withNodeModules);
  return isIgnored2(filepath);
}

// src/common/get-file-info.js
async function getFileInfo(filePath, options9) {
  if (typeof filePath !== "string") {
    throw new TypeError(
      `expect \`filePath\` to be a string, got \`${typeof filePath}\``
    );
  }
  const ignored = await isIgnored(filePath, options9);
  let inferredParser;
  if (!ignored) {
    inferredParser = await getParser(filePath, options9);
  }
  return {
    ignored,
    inferredParser: inferredParser ?? null
  };
}
async function getParser(filePath, options9) {
  let config;
  if (options9.resolveConfig !== false) {
    config = await resolveConfig(filePath);
  }
  return (config == null ? void 0 : config.parser) ?? infer_parser_default(filePath, options9.plugins);
}
var get_file_info_default = getFileInfo;

// src/common/load-plugins.js
var import_fast_glob = __toESM(require_out4(), 1);
import fs5 from "fs/promises";
import path10 from "path";
import { fileURLToPath as fileURLToPath4, pathToFileURL as pathToFileURL4 } from "url";

// src/utils/import-from-directory.js
import path9 from "path";
function importFromDirectory(specifier, directory) {
  return import_from_file_default(specifier, path9.join(directory, "noop.js"));
}
var import_from_directory_default = importFromDirectory;

// src/common/load-plugins.js
import thirdParty2 from "./internal/third-party.mjs";
var importPlugin = async (name, directory) => {
  const module = await import_from_directory_default(name, directory);
  const plugin = module.default ?? module;
  return { name, ...plugin };
};
var memoizedLoad = mem(load, { cacheKey: JSON.stringify });
var memoizedSearch = mem(findPluginsInNodeModules);
var clearCache2 = () => {
  memClear(memoizedLoad);
  memClear(memoizedSearch);
};
async function load(plugins, pluginSearchDirs) {
  plugins ?? (plugins = []);
  if (pluginSearchDirs === false) {
    pluginSearchDirs = [];
  } else {
    pluginSearchDirs ?? (pluginSearchDirs = []);
    if (pluginSearchDirs.length === 0) {
      const autoLoadDir = thirdParty2.findParentDir(__dirname, "node_modules");
      if (autoLoadDir) {
        pluginSearchDirs = [autoLoadDir];
      }
    }
  }
  const [externalPluginNames, externalPluginInstances] = partition_default(
    plugins,
    (plugin) => typeof plugin === "string"
  );
  const externalManualLoadPlugins = await Promise.all(
    externalPluginNames.map(async (name) => {
      try {
        const module = await import(pathToFileURL4(path10.resolve(name)).href);
        const plugin = module.default ?? module;
        return { name, ...plugin };
      } catch {
        return importPlugin(name, process.cwd());
      }
    })
  );
  const externalAutoLoadPlugins = (await Promise.all(
    pluginSearchDirs.map(async (pluginSearchDir) => {
      const resolvedPluginSearchDir = path10.resolve(
        process.cwd(),
        pluginSearchDir
      );
      const nodeModulesDir = path10.resolve(
        resolvedPluginSearchDir,
        "node_modules"
      );
      if (!await isDirectory(nodeModulesDir) && !await isDirectory(resolvedPluginSearchDir)) {
        throw new Error(
          `${pluginSearchDir} does not exist or is not a directory`
        );
      }
      const pluginNames = await memoizedSearch(nodeModulesDir);
      return Promise.all(
        pluginNames.map((name) => importPlugin(name, nodeModulesDir))
      );
    })
  )).flat();
  return [
    ...externalManualLoadPlugins,
    ...externalAutoLoadPlugins,
    ...externalPluginInstances
  ];
}
async function findPluginsInNodeModules(nodeModulesDir) {
  const pluginPackageJsonPaths = await (0, import_fast_glob.default)(
    [
      "prettier-plugin-*/package.json",
      "@*/prettier-plugin-*/package.json",
      "@prettier/plugin-*/package.json"
    ],
    {
      cwd: nodeModulesDir
    }
  );
  return pluginPackageJsonPaths.map(path10.dirname);
}
async function isDirectory(dir) {
  let stat;
  try {
    stat = await fs5.stat(dir);
  } catch {
    return false;
  }
  return stat.isDirectory();
}

// src/languages.js
var languages_exports = {};
__export(languages_exports, {
  css: () => language_css_exports,
  graphql: () => language_graphql_exports,
  handlebars: () => language_handlebars_exports,
  html: () => language_html_exports,
  js: () => language_js_exports,
  json: () => language_json_exports,
  markdown: () => language_markdown_exports,
  yaml: () => language_yaml_exports
});

// src/language-js/index.js
var language_js_exports = {};
__export(language_js_exports, {
  languages: () => languages_evaluate_default,
  options: () => options_default,
  parsers: () => parsers2,
  printers: () => printers
});

// src/utils/create-parsers.js
var createParsers = false ? () => {
} : function(modules) {
  const parsers15 = /* @__PURE__ */ Object.create(null);
  for (const { importPlugin: importPlugin2, parserNames } of modules) {
    for (const parserName of parserNames) {
      parsers15[parserName] = async () => {
        const {
          default: { parsers: pluginParsers }
        } = await importPlugin2();
        return Object.assign(parsers15, pluginParsers)[parserName];
      };
    }
  }
  return parsers15;
};
var create_parsers_default = createParsers;

// src/language-js/parse/parsers.js
var parsers = [
  {
    importPlugin: () => import("./plugins/babel.mjs"),
    parserNames: [
      "babel",
      "babel-flow",
      "babel-ts",
      "json",
      "json5",
      "json-stringify",
      "__js_expression",
      "__vue_expression",
      "__vue_ts_expression",
      "__vue_event_binding",
      "__vue_ts_event_binding",
      "__babel_estree"
    ]
  },
  {
    importPlugin: () => import("./plugins/flow.mjs"),
    parserNames: ["flow"]
  },
  {
    importPlugin: () => import("./plugins/typescript.mjs"),
    parserNames: ["typescript"]
  },
  {
    importPlugin: () => import("./plugins/angular.mjs"),
    parserNames: [
      "__ng_action",
      "__ng_binding",
      "__ng_interpolation",
      "__ng_directive"
    ]
  },
  {
    importPlugin: () => import("./plugins/acorn-and-espree.mjs"),
    parserNames: ["acorn", "espree"]
  },
  {
    importPlugin: () => import("./plugins/meriyah.mjs"),
    parserNames: ["meriyah"]
  }
];
var parsers_default = parsers;

// src/utils/unexpected-node-error.js
var UnexpectedNodeError = class extends Error {
  name = "UnexpectedNodeError";
  constructor(node, language, typeProperty = "type") {
    super(
      `Unexpected ${language} node ${typeProperty}: ${JSON.stringify(
        node[typeProperty]
      )}.`
    );
    this.node = node;
  }
};
var unexpected_node_error_default = UnexpectedNodeError;

// node_modules/@prettier/is-es5-identifier-name/dist/index.js
var regexp_default = /^[\$A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC][\$0-9A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]*$/;
var isEs5IdentifierName = (id) => regexp_default.test(id);
var src_default = isEs5IdentifierName;

// src/utils/skip-inline-comment.js
function skipInlineComment(text, startIndex) {
  if (startIndex === false) {
    return false;
  }
  if (text.charAt(startIndex) === "/" && text.charAt(startIndex + 1) === "*") {
    for (let i = startIndex + 2; i < text.length; ++i) {
      if (text.charAt(i) === "*" && text.charAt(i + 1) === "/") {
        return i + 2;
      }
    }
  }
  return startIndex;
}
var skip_inline_comment_default = skipInlineComment;

// src/utils/skip-trailing-comment.js
function skipTrailingComment(text, startIndex) {
  if (startIndex === false) {
    return false;
  }
  if (text.charAt(startIndex) === "/" && text.charAt(startIndex + 1) === "/") {
    return skipEverythingButNewLine(text, startIndex);
  }
  return startIndex;
}
var skip_trailing_comment_default = skipTrailingComment;

// src/utils/is-next-line-empty.js
function isNextLineEmpty(text, startIndex) {
  let oldIdx = null;
  let idx = startIndex;
  while (idx !== oldIdx) {
    oldIdx = idx;
    idx = skipToLineEnd(text, idx);
    idx = skip_inline_comment_default(text, idx);
    idx = skipSpaces(text, idx);
  }
  idx = skip_trailing_comment_default(text, idx);
  idx = skip_newline_default(text, idx);
  return idx !== false && has_newline_default(text, idx);
}
var is_next_line_empty_default = isNextLineEmpty;

// node_modules/strip-ansi/node_modules/ansi-regex/index.js
function ansiRegex({ onlyFirst = false } = {}) {
  const pattern = [
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
  ].join("|");
  return new RegExp(pattern, onlyFirst ? void 0 : "g");
}

// node_modules/strip-ansi/index.js
function stripAnsi(string) {
  if (typeof string !== "string") {
    throw new TypeError(`Expected a \`string\`, got \`${typeof string}\``);
  }
  return string.replace(ansiRegex(), "");
}

// node_modules/string-width/node_modules/is-fullwidth-code-point/index.js
function isFullwidthCodePoint(codePoint) {
  if (!Number.isInteger(codePoint)) {
    return false;
  }
  return codePoint >= 4352 && (codePoint <= 4447 || // Hangul Jamo
  codePoint === 9001 || // LEFT-POINTING ANGLE BRACKET
  codePoint === 9002 || // RIGHT-POINTING ANGLE BRACKET
  // CJK Radicals Supplement .. Enclosed CJK Letters and Months
  11904 <= codePoint && codePoint <= 12871 && codePoint !== 12351 || // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
  12880 <= codePoint && codePoint <= 19903 || // CJK Unified Ideographs .. Yi Radicals
  19968 <= codePoint && codePoint <= 42182 || // Hangul Jamo Extended-A
  43360 <= codePoint && codePoint <= 43388 || // Hangul Syllables
  44032 <= codePoint && codePoint <= 55203 || // CJK Compatibility Ideographs
  63744 <= codePoint && codePoint <= 64255 || // Vertical Forms
  65040 <= codePoint && codePoint <= 65049 || // CJK Compatibility Forms .. Small Form Variants
  65072 <= codePoint && codePoint <= 65131 || // Halfwidth and Fullwidth Forms
  65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 || // Kana Supplement
  110592 <= codePoint && codePoint <= 110593 || // Enclosed Ideographic Supplement
  127488 <= codePoint && codePoint <= 127569 || // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
  131072 <= codePoint && codePoint <= 262141);
}

// node_modules/string-width/index.js
var import_emoji_regex = __toESM(require_emoji_regex(), 1);
function stringWidth(string) {
  if (typeof string !== "string" || string.length === 0) {
    return 0;
  }
  string = stripAnsi(string);
  if (string.length === 0) {
    return 0;
  }
  string = string.replace((0, import_emoji_regex.default)(), "  ");
  let width = 0;
  for (let index = 0; index < string.length; index++) {
    const codePoint = string.codePointAt(index);
    if (codePoint <= 31 || codePoint >= 127 && codePoint <= 159) {
      continue;
    }
    if (codePoint >= 768 && codePoint <= 879) {
      continue;
    }
    if (codePoint > 65535) {
      index++;
    }
    width += isFullwidthCodePoint(codePoint) ? 2 : 1;
  }
  return width;
}

// src/utils/get-string-width.js
var notAsciiRegex = /[^\x20-\x7F]/;
function getStringWidth(text) {
  if (!text) {
    return 0;
  }
  if (!notAsciiRegex.test(text)) {
    return text.length;
  }
  return stringWidth(text);
}
var get_string_width_default = getStringWidth;

// src/language-js/loc.js
function locStart(node) {
  var _a;
  const start = node.range ? node.range[0] : node.start;
  const decorators = ((_a = node.declaration) == null ? void 0 : _a.decorators) ?? node.decorators;
  if (is_non_empty_array_default(decorators)) {
    return Math.min(locStart(decorators[0]), start);
  }
  return start;
}
function locEnd(node) {
  return node.range ? node.range[1] : node.end;
}
function hasSameLocStart(nodeA, nodeB) {
  const nodeAStart = locStart(nodeA);
  return Number.isInteger(nodeAStart) && nodeAStart === locStart(nodeB);
}
function hasSameLocEnd(nodeA, nodeB) {
  const nodeAEnd = locEnd(nodeA);
  return Number.isInteger(nodeAEnd) && nodeAEnd === locEnd(nodeB);
}
function hasSameLoc(nodeA, nodeB) {
  return hasSameLocStart(nodeA, nodeB) && hasSameLocEnd(nodeA, nodeB);
}

// node_modules/to-fast-properties/index.js
var fastProto = null;
function FastObject(object) {
  if (fastProto !== null && typeof fastProto.property) {
    const result = fastProto;
    fastProto = FastObject.prototype = null;
    return result;
  }
  fastProto = FastObject.prototype = object == null ? /* @__PURE__ */ Object.create(null) : object;
  return new FastObject();
}
var inlineCacheCutoff = 10;
for (let index = 0; index <= inlineCacheCutoff; index++) {
  FastObject();
}
function toFastproperties(object) {
  return FastObject(object);
}

// src/utils/create-get-visitor-keys.js
function createGetVisitorKeys(visitorKeys6, typeProperty = "type") {
  toFastproperties(visitorKeys6);
  function getVisitorKeys9(node) {
    const type = node[typeProperty];
    if (false) {
      throw new Error(
        `Can't get node type, you must pass the wrong typeProperty '${typeProperty}'`
      );
    }
    const keys = visitorKeys6[type];
    if (!Array.isArray(keys)) {
      throw Object.assign(new Error(`Missing visitor keys for '${type}'.`), {
        node
      });
    }
    return keys;
  }
  return getVisitorKeys9;
}
var create_get_visitor_keys_default = createGetVisitorKeys;

// src/language-js/traverse/visitor-keys.evaluate.js
var visitor_keys_evaluate_default = {
  "ArrayExpression": [
    "elements"
  ],
  "AssignmentExpression": [
    "left",
    "right"
  ],
  "BinaryExpression": [
    "left",
    "right"
  ],
  "InterpreterDirective": [],
  "Directive": [
    "value"
  ],
  "DirectiveLiteral": [],
  "BlockStatement": [
    "directives",
    "body"
  ],
  "BreakStatement": [
    "label"
  ],
  "CallExpression": [
    "callee",
    "arguments",
    "typeParameters",
    "typeArguments"
  ],
  "CatchClause": [
    "param",
    "body"
  ],
  "ConditionalExpression": [
    "test",
    "consequent",
    "alternate"
  ],
  "ContinueStatement": [
    "label"
  ],
  "DebuggerStatement": [],
  "DoWhileStatement": [
    "test",
    "body"
  ],
  "EmptyStatement": [],
  "ExpressionStatement": [
    "expression"
  ],
  "File": [
    "program"
  ],
  "ForInStatement": [
    "left",
    "right",
    "body"
  ],
  "ForStatement": [
    "init",
    "test",
    "update",
    "body"
  ],
  "FunctionDeclaration": [
    "id",
    "params",
    "body",
    "returnType",
    "typeParameters",
    "predicate"
  ],
  "FunctionExpression": [
    "id",
    "params",
    "body",
    "returnType",
    "typeParameters"
  ],
  "Identifier": [
    "typeAnnotation",
    "decorators"
  ],
  "IfStatement": [
    "test",
    "consequent",
    "alternate"
  ],
  "LabeledStatement": [
    "label",
    "body"
  ],
  "StringLiteral": [],
  "NumericLiteral": [],
  "NullLiteral": [],
  "BooleanLiteral": [],
  "RegExpLiteral": [],
  "LogicalExpression": [
    "left",
    "right"
  ],
  "MemberExpression": [
    "object",
    "property"
  ],
  "NewExpression": [
    "callee",
    "arguments",
    "typeParameters",
    "typeArguments"
  ],
  "Program": [
    "directives",
    "body"
  ],
  "ObjectExpression": [
    "properties"
  ],
  "ObjectMethod": [
    "key",
    "params",
    "body",
    "decorators",
    "returnType",
    "typeParameters"
  ],
  "ObjectProperty": [
    "key",
    "value",
    "decorators"
  ],
  "RestElement": [
    "argument",
    "typeAnnotation",
    "decorators"
  ],
  "ReturnStatement": [
    "argument"
  ],
  "SequenceExpression": [
    "expressions"
  ],
  "ParenthesizedExpression": [
    "expression"
  ],
  "SwitchCase": [
    "test",
    "consequent"
  ],
  "SwitchStatement": [
    "discriminant",
    "cases"
  ],
  "ThisExpression": [],
  "ThrowStatement": [
    "argument"
  ],
  "TryStatement": [
    "block",
    "handler",
    "finalizer"
  ],
  "UnaryExpression": [
    "argument"
  ],
  "UpdateExpression": [
    "argument"
  ],
  "VariableDeclaration": [
    "declarations"
  ],
  "VariableDeclarator": [
    "id",
    "init"
  ],
  "WhileStatement": [
    "test",
    "body"
  ],
  "WithStatement": [
    "object",
    "body"
  ],
  "AssignmentPattern": [
    "left",
    "right",
    "decorators",
    "typeAnnotation"
  ],
  "ArrayPattern": [
    "elements",
    "typeAnnotation",
    "decorators"
  ],
  "ArrowFunctionExpression": [
    "params",
    "body",
    "returnType",
    "typeParameters",
    "predicate"
  ],
  "ClassBody": [
    "body"
  ],
  "ClassExpression": [
    "id",
    "body",
    "superClass",
    "mixins",
    "typeParameters",
    "superTypeParameters",
    "implements",
    "decorators"
  ],
  "ClassDeclaration": [
    "id",
    "body",
    "superClass",
    "mixins",
    "typeParameters",
    "superTypeParameters",
    "implements",
    "decorators"
  ],
  "ExportAllDeclaration": [
    "source",
    "exported",
    "assertions"
  ],
  "ExportDefaultDeclaration": [
    "declaration"
  ],
  "ExportNamedDeclaration": [
    "declaration",
    "specifiers",
    "source",
    "assertions"
  ],
  "ExportSpecifier": [
    "local",
    "exported"
  ],
  "ForOfStatement": [
    "left",
    "right",
    "body"
  ],
  "ImportDeclaration": [
    "specifiers",
    "source",
    "assertions"
  ],
  "ImportDefaultSpecifier": [
    "local"
  ],
  "ImportNamespaceSpecifier": [
    "local"
  ],
  "ImportSpecifier": [
    "local",
    "imported"
  ],
  "MetaProperty": [
    "meta",
    "property"
  ],
  "ClassMethod": [
    "key",
    "params",
    "body",
    "decorators",
    "returnType",
    "typeParameters"
  ],
  "ObjectPattern": [
    "properties",
    "typeAnnotation",
    "decorators"
  ],
  "SpreadElement": [
    "argument"
  ],
  "Super": [],
  "TaggedTemplateExpression": [
    "tag",
    "quasi",
    "typeParameters"
  ],
  "TemplateElement": [],
  "TemplateLiteral": [
    "quasis",
    "expressions"
  ],
  "YieldExpression": [
    "argument"
  ],
  "AwaitExpression": [
    "argument"
  ],
  "Import": [],
  "BigIntLiteral": [],
  "ExportNamespaceSpecifier": [
    "exported"
  ],
  "OptionalMemberExpression": [
    "object",
    "property"
  ],
  "OptionalCallExpression": [
    "callee",
    "arguments",
    "typeParameters",
    "typeArguments"
  ],
  "ClassProperty": [
    "key",
    "value",
    "typeAnnotation",
    "decorators",
    "variance"
  ],
  "ClassAccessorProperty": [
    "key",
    "value",
    "typeAnnotation",
    "decorators"
  ],
  "ClassPrivateProperty": [
    "key",
    "value",
    "decorators",
    "typeAnnotation",
    "variance"
  ],
  "ClassPrivateMethod": [
    "key",
    "params",
    "body",
    "decorators",
    "returnType",
    "typeParameters"
  ],
  "PrivateName": [
    "id"
  ],
  "StaticBlock": [
    "body"
  ],
  "AnyTypeAnnotation": [],
  "ArrayTypeAnnotation": [
    "elementType"
  ],
  "BooleanTypeAnnotation": [],
  "BooleanLiteralTypeAnnotation": [],
  "NullLiteralTypeAnnotation": [],
  "ClassImplements": [
    "id",
    "typeParameters"
  ],
  "DeclareClass": [
    "id",
    "typeParameters",
    "extends",
    "mixins",
    "implements",
    "body"
  ],
  "DeclareFunction": [
    "id",
    "predicate"
  ],
  "DeclareInterface": [
    "id",
    "typeParameters",
    "extends",
    "body"
  ],
  "DeclareModule": [
    "id",
    "body"
  ],
  "DeclareModuleExports": [
    "typeAnnotation"
  ],
  "DeclareTypeAlias": [
    "id",
    "typeParameters",
    "right"
  ],
  "DeclareOpaqueType": [
    "id",
    "typeParameters",
    "supertype"
  ],
  "DeclareVariable": [
    "id"
  ],
  "DeclareExportDeclaration": [
    "declaration",
    "specifiers",
    "source"
  ],
  "DeclareExportAllDeclaration": [
    "source"
  ],
  "DeclaredPredicate": [
    "value"
  ],
  "ExistsTypeAnnotation": [],
  "FunctionTypeAnnotation": [
    "typeParameters",
    "params",
    "rest",
    "returnType",
    "this"
  ],
  "FunctionTypeParam": [
    "name",
    "typeAnnotation"
  ],
  "GenericTypeAnnotation": [
    "id",
    "typeParameters"
  ],
  "InferredPredicate": [],
  "InterfaceExtends": [
    "id",
    "typeParameters"
  ],
  "InterfaceDeclaration": [
    "id",
    "typeParameters",
    "extends",
    "body"
  ],
  "InterfaceTypeAnnotation": [
    "extends",
    "body"
  ],
  "IntersectionTypeAnnotation": [
    "types"
  ],
  "MixedTypeAnnotation": [],
  "EmptyTypeAnnotation": [],
  "NullableTypeAnnotation": [
    "typeAnnotation"
  ],
  "NumberLiteralTypeAnnotation": [],
  "NumberTypeAnnotation": [],
  "ObjectTypeAnnotation": [
    "properties",
    "indexers",
    "callProperties",
    "internalSlots"
  ],
  "ObjectTypeInternalSlot": [
    "id",
    "value",
    "optional",
    "static",
    "method"
  ],
  "ObjectTypeCallProperty": [
    "value"
  ],
  "ObjectTypeIndexer": [
    "id",
    "key",
    "value",
    "variance"
  ],
  "ObjectTypeProperty": [
    "key",
    "value",
    "variance"
  ],
  "ObjectTypeSpreadProperty": [
    "argument"
  ],
  "OpaqueType": [
    "id",
    "typeParameters",
    "supertype",
    "impltype"
  ],
  "QualifiedTypeIdentifier": [
    "id",
    "qualification"
  ],
  "StringLiteralTypeAnnotation": [],
  "StringTypeAnnotation": [],
  "SymbolTypeAnnotation": [],
  "ThisTypeAnnotation": [],
  "TupleTypeAnnotation": [
    "types",
    "elementTypes"
  ],
  "TypeofTypeAnnotation": [
    "argument"
  ],
  "TypeAlias": [
    "id",
    "typeParameters",
    "right"
  ],
  "TypeAnnotation": [
    "typeAnnotation"
  ],
  "TypeCastExpression": [
    "expression",
    "typeAnnotation"
  ],
  "TypeParameter": [
    "bound",
    "default",
    "variance"
  ],
  "TypeParameterDeclaration": [
    "params"
  ],
  "TypeParameterInstantiation": [
    "params"
  ],
  "UnionTypeAnnotation": [
    "types"
  ],
  "Variance": [],
  "VoidTypeAnnotation": [],
  "EnumDeclaration": [
    "id",
    "body"
  ],
  "EnumBooleanBody": [
    "members"
  ],
  "EnumNumberBody": [
    "members"
  ],
  "EnumStringBody": [
    "members"
  ],
  "EnumSymbolBody": [
    "members"
  ],
  "EnumBooleanMember": [
    "id",
    "init"
  ],
  "EnumNumberMember": [
    "id",
    "init"
  ],
  "EnumStringMember": [
    "id",
    "init"
  ],
  "EnumDefaultedMember": [
    "id"
  ],
  "IndexedAccessType": [
    "objectType",
    "indexType"
  ],
  "OptionalIndexedAccessType": [
    "objectType",
    "indexType"
  ],
  "JSXAttribute": [
    "name",
    "value"
  ],
  "JSXClosingElement": [
    "name"
  ],
  "JSXElement": [
    "openingElement",
    "children",
    "closingElement"
  ],
  "JSXEmptyExpression": [],
  "JSXExpressionContainer": [
    "expression"
  ],
  "JSXSpreadChild": [
    "expression"
  ],
  "JSXIdentifier": [],
  "JSXMemberExpression": [
    "object",
    "property"
  ],
  "JSXNamespacedName": [
    "namespace",
    "name"
  ],
  "JSXOpeningElement": [
    "name",
    "attributes",
    "typeParameters"
  ],
  "JSXSpreadAttribute": [
    "argument"
  ],
  "JSXText": [],
  "JSXFragment": [
    "openingFragment",
    "children",
    "closingFragment"
  ],
  "JSXOpeningFragment": [],
  "JSXClosingFragment": [],
  "Noop": [],
  "Placeholder": [],
  "V8IntrinsicIdentifier": [],
  "ArgumentPlaceholder": [],
  "BindExpression": [
    "object",
    "callee"
  ],
  "ImportAttribute": [
    "key",
    "value"
  ],
  "Decorator": [
    "expression"
  ],
  "DoExpression": [
    "body"
  ],
  "ExportDefaultSpecifier": [
    "exported"
  ],
  "RecordExpression": [
    "properties"
  ],
  "TupleExpression": [
    "elements"
  ],
  "DecimalLiteral": [],
  "ModuleExpression": [
    "body"
  ],
  "TopicReference": [],
  "PipelineTopicExpression": [
    "expression"
  ],
  "PipelineBareFunction": [
    "callee"
  ],
  "PipelinePrimaryTopicReference": [],
  "TSParameterProperty": [
    "parameter",
    "decorators"
  ],
  "TSDeclareFunction": [
    "id",
    "typeParameters",
    "params",
    "returnType",
    "body"
  ],
  "TSDeclareMethod": [
    "decorators",
    "key",
    "typeParameters",
    "params",
    "returnType"
  ],
  "TSQualifiedName": [
    "left",
    "right"
  ],
  "TSCallSignatureDeclaration": [
    "typeParameters",
    "parameters",
    "typeAnnotation",
    "params",
    "returnType"
  ],
  "TSConstructSignatureDeclaration": [
    "typeParameters",
    "parameters",
    "typeAnnotation",
    "params",
    "returnType"
  ],
  "TSPropertySignature": [
    "key",
    "typeAnnotation"
  ],
  "TSMethodSignature": [
    "key",
    "typeParameters",
    "parameters",
    "typeAnnotation",
    "params",
    "returnType"
  ],
  "TSIndexSignature": [
    "parameters",
    "typeAnnotation"
  ],
  "TSAnyKeyword": [],
  "TSBooleanKeyword": [],
  "TSBigIntKeyword": [],
  "TSIntrinsicKeyword": [],
  "TSNeverKeyword": [],
  "TSNullKeyword": [],
  "TSNumberKeyword": [],
  "TSObjectKeyword": [],
  "TSStringKeyword": [],
  "TSSymbolKeyword": [],
  "TSUndefinedKeyword": [],
  "TSUnknownKeyword": [],
  "TSVoidKeyword": [],
  "TSThisType": [],
  "TSFunctionType": [
    "typeParameters",
    "parameters",
    "typeAnnotation",
    "params",
    "returnType"
  ],
  "TSConstructorType": [
    "typeParameters",
    "parameters",
    "typeAnnotation",
    "params",
    "returnType"
  ],
  "TSTypeReference": [
    "typeName",
    "typeParameters"
  ],
  "TSTypePredicate": [
    "parameterName",
    "typeAnnotation"
  ],
  "TSTypeQuery": [
    "exprName",
    "typeParameters"
  ],
  "TSTypeLiteral": [
    "members"
  ],
  "TSArrayType": [
    "elementType"
  ],
  "TSTupleType": [
    "elementTypes"
  ],
  "TSOptionalType": [
    "typeAnnotation"
  ],
  "TSRestType": [
    "typeAnnotation"
  ],
  "TSNamedTupleMember": [
    "label",
    "elementType"
  ],
  "TSUnionType": [
    "types"
  ],
  "TSIntersectionType": [
    "types"
  ],
  "TSConditionalType": [
    "checkType",
    "extendsType",
    "trueType",
    "falseType"
  ],
  "TSInferType": [
    "typeParameter"
  ],
  "TSParenthesizedType": [
    "typeAnnotation"
  ],
  "TSTypeOperator": [
    "typeAnnotation"
  ],
  "TSIndexedAccessType": [
    "objectType",
    "indexType"
  ],
  "TSMappedType": [
    "typeParameter",
    "typeAnnotation",
    "nameType"
  ],
  "TSLiteralType": [
    "literal"
  ],
  "TSExpressionWithTypeArguments": [
    "expression",
    "typeParameters"
  ],
  "TSInterfaceDeclaration": [
    "id",
    "typeParameters",
    "extends",
    "body"
  ],
  "TSInterfaceBody": [
    "body"
  ],
  "TSTypeAliasDeclaration": [
    "id",
    "typeParameters",
    "typeAnnotation"
  ],
  "TSInstantiationExpression": [
    "expression",
    "typeParameters"
  ],
  "TSAsExpression": [
    "expression",
    "typeAnnotation"
  ],
  "TSSatisfiesExpression": [
    "expression",
    "typeAnnotation"
  ],
  "TSTypeAssertion": [
    "typeAnnotation",
    "expression"
  ],
  "TSEnumDeclaration": [
    "id",
    "members"
  ],
  "TSEnumMember": [
    "id",
    "initializer"
  ],
  "TSModuleDeclaration": [
    "id",
    "body"
  ],
  "TSModuleBlock": [
    "body"
  ],
  "TSImportType": [
    "argument",
    "qualifier",
    "typeParameters",
    "parameter"
  ],
  "TSImportEqualsDeclaration": [
    "id",
    "moduleReference"
  ],
  "TSExternalModuleReference": [
    "expression"
  ],
  "TSNonNullExpression": [
    "expression"
  ],
  "TSExportAssignment": [
    "expression"
  ],
  "TSNamespaceExportDeclaration": [
    "id"
  ],
  "TSTypeAnnotation": [
    "typeAnnotation"
  ],
  "TSTypeParameterInstantiation": [
    "params"
  ],
  "TSTypeParameterDeclaration": [
    "params"
  ],
  "TSTypeParameter": [
    "constraint",
    "default",
    "name"
  ],
  "ChainExpression": [
    "expression"
  ],
  "ExperimentalRestProperty": [
    "argument"
  ],
  "ExperimentalSpreadProperty": [
    "argument"
  ],
  "ImportExpression": [
    "source",
    "attributes"
  ],
  "Literal": [],
  "MethodDefinition": [
    "decorators",
    "key",
    "value"
  ],
  "PrivateIdentifier": [],
  "Property": [
    "key",
    "value",
    "decorators"
  ],
  "PropertyDefinition": [
    "decorators",
    "key",
    "typeAnnotation",
    "value",
    "variance"
  ],
  "AccessorProperty": [
    "decorators",
    "key",
    "typeAnnotation",
    "value"
  ],
  "TSAbstractAccessorProperty": [
    "decorators",
    "key",
    "typeAnnotation"
  ],
  "TSAbstractKeyword": [],
  "TSAbstractMethodDefinition": [
    "key",
    "value",
    "decorators"
  ],
  "TSAbstractPropertyDefinition": [
    "decorators",
    "key",
    "typeAnnotation"
  ],
  "TSAsyncKeyword": [],
  "TSClassImplements": [
    "expression",
    "typeParameters"
  ],
  "TSDeclareKeyword": [],
  "TSEmptyBodyFunctionExpression": [
    "id",
    "typeParameters",
    "params",
    "returnType"
  ],
  "TSExportKeyword": [],
  "TSInterfaceHeritage": [
    "expression",
    "typeParameters"
  ],
  "TSPrivateKeyword": [],
  "TSProtectedKeyword": [],
  "TSPublicKeyword": [],
  "TSReadonlyKeyword": [],
  "TSStaticKeyword": [],
  "TSTemplateLiteralType": [
    "quasis",
    "types"
  ],
  "BigIntLiteralTypeAnnotation": [],
  "NGRoot": [
    "node"
  ],
  "NGPipeExpression": [
    "left",
    "right",
    "arguments"
  ],
  "NGChainedExpression": [
    "expressions"
  ],
  "NGEmptyExpression": [],
  "NGMicrosyntax": [
    "body"
  ],
  "NGMicrosyntaxKey": [],
  "NGMicrosyntaxExpression": [
    "expression",
    "alias"
  ],
  "NGMicrosyntaxKeyedExpression": [
    "key",
    "expression"
  ],
  "NGMicrosyntaxLet": [
    "key",
    "value"
  ],
  "NGMicrosyntaxAs": [
    "key",
    "alias"
  ],
  "JsExpressionRoot": [
    "node"
  ],
  "JsonRoot": [
    "node"
  ],
  "TSJSDocAllType": [],
  "TSJSDocUnknownType": [],
  "TSJSDocNullableType": [
    "typeAnnotation"
  ],
  "TSJSDocNonNullableType": [
    "typeAnnotation"
  ],
  "BigIntTypeAnnotation": [],
  "QualifiedTypeofIdentifier": [
    "id",
    "qualification"
  ],
  "DeclareEnum": [
    "id",
    "body"
  ],
  "TupleTypeSpreadElement": [
    "label",
    "typeAnnotation"
  ],
  "TupleTypeLabeledElement": [
    "label",
    "elementType",
    "variance"
  ],
  "NeverTypeAnnotation": [],
  "UndefinedTypeAnnotation": [],
  "UnknownTypeAnnotation": []
};

// src/language-js/traverse/get-visitor-keys.js
var getVisitorKeys = create_get_visitor_keys_default(visitor_keys_evaluate_default);
var get_visitor_keys_default = getVisitorKeys;

// src/language-js/utils/is-block-comment.js
var BLOCK_COMMENT_TYPES = /* @__PURE__ */ new Set([
  "Block",
  "CommentBlock",
  // `meriyah`
  "MultiLine"
]);
var isBlockComment = (comment) => BLOCK_COMMENT_TYPES.has(comment == null ? void 0 : comment.type);
var is_block_comment_default = isBlockComment;

// src/language-js/utils/is-node-matches.js
function isNodeMatchesNameOrPath(node, nameOrPath) {
  const names = nameOrPath.split(".");
  for (let index = names.length - 1; index >= 0; index--) {
    const name = names[index];
    if (index === 0) {
      return node.type === "Identifier" && node.name === name;
    }
    if (node.type !== "MemberExpression" || node.optional || node.computed || node.property.type !== "Identifier" || node.property.name !== name) {
      return false;
    }
    node = node.object;
  }
}
function isNodeMatches(node, nameOrPaths) {
  return nameOrPaths.some(
    (nameOrPath) => isNodeMatchesNameOrPath(node, nameOrPath)
  );
}
var is_node_matches_default = isNodeMatches;

// src/language-js/utils/index.js
function hasNode(node, fn) {
  if (node === null || typeof node !== "object") {
    return false;
  }
  if (Array.isArray(node)) {
    return node.some((value) => hasNode(value, fn));
  }
  const result = fn(node);
  return typeof result === "boolean" ? result : get_visitor_keys_default(node).some((key) => hasNode(node[key], fn));
}
function hasNakedLeftSide(node) {
  return node.type === "AssignmentExpression" || node.type === "BinaryExpression" || node.type === "LogicalExpression" || node.type === "NGPipeExpression" || node.type === "ConditionalExpression" || isCallExpression(node) || isMemberExpression(node) || node.type === "SequenceExpression" || node.type === "TaggedTemplateExpression" || node.type === "BindExpression" || node.type === "UpdateExpression" && !node.prefix || isTSTypeExpression(node) || node.type === "TSNonNullExpression" || node.type === "ChainExpression";
}
function getLeftSide(node) {
  if (node.expressions) {
    return node.expressions[0];
  }
  return node.left ?? node.test ?? node.callee ?? node.object ?? node.tag ?? node.argument ?? node.expression;
}
function getLeftSidePathName(node) {
  if (node.expressions) {
    return ["expressions", 0];
  }
  if (node.left) {
    return ["left"];
  }
  if (node.test) {
    return ["test"];
  }
  if (node.object) {
    return ["object"];
  }
  if (node.callee) {
    return ["callee"];
  }
  if (node.tag) {
    return ["tag"];
  }
  if (node.argument) {
    return ["argument"];
  }
  if (node.expression) {
    return ["expression"];
  }
  throw new Error("Unexpected node has no left side.");
}
function createTypeCheckFunction(types) {
  types = new Set(types);
  return (node) => types.has(node == null ? void 0 : node.type);
}
var isLineComment = createTypeCheckFunction([
  "Line",
  "CommentLine",
  // `meriyah` has `SingleLine`, `HashbangComment`, `HTMLOpen`, and `HTMLClose`
  "SingleLine",
  "HashbangComment",
  "HTMLOpen",
  "HTMLClose",
  // `espree`
  "Hashbang",
  // Babel hashbang
  "InterpreterDirective"
]);
var isExportDeclaration = createTypeCheckFunction(["ExportDefaultDeclaration", "DeclareExportDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration", "DeclareExportAllDeclaration"]);
var isArrayOrTupleExpression = createTypeCheckFunction(["ArrayExpression", "TupleExpression"]);
var isObjectOrRecordExpression = createTypeCheckFunction(["ObjectExpression", "RecordExpression"]);
function isNumericLiteral(node) {
  return node.type === "NumericLiteral" || node.type === "Literal" && typeof node.value === "number";
}
function isSignedNumericLiteral(node) {
  return node.type === "UnaryExpression" && (node.operator === "+" || node.operator === "-") && isNumericLiteral(node.argument);
}
function isStringLiteral(node) {
  return node.type === "StringLiteral" || node.type === "Literal" && typeof node.value === "string";
}
function isRegExpLiteral(node) {
  return node.type === "RegExpLiteral" || node.type === "Literal" && Boolean(node.regex);
}
var isObjectType = createTypeCheckFunction(["ObjectTypeAnnotation", "TSTypeLiteral", "TSMappedType"]);
var isFunctionOrArrowExpression = createTypeCheckFunction(["FunctionExpression", "ArrowFunctionExpression"]);
function isFunctionOrArrowExpressionWithBody(node) {
  return node.type === "FunctionExpression" || node.type === "ArrowFunctionExpression" && node.body.type === "BlockStatement";
}
function isAngularTestWrapper(node) {
  return isCallExpression(node) && node.callee.type === "Identifier" && ["async", "inject", "fakeAsync", "waitForAsync"].includes(node.callee.name);
}
var isJsxElement = createTypeCheckFunction(["JSXElement", "JSXFragment"]);
function isTheOnlyJsxElementInMarkdown(options9, path11) {
  if (options9.parentParser !== "markdown" && options9.parentParser !== "mdx") {
    return false;
  }
  const {
    node
  } = path11;
  if (!node.expression || !isJsxElement(node.expression)) {
    return false;
  }
  const {
    parent
  } = path11;
  return parent.type === "Program" && parent.body.length === 1;
}
function isGetterOrSetter(node) {
  return node.kind === "get" || node.kind === "set";
}
function isFunctionNotation(node) {
  return isGetterOrSetter(node) || hasSameLocStart(node, node.value);
}
function isObjectTypePropertyAFunction(node) {
  return (node.type === "ObjectTypeProperty" || node.type === "ObjectTypeInternalSlot") && node.value.type === "FunctionTypeAnnotation" && !node.static && !isFunctionNotation(node);
}
function isTypeAnnotationAFunction(node) {
  return (node.type === "TypeAnnotation" || node.type === "TSTypeAnnotation") && node.typeAnnotation.type === "FunctionTypeAnnotation" && !node.static && !hasSameLocStart(node, node.typeAnnotation);
}
var isBinaryish = createTypeCheckFunction(["BinaryExpression", "LogicalExpression", "NGPipeExpression"]);
function isMemberish(node) {
  return isMemberExpression(node) || node.type === "BindExpression" && Boolean(node.object);
}
var simpleTypeAnnotations = /* @__PURE__ */ new Set([
  // `any`
  "AnyTypeAnnotation",
  "TSAnyKeyword",
  // `null`
  "NullLiteralTypeAnnotation",
  "TSNullKeyword",
  // `this`
  "ThisTypeAnnotation",
  "TSThisType",
  // `number`
  "NumberTypeAnnotation",
  "TSNumberKeyword",
  // `void`
  "VoidTypeAnnotation",
  "TSVoidKeyword",
  // `boolean`
  "BooleanTypeAnnotation",
  "TSBooleanKeyword",
  // `bigint`
  "BigIntTypeAnnotation",
  "TSBigIntKeyword",
  // `symbol`
  "SymbolTypeAnnotation",
  "TSSymbolKeyword",
  // `string`
  "StringTypeAnnotation",
  "TSStringKeyword",
  // `never`
  "NeverTypeAnnotation",
  "TSNeverKeyword",
  // `undefined`
  "UndefinedTypeAnnotation",
  "TSUndefinedKeyword",
  // `unknown`
  "UnknownTypeAnnotation",
  "TSUnknownKeyword",
  // literals
  "BooleanLiteralTypeAnnotation",
  "StringLiteralTypeAnnotation",
  "BigIntLiteralTypeAnnotation",
  "NumberLiteralTypeAnnotation",
  "TSLiteralType",
  "TSTemplateLiteralType",
  // flow only, `empty`, `mixed`
  "EmptyTypeAnnotation",
  "MixedTypeAnnotation",
  // typescript only `object`
  "TSObjectKeyword"
]);
function isSimpleType(node) {
  if (!node) {
    return false;
  }
  if ((node.type === "GenericTypeAnnotation" || node.type === "TSTypeReference") && !node.typeParameters) {
    return true;
  }
  if (simpleTypeAnnotations.has(node.type)) {
    return true;
  }
  return false;
}
function isUnitTestSetUp(node) {
  const unitTestSetUpRe = /^(?:before|after)(?:Each|All)$/;
  return node.callee.type === "Identifier" && node.arguments.length === 1 && unitTestSetUpRe.test(node.callee.name);
}
var testCallCalleePatterns = ["it", "it.only", "it.skip", "describe", "describe.only", "describe.skip", "test", "test.only", "test.skip", "test.step", "test.describe", "test.describe.only", "test.describe.parallel", "test.describe.parallel.only", "test.describe.serial", "test.describe.serial.only", "skip", "xit", "xdescribe", "xtest", "fit", "fdescribe", "ftest"];
function isTestCallCallee(node) {
  return is_node_matches_default(node, testCallCalleePatterns);
}
function isTestCall(node, parent) {
  if (node.type !== "CallExpression") {
    return false;
  }
  if (node.arguments.length === 1) {
    if (isAngularTestWrapper(node) && parent && isTestCall(parent)) {
      return isFunctionOrArrowExpression(node.arguments[0]);
    }
    if (isUnitTestSetUp(node)) {
      return isAngularTestWrapper(node.arguments[0]);
    }
  } else if ((node.arguments.length === 2 || node.arguments.length === 3) && (node.arguments[0].type === "TemplateLiteral" || isStringLiteral(node.arguments[0])) && isTestCallCallee(node.callee)) {
    if (node.arguments[2] && !isNumericLiteral(node.arguments[2])) {
      return false;
    }
    return (node.arguments.length === 2 ? isFunctionOrArrowExpression(node.arguments[1]) : isFunctionOrArrowExpressionWithBody(node.arguments[1]) && getFunctionParameters(node.arguments[1]).length <= 1) || isAngularTestWrapper(node.arguments[1]);
  }
  return false;
}
var isCallExpression = createTypeCheckFunction(["CallExpression", "OptionalCallExpression"]);
var isMemberExpression = createTypeCheckFunction(["MemberExpression", "OptionalMemberExpression"]);
function isSimpleTemplateLiteral(node) {
  let expressionsKey = "expressions";
  if (node.type === "TSTemplateLiteralType") {
    expressionsKey = "types";
  }
  const expressions = node[expressionsKey];
  if (expressions.length === 0) {
    return false;
  }
  return expressions.every((expr) => {
    if (hasComment(expr)) {
      return false;
    }
    if (expr.type === "Identifier" || expr.type === "ThisExpression") {
      return true;
    }
    if (expr.type === "ChainExpression") {
      expr = expr.expression;
    }
    if (isMemberExpression(expr)) {
      let head = expr;
      while (isMemberExpression(head)) {
        if (head.property.type !== "Identifier" && head.property.type !== "Literal" && head.property.type !== "StringLiteral" && head.property.type !== "NumericLiteral") {
          return false;
        }
        head = head.object;
        if (hasComment(head)) {
          return false;
        }
      }
      if (head.type === "Identifier" || head.type === "ThisExpression") {
        return true;
      }
      return false;
    }
    return false;
  });
}
function getTypeScriptMappedTypeModifier(tokenNode, keyword) {
  if (tokenNode === "+" || tokenNode === "-") {
    return tokenNode + keyword;
  }
  return keyword;
}
function hasLeadingOwnLineComment(text, node) {
  if (isJsxElement(node)) {
    return hasNodeIgnoreComment(node);
  }
  return hasComment(node, CommentCheckFlags.Leading, (comment) => has_newline_default(text, locEnd(comment)));
}
function isStringPropSafeToUnquote(node, options9) {
  return options9.parser !== "json" && isStringLiteral(node.key) && rawText(node.key).slice(1, -1) === node.key.value && (src_default(node.key.value) && // With `--strictPropertyInitialization`, TS treats properties with quoted names differently than unquoted ones.
  // See https://github.com/microsoft/TypeScript/pull/20075
  !(options9.parser === "babel-ts" && node.type === "ClassProperty" || options9.parser === "typescript" && node.type === "PropertyDefinition") || isSimpleNumber(node.key.value) && String(Number(node.key.value)) === node.key.value && (options9.parser === "babel" || options9.parser === "acorn" || options9.parser === "espree" || options9.parser === "meriyah" || options9.parser === "__babel_estree"));
}
function isSimpleNumber(numberString) {
  return /^(?:\d+|\d+\.\d+)$/.test(numberString);
}
function templateLiteralHasNewLines(template) {
  return template.quasis.some((quasi) => quasi.value.raw.includes("\n"));
}
function isTemplateOnItsOwnLine(node, text) {
  return (node.type === "TemplateLiteral" && templateLiteralHasNewLines(node) || node.type === "TaggedTemplateExpression" && templateLiteralHasNewLines(node.quasi)) && !has_newline_default(text, locStart(node), {
    backwards: true
  });
}
function needsHardlineAfterDanglingComment(node) {
  if (!hasComment(node)) {
    return false;
  }
  const lastDanglingComment = at_default(
    /* isOptionalObject*/
    false,
    getComments(node, CommentCheckFlags.Dangling),
    -1
  );
  return lastDanglingComment && !is_block_comment_default(lastDanglingComment);
}
function isFunctionCompositionArgs(args) {
  if (args.length <= 1) {
    return false;
  }
  let count = 0;
  for (const arg of args) {
    if (isFunctionOrArrowExpression(arg)) {
      count += 1;
      if (count > 1) {
        return true;
      }
    } else if (isCallExpression(arg)) {
      for (const childArg of arg.arguments) {
        if (isFunctionOrArrowExpression(childArg)) {
          return true;
        }
      }
    }
  }
  return false;
}
function isLongCurriedCallExpression(path11) {
  const {
    node,
    parent,
    key
  } = path11;
  return key === "callee" && isCallExpression(node) && isCallExpression(parent) && parent.arguments.length > 0 && node.arguments.length > parent.arguments.length;
}
var simpleCallArgumentUnaryOperators = /* @__PURE__ */ new Set(["!", "-", "+", "~"]);
function isSimpleCallArgument(node, depth = 2) {
  if (depth <= 0) {
    return false;
  }
  const isChildSimple = (child) => isSimpleCallArgument(child, depth - 1);
  if (isRegExpLiteral(node)) {
    return get_string_width_default(node.pattern ?? node.regex.pattern) <= 5;
  }
  if (node.type === "Literal" || node.type === "BigIntLiteral" || node.type === "DecimalLiteral" || node.type === "BooleanLiteral" || node.type === "NullLiteral" || node.type === "NumericLiteral" || node.type === "StringLiteral" || node.type === "Identifier" || node.type === "ThisExpression" || node.type === "Super" || node.type === "PrivateName" || node.type === "PrivateIdentifier" || node.type === "ArgumentPlaceholder" || node.type === "Import") {
    return true;
  }
  if (node.type === "TemplateLiteral") {
    return node.quasis.every((element) => !element.value.raw.includes("\n")) && node.expressions.every(isChildSimple);
  }
  if (isObjectOrRecordExpression(node)) {
    return node.properties.every((p) => !p.computed && (p.shorthand || p.value && isChildSimple(p.value)));
  }
  if (isArrayOrTupleExpression(node)) {
    return node.elements.every((x) => x === null || isChildSimple(x));
  }
  if (isCallLikeExpression(node)) {
    if (node.type === "ImportExpression" || isSimpleCallArgument(node.callee, depth)) {
      const args = getCallArguments(node);
      return args.length <= depth && args.every(isChildSimple);
    }
    return false;
  }
  if (isMemberExpression(node)) {
    return isSimpleCallArgument(node.object, depth) && isSimpleCallArgument(node.property, depth);
  }
  if (node.type === "UnaryExpression" && simpleCallArgumentUnaryOperators.has(node.operator) || node.type === "UpdateExpression") {
    return isSimpleCallArgument(node.argument, depth);
  }
  if (node.type === "TSNonNullExpression") {
    return isSimpleCallArgument(node.expression, depth);
  }
  return false;
}
function rawText(node) {
  var _a;
  return ((_a = node.extra) == null ? void 0 : _a.raw) ?? node.raw;
}
function identity(x) {
  return x;
}
function isTSXFile(options9) {
  return options9.filepath && /\.tsx$/i.test(options9.filepath);
}
function shouldPrintComma(options9, level = "es5") {
  return options9.trailingComma === "es5" && level === "es5" || options9.trailingComma === "all" && (level === "all" || level === "es5");
}
function startsWithNoLookaheadToken(node, predicate) {
  switch (node.type) {
    case "BinaryExpression":
    case "LogicalExpression":
    case "AssignmentExpression":
    case "NGPipeExpression":
      return startsWithNoLookaheadToken(node.left, predicate);
    case "MemberExpression":
    case "OptionalMemberExpression":
      return startsWithNoLookaheadToken(node.object, predicate);
    case "TaggedTemplateExpression":
      if (node.tag.type === "FunctionExpression") {
        return false;
      }
      return startsWithNoLookaheadToken(node.tag, predicate);
    case "CallExpression":
    case "OptionalCallExpression":
      if (node.callee.type === "FunctionExpression") {
        return false;
      }
      return startsWithNoLookaheadToken(node.callee, predicate);
    case "ConditionalExpression":
      return startsWithNoLookaheadToken(node.test, predicate);
    case "UpdateExpression":
      return !node.prefix && startsWithNoLookaheadToken(node.argument, predicate);
    case "BindExpression":
      return node.object && startsWithNoLookaheadToken(node.object, predicate);
    case "SequenceExpression":
      return startsWithNoLookaheadToken(node.expressions[0], predicate);
    case "ChainExpression":
    case "TSSatisfiesExpression":
    case "TSAsExpression":
    case "TSNonNullExpression":
      return startsWithNoLookaheadToken(node.expression, predicate);
    default:
      return predicate(node);
  }
}
var equalityOperators = {
  "==": true,
  "!=": true,
  "===": true,
  "!==": true
};
var multiplicativeOperators = {
  "*": true,
  "/": true,
  "%": true
};
var bitshiftOperators = {
  ">>": true,
  ">>>": true,
  "<<": true
};
function shouldFlatten(parentOp, nodeOp) {
  if (getPrecedence(nodeOp) !== getPrecedence(parentOp)) {
    return false;
  }
  if (parentOp === "**") {
    return false;
  }
  if (equalityOperators[parentOp] && equalityOperators[nodeOp]) {
    return false;
  }
  if (nodeOp === "%" && multiplicativeOperators[parentOp] || parentOp === "%" && multiplicativeOperators[nodeOp]) {
    return false;
  }
  if (nodeOp !== parentOp && multiplicativeOperators[nodeOp] && multiplicativeOperators[parentOp]) {
    return false;
  }
  if (bitshiftOperators[parentOp] && bitshiftOperators[nodeOp]) {
    return false;
  }
  return true;
}
var PRECEDENCE = new Map([["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].flatMap((operators, index) => operators.map((operator) => [operator, index])));
function getPrecedence(operator) {
  return PRECEDENCE.get(operator);
}
function isBitwiseOperator(operator) {
  return Boolean(bitshiftOperators[operator]) || operator === "|" || operator === "^" || operator === "&";
}
function hasRestParameter(node) {
  var _a;
  if (node.rest) {
    return true;
  }
  const parameters = getFunctionParameters(node);
  return ((_a = at_default(
    /* isOptionalObject*/
    false,
    parameters,
    -1
  )) == null ? void 0 : _a.type) === "RestElement";
}
var functionParametersCache = /* @__PURE__ */ new WeakMap();
function getFunctionParameters(node) {
  if (functionParametersCache.has(node)) {
    return functionParametersCache.get(node);
  }
  const parameters = [];
  if (node.this) {
    parameters.push(node.this);
  }
  if (Array.isArray(node.parameters)) {
    parameters.push(...node.parameters);
  } else if (Array.isArray(node.params)) {
    parameters.push(...node.params);
  }
  if (node.rest) {
    parameters.push(node.rest);
  }
  functionParametersCache.set(node, parameters);
  return parameters;
}
function iterateFunctionParametersPath(path11, iteratee) {
  const {
    node
  } = path11;
  let index = 0;
  const callback = (childPath) => iteratee(childPath, index++);
  if (node.this) {
    path11.call(callback, "this");
  }
  if (Array.isArray(node.parameters)) {
    path11.each(callback, "parameters");
  } else if (Array.isArray(node.params)) {
    path11.each(callback, "params");
  }
  if (node.rest) {
    path11.call(callback, "rest");
  }
}
var callArgumentsCache = /* @__PURE__ */ new WeakMap();
function getCallArguments(node) {
  if (callArgumentsCache.has(node)) {
    return callArgumentsCache.get(node);
  }
  let args = node.arguments;
  if (node.type === "ImportExpression") {
    args = [node.source];
    if (node.attributes) {
      args.push(node.attributes);
    }
  }
  callArgumentsCache.set(node, args);
  return args;
}
function iterateCallArgumentsPath(path11, iteratee) {
  const {
    node
  } = path11;
  if (node.type === "ImportExpression") {
    path11.call((sourcePath) => iteratee(sourcePath, 0), "source");
    if (node.attributes) {
      path11.call((sourcePath) => iteratee(sourcePath, 1), "attributes");
    }
  } else {
    path11.each(iteratee, "arguments");
  }
}
function getCallArgumentSelector(node, index) {
  if (node.type === "ImportExpression") {
    if (index === 0 || index === (node.attributes ? -2 : -1)) {
      return "source";
    }
    if (node.attributes && (index === 1 || index === -1)) {
      return "attributes";
    }
    throw new RangeError("Invalid argument index");
  }
  if (index < 0) {
    index = node.arguments.length + index;
  }
  if (index < 0 || index >= node.arguments.length) {
    throw new RangeError("Invalid argument index");
  }
  return ["arguments", index];
}
function isPrettierIgnoreComment(comment) {
  return comment.value.trim() === "prettier-ignore" && !comment.unignore;
}
function hasNodeIgnoreComment(node) {
  return (node == null ? void 0 : node.prettierIgnore) || hasComment(node, CommentCheckFlags.PrettierIgnore);
}
var CommentCheckFlags = {
  /** Check comment is a leading comment */
  Leading: 1 << 1,
  /** Check comment is a trailing comment */
  Trailing: 1 << 2,
  /** Check comment is a dangling comment */
  Dangling: 1 << 3,
  /** Check comment is a block comment */
  Block: 1 << 4,
  /** Check comment is a line comment */
  Line: 1 << 5,
  /** Check comment is a `prettier-ignore` comment */
  PrettierIgnore: 1 << 6,
  /** Check comment is the first attached comment */
  First: 1 << 7,
  /** Check comment is the last attached comment */
  Last: 1 << 8
};
var getCommentTestFunction = (flags, fn) => {
  if (typeof flags === "function") {
    fn = flags;
    flags = 0;
  }
  if (flags || fn) {
    return (comment, index, comments) => !(flags & CommentCheckFlags.Leading && !comment.leading || flags & CommentCheckFlags.Trailing && !comment.trailing || flags & CommentCheckFlags.Dangling && (comment.leading || comment.trailing) || flags & CommentCheckFlags.Block && !is_block_comment_default(comment) || flags & CommentCheckFlags.Line && !isLineComment(comment) || flags & CommentCheckFlags.First && index !== 0 || flags & CommentCheckFlags.Last && index !== comments.length - 1 || flags & CommentCheckFlags.PrettierIgnore && !isPrettierIgnoreComment(comment) || fn && !fn(comment));
  }
};
function hasComment(node, flags, fn) {
  if (!is_non_empty_array_default(node == null ? void 0 : node.comments)) {
    return false;
  }
  const test = getCommentTestFunction(flags, fn);
  return test ? node.comments.some(test) : true;
}
function getComments(node, flags, fn) {
  if (!Array.isArray(node == null ? void 0 : node.comments)) {
    return [];
  }
  const test = getCommentTestFunction(flags, fn);
  return test ? node.comments.filter(test) : node.comments;
}
var isNextLineEmpty2 = (node, {
  originalText
}) => is_next_line_empty_default(originalText, locEnd(node));
function isCallLikeExpression(node) {
  return isCallExpression(node) || node.type === "NewExpression" || node.type === "ImportExpression";
}
function isObjectProperty(node) {
  return node && (node.type === "ObjectProperty" || node.type === "Property" && !node.method && node.kind === "init");
}
function isEnabledHackPipeline(options9) {
  return Boolean(options9.__isUsingHackPipeline);
}
var markerForIfWithoutBlockAndSameLineComment = Symbol("ifWithoutBlockAndSameLineComment");
var isTSTypeExpression = createTypeCheckFunction(["TSAsExpression", "TSSatisfiesExpression"]);

// src/utils/get-indent-size.js
function getIndentSize(value, tabWidth) {
  const lastNewlineIndex = value.lastIndexOf("\n");
  if (lastNewlineIndex === -1) {
    return 0;
  }
  return get_alignment_size_default(
    // All the leading whitespaces
    value.slice(lastNewlineIndex + 1).match(/^[\t ]*/)[0],
    tabWidth
  );
}
var get_indent_size_default = getIndentSize;

// src/language-js/print/template-literal.js
function printTemplateLiteral(path11, print4, options9) {
  const {
    node
  } = path11;
  const isTemplateLiteral = node.type === "TemplateLiteral";
  if (isTemplateLiteral && isJestEachTemplateLiteral(path11)) {
    const printed = printJestEachTemplateLiteral(path11, options9, print4);
    if (printed) {
      return printed;
    }
  }
  let expressionsKey = "expressions";
  if (node.type === "TSTemplateLiteralType") {
    expressionsKey = "types";
  }
  const parts = [];
  let expressionDocs = path11.map(print4, expressionsKey);
  const isSimple = isSimpleTemplateLiteral(node);
  if (isSimple) {
    expressionDocs = expressionDocs.map((doc2) => printDocToString(doc2, {
      ...options9,
      printWidth: Number.POSITIVE_INFINITY
    }).formatted);
  }
  parts.push(lineSuffixBoundary, "`");
  let previousQuasiIndentSize = 0;
  path11.each(({
    index,
    node: quasi
  }) => {
    parts.push(print4());
    if (quasi.tail) {
      return;
    }
    const {
      tabWidth
    } = options9;
    const text = quasi.value.raw;
    const indentSize = text.includes("\n") ? get_indent_size_default(text, tabWidth) : previousQuasiIndentSize;
    previousQuasiIndentSize = indentSize;
    let expressionDoc = expressionDocs[index];
    if (!isSimple) {
      const expression = node[expressionsKey][index];
      if (hasComment(expression) || isMemberExpression(expression) || expression.type === "ConditionalExpression" || expression.type === "SequenceExpression" || isTSTypeExpression(expression) || isBinaryish(expression)) {
        expressionDoc = [indent([softline, expressionDoc]), softline];
      }
    }
    const aligned = indentSize === 0 && text.endsWith("\n") ? align(Number.NEGATIVE_INFINITY, expressionDoc) : addAlignmentToDoc(expressionDoc, indentSize, tabWidth);
    parts.push(group(["${", aligned, lineSuffixBoundary, "}"]));
  }, "quasis");
  parts.push("`");
  return parts;
}
function printTaggedTemplateLiteral(print4) {
  const quasiDoc = print4("quasi");
  return label(quasiDoc.label && {
    tagged: true,
    ...quasiDoc.label
  }, [print4("tag"), print4("typeParameters"), lineSuffixBoundary, quasiDoc]);
}
function printJestEachTemplateLiteral(path11, options9, print4) {
  const {
    node
  } = path11;
  const headerNames = node.quasis[0].value.raw.trim().split(/\s*\|\s*/);
  if (headerNames.length > 1 || headerNames.some((headerName) => headerName.length > 0)) {
    options9.__inJestEach = true;
    const expressions = path11.map(print4, "expressions");
    options9.__inJestEach = false;
    const parts = [];
    const stringifiedExpressions = expressions.map((doc2) => "${" + printDocToString(doc2, {
      ...options9,
      printWidth: Number.POSITIVE_INFINITY,
      endOfLine: "lf"
    }).formatted + "}");
    const tableBody = [{
      hasLineBreak: false,
      cells: []
    }];
    for (let i = 1; i < node.quasis.length; i++) {
      const row = at_default(
        /* isOptionalObject*/
        false,
        tableBody,
        -1
      );
      const correspondingExpression = stringifiedExpressions[i - 1];
      row.cells.push(correspondingExpression);
      if (correspondingExpression.includes("\n")) {
        row.hasLineBreak = true;
      }
      if (node.quasis[i].value.raw.includes("\n")) {
        tableBody.push({
          hasLineBreak: false,
          cells: []
        });
      }
    }
    const maxColumnCount = Math.max(headerNames.length, ...tableBody.map((row) => row.cells.length));
    const maxColumnWidths = Array.from({
      length: maxColumnCount
    }).fill(0);
    const table = [{
      cells: headerNames
    }, ...tableBody.filter((row) => row.cells.length > 0)];
    for (const {
      cells
    } of table.filter((row) => !row.hasLineBreak)) {
      for (const [index, cell] of cells.entries()) {
        maxColumnWidths[index] = Math.max(maxColumnWidths[index], get_string_width_default(cell));
      }
    }
    parts.push(lineSuffixBoundary, "`", indent([hardline, join(hardline, table.map((row) => join(" | ", row.cells.map((cell, index) => row.hasLineBreak ? cell : cell + " ".repeat(maxColumnWidths[index] - get_string_width_default(cell))))))]), hardline, "`");
    return parts;
  }
}
function printTemplateExpression(path11, print4) {
  const {
    node
  } = path11;
  let printed = print4();
  if (hasComment(node)) {
    printed = group([indent([softline, printed]), softline]);
  }
  return ["${", printed, lineSuffixBoundary, "}"];
}
function printTemplateExpressions(path11, print4) {
  return path11.map((path12) => printTemplateExpression(path12, print4), "expressions");
}
function escapeTemplateCharacters(doc2, raw) {
  return mapDoc(doc2, (currentDoc) => {
    if (typeof currentDoc === "string") {
      return raw ? string_replace_all_default(
        /* isOptionalObject*/
        false,
        currentDoc,
        /(\\*)`/g,
        "$1$1\\`"
      ) : uncookTemplateElementValue(currentDoc);
    }
    return currentDoc;
  });
}
function uncookTemplateElementValue(cookedValue) {
  return string_replace_all_default(
    /* isOptionalObject*/
    false,
    cookedValue,
    /([\\`]|\${)/g,
    "\\$1"
  );
}
function isJestEachTemplateLiteral({
  node,
  parent
}) {
  const jestEachTriggerRegex = /^[fx]?(?:describe|it|test)$/;
  return parent.type === "TaggedTemplateExpression" && parent.quasi === node && parent.tag.type === "MemberExpression" && parent.tag.property.type === "Identifier" && parent.tag.property.name === "each" && (parent.tag.object.type === "Identifier" && jestEachTriggerRegex.test(parent.tag.object.name) || parent.tag.object.type === "MemberExpression" && parent.tag.object.property.type === "Identifier" && (parent.tag.object.property.name === "only" || parent.tag.object.property.name === "skip") && parent.tag.object.object.type === "Identifier" && jestEachTriggerRegex.test(parent.tag.object.object.name));
}

// src/language-js/embed/markdown.js
async function embedMarkdown(textToDoc2, print4, path11) {
  const {
    node
  } = path11;
  let text = string_replace_all_default(
    /* isOptionalObject*/
    false,
    node.quasis[0].value.raw,
    /((?:\\\\)*)\\`/g,
    (_, backslashes) => "\\".repeat(backslashes.length / 2) + "`"
  );
  const indentation = getIndentation(text);
  const hasIndent = indentation !== "";
  if (hasIndent) {
    text = string_replace_all_default(
      /* isOptionalObject*/
      false,
      text,
      new RegExp(`^${indentation}`, "gm"),
      ""
    );
  }
  const doc2 = escapeTemplateCharacters(await textToDoc2(text, {
    parser: "markdown",
    __inJsTemplate: true
  }), true);
  return ["`", hasIndent ? indent([softline, doc2]) : [literalline, dedentToRoot(doc2)], softline, "`"];
}
function getIndentation(str) {
  const firstMatchedIndent = str.match(/^([^\S\n]*)\S/m);
  return firstMatchedIndent === null ? "" : firstMatchedIndent[1];
}
var markdown_default = embedMarkdown;

// src/language-js/embed/css.js
async function embedCss(textToDoc2, print4, path11) {
  const { node } = path11;
  const rawQuasis = node.quasis.map((q) => q.value.raw);
  let placeholderID = 0;
  const text = rawQuasis.reduce(
    (prevVal, currVal, idx) => idx === 0 ? currVal : prevVal + "@prettier-placeholder-" + placeholderID++ + "-id" + currVal,
    ""
  );
  const quasisDoc = await textToDoc2(text, { parser: "scss" });
  const expressionDocs = printTemplateExpressions(path11, print4);
  const newDoc = replacePlaceholders(quasisDoc, expressionDocs);
  if (!newDoc) {
    throw new Error("Couldn't insert all the expressions");
  }
  return ["`", indent([hardline, newDoc]), softline, "`"];
}
function replacePlaceholders(quasisDoc, expressionDocs) {
  if (!is_non_empty_array_default(expressionDocs)) {
    return quasisDoc;
  }
  let replaceCounter = 0;
  const newDoc = mapDoc(cleanDoc(quasisDoc), (doc2) => {
    if (typeof doc2 !== "string" || !doc2.includes("@prettier-placeholder")) {
      return doc2;
    }
    return doc2.split(/@prettier-placeholder-(\d+)-id/).map((component, idx) => {
      if (idx % 2 === 0) {
        return replaceEndOfLine(component);
      }
      replaceCounter++;
      return expressionDocs[component];
    });
  });
  return expressionDocs.length === replaceCounter ? newDoc : null;
}
var css_default = embedCss;

// src/language-js/embed/graphql.js
async function embedGraphQL(textToDoc2, print4, path11) {
  const { node } = path11;
  const numQuasis = node.quasis.length;
  const expressionDocs = printTemplateExpressions(path11, print4);
  const parts = [];
  for (let i = 0; i < numQuasis; i++) {
    const templateElement = node.quasis[i];
    const isFirst = i === 0;
    const isLast = i === numQuasis - 1;
    const text = templateElement.value.cooked;
    const lines = text.split("\n");
    const numLines = lines.length;
    const expressionDoc = expressionDocs[i];
    const startsWithBlankLine = numLines > 2 && lines[0].trim() === "" && lines[1].trim() === "";
    const endsWithBlankLine = numLines > 2 && lines[numLines - 1].trim() === "" && lines[numLines - 2].trim() === "";
    const commentsAndWhitespaceOnly = lines.every(
      (line2) => /^\s*(?:#[^\n\r]*)?$/.test(line2)
    );
    if (!isLast && /#[^\n\r]*$/.test(lines[numLines - 1])) {
      return null;
    }
    let doc2 = null;
    if (commentsAndWhitespaceOnly) {
      doc2 = printGraphqlComments(lines);
    } else {
      doc2 = await textToDoc2(text, { parser: "graphql" });
    }
    if (doc2) {
      doc2 = escapeTemplateCharacters(doc2, false);
      if (!isFirst && startsWithBlankLine) {
        parts.push("");
      }
      parts.push(doc2);
      if (!isLast && endsWithBlankLine) {
        parts.push("");
      }
    } else if (!isFirst && !isLast && startsWithBlankLine) {
      parts.push("");
    }
    if (expressionDoc) {
      parts.push(expressionDoc);
    }
  }
  return ["`", indent([hardline, join(hardline, parts)]), hardline, "`"];
}
function printGraphqlComments(lines) {
  const parts = [];
  let seenComment = false;
  const array = lines.map((textLine) => textLine.trim());
  for (const [i, textLine] of array.entries()) {
    if (textLine === "") {
      continue;
    }
    if (array[i - 1] === "" && seenComment) {
      parts.push([hardline, textLine]);
    } else {
      parts.push(textLine);
    }
    seenComment = true;
  }
  return parts.length === 0 ? null : join(hardline, parts);
}
var graphql_default = embedGraphQL;

// src/language-js/embed/html.js
var htmlTemplateLiteralCounter = 0;
async function embedHtmlLike(parser, textToDoc2, print4, path11, options9) {
  const {
    node
  } = path11;
  const counter = htmlTemplateLiteralCounter;
  htmlTemplateLiteralCounter = htmlTemplateLiteralCounter + 1 >>> 0;
  const composePlaceholder = (index) => `PRETTIER_HTML_PLACEHOLDER_${index}_${counter}_IN_JS`;
  const text = node.quasis.map((quasi, index, quasis) => index === quasis.length - 1 ? quasi.value.cooked : quasi.value.cooked + composePlaceholder(index)).join("");
  const expressionDocs = printTemplateExpressions(path11, print4);
  const placeholderRegex = new RegExp(composePlaceholder("(\\d+)"), "g");
  let topLevelCount = 0;
  const doc2 = await textToDoc2(text, {
    parser,
    __onHtmlRoot(root) {
      topLevelCount = root.children.length;
    }
  });
  const contentDoc = mapDoc(doc2, (doc3) => {
    if (typeof doc3 !== "string") {
      return doc3;
    }
    const parts = [];
    const components = doc3.split(placeholderRegex);
    for (let i = 0; i < components.length; i++) {
      let component = components[i];
      if (i % 2 === 0) {
        if (component) {
          component = uncookTemplateElementValue(component);
          if (options9.__embeddedInHtml) {
            component = string_replace_all_default(
              /* isOptionalObject*/
              false,
              component,
              /<\/(?=script\b)/gi,
              "<\\/"
            );
          }
          parts.push(component);
        }
        continue;
      }
      const placeholderIndex = Number(component);
      parts.push(expressionDocs[placeholderIndex]);
    }
    return parts;
  });
  const leadingWhitespace = /^\s/.test(text) ? " " : "";
  const trailingWhitespace = /\s$/.test(text) ? " " : "";
  const linebreak = options9.htmlWhitespaceSensitivity === "ignore" ? hardline : leadingWhitespace && trailingWhitespace ? line : null;
  if (linebreak) {
    return group(["`", indent([linebreak, group(contentDoc)]), linebreak, "`"]);
  }
  return label({
    hug: false
  }, group(["`", leadingWhitespace, topLevelCount > 1 ? indent(group(contentDoc)) : group(contentDoc), trailingWhitespace, "`"]));
}
var embedHtml = embedHtmlLike.bind(void 0, "html");
var embedAngular = embedHtmlLike.bind(void 0, "angular");

// src/language-js/embed.js
function embed(path11) {
  const { node } = path11;
  if (node.type !== "TemplateLiteral" || // Bail out if any of the quasis have an invalid escape sequence
  // (which would make the `cooked` value be `null`)
  hasInvalidCookedValue(node)) {
    return;
  }
  const embedder = getEmbedder(path11);
  if (embedder) {
    if (node.quasis.length === 1 && node.quasis[0].value.raw.trim() === "") {
      return "``";
    }
    return async (...args) => {
      const doc2 = await embedder(...args);
      return doc2 && label({ embed: true, ...doc2.label }, doc2);
    };
  }
}
function getEmbedder(path11) {
  if (isStyledJsx(path11) || isStyledComponents(path11) || isCssProp(path11) || isAngularComponentStyles(path11)) {
    return css_default;
  }
  if (isGraphQL(path11)) {
    return graphql_default;
  }
  if (isHtml(path11)) {
    return embedHtml;
  }
  if (isAngularComponentTemplate(path11)) {
    return embedAngular;
  }
  if (isMarkdown(path11)) {
    return markdown_default;
  }
}
function isMarkdown({ node, parent }) {
  return (parent == null ? void 0 : parent.type) === "TaggedTemplateExpression" && node.quasis.length === 1 && parent.tag.type === "Identifier" && (parent.tag.name === "md" || parent.tag.name === "markdown");
}
function isStyledJsx({ node, parent, grandparent }) {
  return grandparent && node.quasis && parent.type === "JSXExpressionContainer" && grandparent.type === "JSXElement" && grandparent.openingElement.name.name === "style" && grandparent.openingElement.attributes.some(
    (attribute) => attribute.name.name === "jsx"
  ) || (parent == null ? void 0 : parent.type) === "TaggedTemplateExpression" && parent.tag.type === "Identifier" && parent.tag.name === "css" || (parent == null ? void 0 : parent.type) === "TaggedTemplateExpression" && parent.tag.type === "MemberExpression" && parent.tag.object.name === "css" && (parent.tag.property.name === "global" || parent.tag.property.name === "resolve");
}
function isAngularComponentStyles(path11) {
  return path11.match(
    (node) => node.type === "TemplateLiteral",
    (node, name) => isArrayOrTupleExpression(node) && name === "elements",
    (node, name) => isObjectProperty(node) && node.key.type === "Identifier" && node.key.name === "styles" && name === "value",
    ...angularComponentObjectExpressionPredicates
  );
}
function isAngularComponentTemplate(path11) {
  return path11.match(
    (node) => node.type === "TemplateLiteral",
    (node, name) => isObjectProperty(node) && node.key.type === "Identifier" && node.key.name === "template" && name === "value",
    ...angularComponentObjectExpressionPredicates
  );
}
var angularComponentObjectExpressionPredicates = [
  (node, name) => node.type === "ObjectExpression" && name === "properties",
  (node, name) => node.type === "CallExpression" && node.callee.type === "Identifier" && node.callee.name === "Component" && name === "arguments",
  (node, name) => node.type === "Decorator" && name === "expression"
];
function isStyledComponents({ parent }) {
  if (!parent || parent.type !== "TaggedTemplateExpression") {
    return false;
  }
  const tag = parent.tag.type === "ParenthesizedExpression" ? parent.tag.expression : parent.tag;
  switch (tag.type) {
    case "MemberExpression":
      return (
        // styled.foo``
        isStyledIdentifier(tag.object) || // Component.extend``
        isStyledExtend(tag)
      );
    case "CallExpression":
      return (
        // styled(Component)``
        isStyledIdentifier(tag.callee) || tag.callee.type === "MemberExpression" && (tag.callee.object.type === "MemberExpression" && // styled.foo.attrs({})``
        (isStyledIdentifier(tag.callee.object.object) || // Component.extend.attrs({})``
        isStyledExtend(tag.callee.object)) || // styled(Component).attrs({})``
        tag.callee.object.type === "CallExpression" && isStyledIdentifier(tag.callee.object.callee))
      );
    case "Identifier":
      return tag.name === "css";
    default:
      return false;
  }
}
function isCssProp({ parent, grandparent }) {
  return (grandparent == null ? void 0 : grandparent.type) === "JSXAttribute" && parent.type === "JSXExpressionContainer" && grandparent.name.type === "JSXIdentifier" && grandparent.name.name === "css";
}
function isStyledIdentifier(node) {
  return node.type === "Identifier" && node.name === "styled";
}
function isStyledExtend(node) {
  return /^[A-Z]/.test(node.object.name) && node.property.name === "extend";
}
function isGraphQL({ node, parent }) {
  return hasLanguageComment(node, "GraphQL") || parent && (parent.type === "TaggedTemplateExpression" && (parent.tag.type === "MemberExpression" && parent.tag.object.name === "graphql" && parent.tag.property.name === "experimental" || parent.tag.type === "Identifier" && (parent.tag.name === "gql" || parent.tag.name === "graphql")) || parent.type === "CallExpression" && parent.callee.type === "Identifier" && parent.callee.name === "graphql");
}
function hasLanguageComment(node, languageName) {
  return hasComment(
    node,
    CommentCheckFlags.Block | CommentCheckFlags.Leading,
    ({ value }) => value === ` ${languageName} `
  );
}
function isHtml(path11) {
  return hasLanguageComment(path11.node, "HTML") || path11.match(
    (node) => node.type === "TemplateLiteral",
    (node, name) => node.type === "TaggedTemplateExpression" && node.tag.type === "Identifier" && node.tag.name === "html" && name === "quasi"
  );
}
function hasInvalidCookedValue({ quasis }) {
  return quasis.some(({ value: { cooked } }) => cooked === null);
}
var embed_default = embed;

// src/language-js/clean.js
var ignoredProperties = /* @__PURE__ */ new Set(["range", "raw", "comments", "leadingComments", "trailingComments", "innerComments", "extra", "start", "end", "loc", "flags", "errors", "tokens"]);
var removeTemplateElementsValue = (node) => {
  for (const templateElement of node.quasis) {
    delete templateElement.value;
  }
};
function clean(ast, newObj, parent) {
  var _a, _b;
  if (ast.type === "Program") {
    delete newObj.sourceType;
  }
  if ((ast.type === "BigIntLiteral" || ast.type === "BigIntLiteralTypeAnnotation") && newObj.value) {
    newObj.value = newObj.value.toLowerCase();
  }
  if ((ast.type === "BigIntLiteral" || ast.type === "Literal") && newObj.bigint) {
    newObj.bigint = newObj.bigint.toLowerCase();
  }
  if (ast.type === "DecimalLiteral") {
    newObj.value = Number(newObj.value);
  }
  if (ast.type === "Literal" && newObj.decimal) {
    newObj.decimal = Number(newObj.decimal);
  }
  if (ast.type === "EmptyStatement") {
    return null;
  }
  if (ast.type === "JSXText") {
    return null;
  }
  if (ast.type === "JSXExpressionContainer" && (ast.expression.type === "Literal" || ast.expression.type === "StringLiteral") && ast.expression.value === " ") {
    return null;
  }
  if ((ast.type === "Property" || ast.type === "ObjectProperty" || ast.type === "MethodDefinition" || ast.type === "ClassProperty" || ast.type === "ClassMethod" || ast.type === "PropertyDefinition" || ast.type === "TSDeclareMethod" || ast.type === "TSPropertySignature" || ast.type === "ObjectTypeProperty") && typeof ast.key === "object" && ast.key && (ast.key.type === "Literal" || ast.key.type === "NumericLiteral" || ast.key.type === "StringLiteral" || ast.key.type === "Identifier")) {
    delete newObj.key;
  }
  if (ast.type === "JSXElement" && ast.openingElement.name.name === "style" && ast.openingElement.attributes.some((attr) => attr.name.name === "jsx")) {
    for (const {
      type,
      expression: expression2
    } of newObj.children) {
      if (type === "JSXExpressionContainer" && expression2.type === "TemplateLiteral") {
        removeTemplateElementsValue(expression2);
      }
    }
  }
  if (ast.type === "JSXAttribute" && ast.name.name === "css" && ast.value.type === "JSXExpressionContainer" && ast.value.expression.type === "TemplateLiteral") {
    removeTemplateElementsValue(newObj.value.expression);
  }
  if (ast.type === "JSXAttribute" && ((_a = ast.value) == null ? void 0 : _a.type) === "Literal" && /["']|&quot;|&apos;/.test(ast.value.value)) {
    newObj.value.value = string_replace_all_default(
      /* isOptionalObject*/
      false,
      newObj.value.value,
      /["']|&quot;|&apos;/g,
      '"'
    );
  }
  const expression = ast.expression || ast.callee;
  if (ast.type === "Decorator" && expression.type === "CallExpression" && expression.callee.name === "Component" && expression.arguments.length === 1) {
    const astProps = ast.expression.arguments[0].properties;
    for (const [index, prop] of newObj.expression.arguments[0].properties.entries()) {
      switch (astProps[index].key.name) {
        case "styles":
          if (isArrayOrTupleExpression(prop.value)) {
            removeTemplateElementsValue(prop.value.elements[0]);
          }
          break;
        case "template":
          if (prop.value.type === "TemplateLiteral") {
            removeTemplateElementsValue(prop.value);
          }
          break;
      }
    }
  }
  if (ast.type === "TaggedTemplateExpression" && (ast.tag.type === "MemberExpression" || ast.tag.type === "Identifier" && (ast.tag.name === "gql" || ast.tag.name === "graphql" || ast.tag.name === "css" || ast.tag.name === "md" || ast.tag.name === "markdown" || ast.tag.name === "html") || ast.tag.type === "CallExpression")) {
    removeTemplateElementsValue(newObj.quasi);
  }
  if (ast.type === "TemplateLiteral") {
    const hasLanguageComment2 = (_b = ast.leadingComments) == null ? void 0 : _b.some((comment) => is_block_comment_default(comment) && ["GraphQL", "HTML"].some((languageName) => comment.value === ` ${languageName} `));
    if (hasLanguageComment2 || parent.type === "CallExpression" && parent.callee.name === "graphql" || // TODO: check parser
    // `flow` and `typescript` don't have `leadingComments`
    !ast.leadingComments) {
      removeTemplateElementsValue(newObj);
    }
  }
  if ((ast.type === "TSIntersectionType" || ast.type === "TSUnionType") && ast.types.length === 1) {
    return newObj.types[0];
  }
  if (ast.type === "ChainExpression" && ast.expression.type === "TSNonNullExpression") {
    [newObj.type, newObj.expression.type] = [newObj.expression.type, newObj.type];
  }
}
clean.ignoredProperties = ignoredProperties;
var clean_default = clean;

// src/language-js/pragma.js
var import_jest_docblock = __toESM(require_build(), 1);

// src/language-js/utils/get-shebang.js
function getShebang(text) {
  if (!text.startsWith("#!")) {
    return "";
  }
  const index = text.indexOf("\n");
  if (index === -1) {
    return text;
  }
  return text.slice(0, index);
}
var get_shebang_default = getShebang;

// src/language-js/pragma.js
function parseDocBlock(text) {
  const shebang = get_shebang_default(text);
  if (shebang) {
    text = text.slice(shebang.length + 1);
  }
  const docBlock = (0, import_jest_docblock.extract)(text);
  const {
    pragmas: pragmas2,
    comments
  } = (0, import_jest_docblock.parseWithComments)(docBlock);
  return {
    shebang,
    text,
    pragmas: pragmas2,
    comments
  };
}
function insertPragma(originalText) {
  const {
    shebang,
    text,
    pragmas: pragmas2,
    comments
  } = parseDocBlock(originalText);
  const strippedText = (0, import_jest_docblock.strip)(text);
  let docBlock = (0, import_jest_docblock.print)({
    pragmas: {
      format: "",
      ...pragmas2
    },
    comments: comments.trimStart()
  });
  if (false) {
    docBlock = normalizeEndOfLine(docBlock);
  }
  return (shebang ? `${shebang}
` : "") + docBlock + (strippedText.startsWith("\n") ? "\n" : "\n\n") + strippedText;
}

// src/language-js/comments/printer-methods.js
var printer_methods_exports = {};
__export(printer_methods_exports, {
  canAttachComment: () => canAttachComment,
  getCommentChildNodes: () => getCommentChildNodes,
  handleComments: () => handle_comments_exports,
  hasPrettierIgnore: () => hasPrettierIgnore,
  isBlockComment: () => is_block_comment_default,
  isGap: () => isGap,
  printComment: () => printComment2,
  willPrintOwnComments: () => willPrintOwnComments
});

// src/utils/get-preferred-quote.js
function getPreferredQuote(rawContent, preferredQuote) {
  const double = { quote: '"', regex: /"/g, escaped: "&quot;" };
  const single = { quote: "'", regex: /'/g, escaped: "&apos;" };
  const preferred = preferredQuote === "'" ? single : double;
  const alternate = preferred === single ? double : single;
  let result = preferred;
  if (rawContent.includes(preferred.quote) || rawContent.includes(alternate.quote)) {
    const numPreferredQuotes = (rawContent.match(preferred.regex) || []).length;
    const numAlternateQuotes = (rawContent.match(alternate.regex) || []).length;
    result = numPreferredQuotes > numAlternateQuotes ? alternate : preferred;
  }
  return result;
}
var get_preferred_quote_default = getPreferredQuote;

// node_modules/escape-string-regexp/index.js
function escapeStringRegexp(string) {
  if (typeof string !== "string") {
    throw new TypeError("Expected a string");
  }
  return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}

// src/utils/whitespace-utils.js
var _whitespaceCharacters;
var WhitespaceUtils = class {
  constructor(whitespaceCharacters) {
    __privateAdd(this, _whitespaceCharacters, void 0);
    __privateSet(this, _whitespaceCharacters, new Set(whitespaceCharacters));
    if (false) {
      throw new TypeError(`Invalid characters: ${JSON.stringify(whitespaceCharacters)}`);
    }
  }
  getLeadingWhitespaceCount(text) {
    const whitespaceCharacters = __privateGet(this, _whitespaceCharacters);
    let count = 0;
    for (let index = 0; index < text.length && whitespaceCharacters.has(text.charAt(index)); index++) {
      count++;
    }
    return count;
  }
  getTrailingWhitespaceCount(text) {
    const whitespaceCharacters = __privateGet(this, _whitespaceCharacters);
    let count = 0;
    for (let index = text.length - 1; index >= 0 && whitespaceCharacters.has(text.charAt(index)); index--) {
      count++;
    }
    return count;
  }
  getLeadingWhitespace(text) {
    const count = this.getLeadingWhitespaceCount(text);
    return text.slice(0, count);
  }
  getTrailingWhitespace(text) {
    const count = this.getTrailingWhitespaceCount(text);
    return text.slice(text.length - count);
  }
  hasLeadingWhitespace(text) {
    return __privateGet(this, _whitespaceCharacters).has(text.charAt(0));
  }
  hasTrailingWhitespace(text) {
    return __privateGet(this, _whitespaceCharacters).has(at_default(
      /* isOptionalObject*/
      false,
      text,
      -1
    ));
  }
  trimStart(text) {
    const count = this.getLeadingWhitespaceCount(text);
    return text.slice(count);
  }
  trimEnd(text) {
    const count = this.getTrailingWhitespaceCount(text);
    return text.slice(0, text.length - count);
  }
  trim(text) {
    return this.trimEnd(this.trimStart(text));
  }
  split(text, captureWhitespace = false) {
    const pattern = `[${escapeStringRegexp([...__privateGet(this, _whitespaceCharacters)].join(""))}]+`;
    const regexp = new RegExp(captureWhitespace ? `(${pattern})` : pattern);
    return text.split(regexp);
  }
  hasWhitespaceCharacter(text) {
    const whitespaceCharacters = __privateGet(this, _whitespaceCharacters);
    return Array.prototype.some.call(text, (character) => whitespaceCharacters.has(character));
  }
  hasNonWhitespaceCharacter(text) {
    const whitespaceCharacters = __privateGet(this, _whitespaceCharacters);
    return Array.prototype.some.call(text, (character) => !whitespaceCharacters.has(character));
  }
  isWhitespaceOnly(text) {
    const whitespaceCharacters = __privateGet(this, _whitespaceCharacters);
    return Array.prototype.every.call(text, (character) => whitespaceCharacters.has(character));
  }
};
_whitespaceCharacters = new WeakMap();
var whitespace_utils_default = WhitespaceUtils;

// src/language-js/needs-parens.js
function needsParens(path11, options9) {
  var _a, _b, _c, _d, _e, _f;
  if (path11.isRoot) {
    return false;
  }
  const { node, key, parent } = path11;
  if (options9.__isInHtmlInterpolation && !options9.bracketSpacing && endsWithRightBracket(node) && isFollowedByRightBracket(path11)) {
    return true;
  }
  if (isStatement(node)) {
    return false;
  }
  if (node.type === "Identifier") {
    if (((_a = node.extra) == null ? void 0 : _a.parenthesized) && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(node.name)) {
      return true;
    }
    if (key === "left" && (node.name === "async" && !parent.await || node.name === "let") && parent.type === "ForOfStatement") {
      return true;
    }
    if (node.name === "let") {
      const expression = (_b = path11.findAncestor(
        (node2) => node2.type === "ForOfStatement"
      )) == null ? void 0 : _b.left;
      if (expression && startsWithNoLookaheadToken(
        expression,
        (leftmostNode) => leftmostNode === node
      )) {
        return true;
      }
    }
    if (key === "object" && node.name === "let" && parent.type === "MemberExpression" && parent.computed && !parent.optional) {
      const statement = path11.findAncestor(
        (node2) => node2.type === "ExpressionStatement" || node2.type === "ForStatement" || node2.type === "ForInStatement"
      );
      const expression = !statement ? void 0 : statement.type === "ExpressionStatement" ? statement.expression : statement.type === "ForStatement" ? statement.init : statement.left;
      if (expression && startsWithNoLookaheadToken(
        expression,
        (leftmostNode) => leftmostNode === node
      )) {
        return true;
      }
    }
    return false;
  }
  if (node.type === "ObjectExpression" || node.type === "FunctionExpression" || node.type === "ClassExpression" || node.type === "DoExpression") {
    const expression = (_c = path11.findAncestor(
      (node2) => node2.type === "ExpressionStatement"
    )) == null ? void 0 : _c.expression;
    if (expression && startsWithNoLookaheadToken(
      expression,
      (leftmostNode) => leftmostNode === node
    )) {
      return true;
    }
  }
  switch (parent.type) {
    case "ParenthesizedExpression":
      return false;
    case "ClassDeclaration":
    case "ClassExpression":
      if (key === "superClass" && (node.type === "ArrowFunctionExpression" || node.type === "AssignmentExpression" || node.type === "AwaitExpression" || node.type === "BinaryExpression" || node.type === "ConditionalExpression" || node.type === "LogicalExpression" || node.type === "NewExpression" || node.type === "ObjectExpression" || node.type === "SequenceExpression" || node.type === "TaggedTemplateExpression" || node.type === "UnaryExpression" || node.type === "UpdateExpression" || node.type === "YieldExpression" || node.type === "TSNonNullExpression")) {
        return true;
      }
      break;
    case "ExportDefaultDeclaration":
      return (
        // `export default function` or `export default class` can't be followed by
        // anything after. So an expression like `export default (function(){}).toString()`
        // needs to be followed by a parentheses
        shouldWrapFunctionForExportDefault(path11, options9) || // `export default (foo, bar)` also needs parentheses
        node.type === "SequenceExpression"
      );
    case "Decorator":
      if (key === "expression") {
        if (isMemberExpression(node) && node.computed) {
          return true;
        }
        let hasCallExpression = false;
        let hasMemberExpression = false;
        let current = node;
        while (current) {
          switch (current.type) {
            case "MemberExpression":
              hasMemberExpression = true;
              current = current.object;
              break;
            case "CallExpression":
              if (
                /** @(x().y) */
                hasMemberExpression || /** @(x().y()) */
                hasCallExpression
              ) {
                return options9.parser !== "typescript";
              }
              hasCallExpression = true;
              current = current.callee;
              break;
            case "Identifier":
              return false;
            case "TaggedTemplateExpression":
              return options9.parser !== "typescript";
            default:
              return true;
          }
        }
        return true;
      }
      break;
    case "ArrowFunctionExpression":
      if (key === "body" && node.type !== "SequenceExpression" && // these have parens added anyway
      startsWithNoLookaheadToken(
        node,
        (node2) => node2.type === "ObjectExpression"
      )) {
        return true;
      }
      break;
    case "TypeAnnotation":
      if (path11.match(
        void 0,
        void 0,
        (node2, key2) => key2 === "returnType" && node2.type === "ArrowFunctionExpression"
      ) && includesFunctionTypeInObjectType(node)) {
        return true;
      }
      break;
  }
  switch (node.type) {
    case "UpdateExpression":
      if (parent.type === "UnaryExpression") {
        return node.prefix && (node.operator === "++" && parent.operator === "+" || node.operator === "--" && parent.operator === "-");
      }
    case "UnaryExpression":
      switch (parent.type) {
        case "UnaryExpression":
          return node.operator === parent.operator && (node.operator === "+" || node.operator === "-");
        case "BindExpression":
          return true;
        case "MemberExpression":
        case "OptionalMemberExpression":
          return key === "object";
        case "TaggedTemplateExpression":
          return true;
        case "NewExpression":
        case "CallExpression":
        case "OptionalCallExpression":
          return key === "callee";
        case "BinaryExpression":
          return key === "left" && parent.operator === "**";
        case "TSNonNullExpression":
          return true;
        default:
          return false;
      }
    case "BinaryExpression":
      if (parent.type === "UpdateExpression") {
        return true;
      }
      if (node.operator === "in" && isPathInForStatementInitializer(path11)) {
        return true;
      }
      if (node.operator === "|>" && ((_d = node.extra) == null ? void 0 : _d.parenthesized)) {
        const grandParent = path11.grandparent;
        if (grandParent.type === "BinaryExpression" && grandParent.operator === "|>") {
          return true;
        }
      }
    case "TSTypeAssertion":
    case "TSAsExpression":
    case "TSSatisfiesExpression":
    case "LogicalExpression":
      switch (parent.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
          return !isTSTypeExpression(node);
        case "ConditionalExpression":
          return isTSTypeExpression(node);
        case "CallExpression":
        case "NewExpression":
        case "OptionalCallExpression":
          return key === "callee";
        case "ClassExpression":
        case "ClassDeclaration":
          return key === "superClass";
        case "TSTypeAssertion":
        case "TaggedTemplateExpression":
        case "UnaryExpression":
        case "JSXSpreadAttribute":
        case "SpreadElement":
        case "BindExpression":
        case "AwaitExpression":
        case "TSNonNullExpression":
        case "UpdateExpression":
          return true;
        case "MemberExpression":
        case "OptionalMemberExpression":
          return key === "object";
        case "AssignmentExpression":
        case "AssignmentPattern":
          return key === "left" && (node.type === "TSTypeAssertion" || isTSTypeExpression(node));
        case "LogicalExpression":
          if (node.type === "LogicalExpression") {
            return parent.operator !== node.operator;
          }
        case "BinaryExpression": {
          const { operator, type } = node;
          if (!operator && type !== "TSTypeAssertion") {
            return true;
          }
          const precedence = getPrecedence(operator);
          const parentOperator = parent.operator;
          const parentPrecedence = getPrecedence(parentOperator);
          if (parentPrecedence > precedence) {
            return true;
          }
          if (key === "right" && parentPrecedence === precedence) {
            return true;
          }
          if (parentPrecedence === precedence && !shouldFlatten(parentOperator, operator)) {
            return true;
          }
          if (parentPrecedence < precedence && operator === "%") {
            return parentOperator === "+" || parentOperator === "-";
          }
          if (isBitwiseOperator(parentOperator)) {
            return true;
          }
          return false;
        }
        default:
          return false;
      }
    case "SequenceExpression":
      switch (parent.type) {
        case "ReturnStatement":
          return false;
        case "ForStatement":
          return false;
        case "ExpressionStatement":
          return key !== "expression";
        case "ArrowFunctionExpression":
          return key !== "body";
        default:
          return true;
      }
    case "YieldExpression":
      if (parent.type === "AwaitExpression") {
        return true;
      }
    case "AwaitExpression":
      switch (parent.type) {
        case "TaggedTemplateExpression":
        case "UnaryExpression":
        case "LogicalExpression":
        case "SpreadElement":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "BindExpression":
          return true;
        case "MemberExpression":
        case "OptionalMemberExpression":
          return key === "object";
        case "NewExpression":
        case "CallExpression":
        case "OptionalCallExpression":
          return key === "callee";
        case "ConditionalExpression":
          return key === "test";
        case "BinaryExpression":
          if (!node.argument && parent.operator === "|>") {
            return false;
          }
          return true;
        default:
          return false;
      }
    case "TSFunctionType":
      if (path11.match(
        (node2) => node2.type === "TSFunctionType",
        (node2, key2) => key2 === "typeAnnotation" && node2.type === "TSTypeAnnotation",
        (node2, key2) => key2 === "returnType" && node2.type === "ArrowFunctionExpression"
      )) {
        return true;
      }
    case "TSConditionalType":
    case "TSConstructorType":
      if (key === "extendsType" && parent.type === "TSConditionalType") {
        if (node.type === "TSConditionalType") {
          return true;
        }
        let { typeAnnotation } = node.returnType || node.typeAnnotation;
        if (typeAnnotation.type === "TSTypePredicate" && typeAnnotation.typeAnnotation) {
          typeAnnotation = typeAnnotation.typeAnnotation.typeAnnotation;
        }
        if (typeAnnotation.type === "TSInferType" && typeAnnotation.typeParameter.constraint) {
          return true;
        }
      }
      if (key === "checkType" && parent.type === "TSConditionalType") {
        return true;
      }
    case "TSUnionType":
    case "TSIntersectionType":
      if ((parent.type === "TSUnionType" || parent.type === "TSIntersectionType") && parent.types.length > 1 && (!node.types || node.types.length > 1)) {
        return true;
      }
    case "TSInferType":
      if (node.type === "TSInferType" && parent.type === "TSRestType") {
        return false;
      }
    case "TSTypeOperator":
      return parent.type === "TSArrayType" || parent.type === "TSOptionalType" || parent.type === "TSRestType" || key === "objectType" && parent.type === "TSIndexedAccessType" || parent.type === "TSTypeOperator" || parent.type === "TSTypeAnnotation" && path11.grandparent.type.startsWith("TSJSDoc");
    case "TSTypeQuery":
      return key === "objectType" && parent.type === "TSIndexedAccessType" || key === "elementType" && parent.type === "TSArrayType";
    case "ArrayTypeAnnotation":
      return parent.type === "NullableTypeAnnotation";
    case "IntersectionTypeAnnotation":
    case "UnionTypeAnnotation":
      return parent.type === "ArrayTypeAnnotation" || parent.type === "NullableTypeAnnotation" || parent.type === "IntersectionTypeAnnotation" || parent.type === "UnionTypeAnnotation" || key === "objectType" && (parent.type === "IndexedAccessType" || parent.type === "OptionalIndexedAccessType");
    case "NullableTypeAnnotation":
      return parent.type === "ArrayTypeAnnotation" || key === "objectType" && (parent.type === "IndexedAccessType" || parent.type === "OptionalIndexedAccessType");
    case "FunctionTypeAnnotation": {
      if (path11.match(
        void 0,
        (node2, key2) => key2 === "typeAnnotation" && node2.type === "TypeAnnotation",
        (node2, key2) => key2 === "returnType" && node2.type === "ArrowFunctionExpression"
      )) {
        return true;
      }
      const ancestor = parent.type === "NullableTypeAnnotation" ? path11.grandparent : parent;
      return ancestor.type === "UnionTypeAnnotation" || ancestor.type === "IntersectionTypeAnnotation" || ancestor.type === "ArrayTypeAnnotation" || key === "objectType" && (ancestor.type === "IndexedAccessType" || ancestor.type === "OptionalIndexedAccessType") || // We should check ancestor's parent to know whether the parentheses
      // are really needed, but since ??T doesn't make sense this check
      // will almost never be true.
      ancestor.type === "NullableTypeAnnotation" || // See #5283
      parent.type === "FunctionTypeParam" && parent.name === null && getFunctionParameters(node).some(
        (param) => {
          var _a2;
          return ((_a2 = param.typeAnnotation) == null ? void 0 : _a2.type) === "NullableTypeAnnotation";
        }
      );
    }
    case "OptionalIndexedAccessType":
      return key === "objectType" && parent.type === "IndexedAccessType";
    case "TypeofTypeAnnotation":
      return key === "objectType" && (parent.type === "IndexedAccessType" || parent.type === "OptionalIndexedAccessType");
    case "StringLiteral":
    case "NumericLiteral":
    case "Literal":
      if (typeof node.value === "string" && parent.type === "ExpressionStatement" && !parent.directive) {
        const grandParent = path11.grandparent;
        return grandParent.type === "Program" || grandParent.type === "BlockStatement";
      }
      return key === "object" && parent.type === "MemberExpression" && typeof node.value === "number";
    case "AssignmentExpression": {
      const grandParent = path11.grandparent;
      if (key === "body" && parent.type === "ArrowFunctionExpression") {
        return true;
      }
      if (key === "key" && (parent.type === "ClassProperty" || parent.type === "PropertyDefinition") && parent.computed) {
        return false;
      }
      if ((key === "init" || key === "update") && parent.type === "ForStatement") {
        return false;
      }
      if (parent.type === "ExpressionStatement") {
        return node.left.type === "ObjectPattern";
      }
      if (key === "key" && parent.type === "TSPropertySignature") {
        return false;
      }
      if (parent.type === "AssignmentExpression") {
        return false;
      }
      if (parent.type === "SequenceExpression" && grandParent.type === "ForStatement" && (grandParent.init === parent || grandParent.update === parent)) {
        return false;
      }
      if (key === "value" && parent.type === "Property" && grandParent.type === "ObjectPattern" && grandParent.properties.includes(parent)) {
        return false;
      }
      if (parent.type === "NGChainedExpression") {
        return false;
      }
      return true;
    }
    case "ConditionalExpression":
      switch (parent.type) {
        case "TaggedTemplateExpression":
        case "UnaryExpression":
        case "SpreadElement":
        case "BinaryExpression":
        case "LogicalExpression":
        case "NGPipeExpression":
        case "ExportDefaultDeclaration":
        case "AwaitExpression":
        case "JSXSpreadAttribute":
        case "TSTypeAssertion":
        case "TypeCastExpression":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
          return true;
        case "NewExpression":
        case "CallExpression":
        case "OptionalCallExpression":
          return key === "callee";
        case "ConditionalExpression":
          return key === "test";
        case "MemberExpression":
        case "OptionalMemberExpression":
          return key === "object";
        default:
          return false;
      }
    case "FunctionExpression":
      switch (parent.type) {
        case "NewExpression":
        case "CallExpression":
        case "OptionalCallExpression":
          return key === "callee";
        case "TaggedTemplateExpression":
          return true;
        default:
          return false;
      }
    case "ArrowFunctionExpression":
      switch (parent.type) {
        case "BinaryExpression":
          return parent.operator !== "|>" || ((_e = node.extra) == null ? void 0 : _e.parenthesized);
        case "NewExpression":
        case "CallExpression":
        case "OptionalCallExpression":
          return key === "callee";
        case "MemberExpression":
        case "OptionalMemberExpression":
          return key === "object";
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "BindExpression":
        case "TaggedTemplateExpression":
        case "UnaryExpression":
        case "LogicalExpression":
        case "AwaitExpression":
        case "TSTypeAssertion":
          return true;
        case "ConditionalExpression":
          return key === "test";
        default:
          return false;
      }
    case "ClassExpression":
      if (is_non_empty_array_default(node.decorators)) {
        return true;
      }
      switch (parent.type) {
        case "NewExpression":
          return key === "callee";
        default:
          return false;
      }
    case "OptionalMemberExpression":
    case "OptionalCallExpression":
    case "CallExpression":
    case "MemberExpression":
      if (shouldAddParenthesesToChainElement(path11)) {
        return true;
      }
    case "TaggedTemplateExpression":
    case "TSNonNullExpression":
      if (key === "callee" && (parent.type === "BindExpression" || parent.type === "NewExpression")) {
        let object = node;
        while (object) {
          switch (object.type) {
            case "CallExpression":
            case "OptionalCallExpression":
              return true;
            case "MemberExpression":
            case "OptionalMemberExpression":
            case "BindExpression":
              object = object.object;
              break;
            case "TaggedTemplateExpression":
              object = object.tag;
              break;
            case "TSNonNullExpression":
              object = object.expression;
              break;
            default:
              return false;
          }
        }
      }
      return false;
    case "BindExpression":
      return key === "callee" && (parent.type === "BindExpression" || parent.type === "NewExpression") || key === "object" && isMemberExpression(parent);
    case "NGPipeExpression":
      if (parent.type === "NGRoot" || parent.type === "NGMicrosyntaxExpression" || parent.type === "ObjectProperty" && // Preserve parens for compatibility with AngularJS expressions
      !((_f = node.extra) == null ? void 0 : _f.parenthesized) || isArrayOrTupleExpression(parent) || key === "arguments" && isCallExpression(parent) || key === "right" && parent.type === "NGPipeExpression" || key === "property" && parent.type === "MemberExpression" || parent.type === "AssignmentExpression") {
        return false;
      }
      return true;
    case "JSXFragment":
    case "JSXElement":
      return key === "callee" || key === "left" && parent.type === "BinaryExpression" && parent.operator === "<" || !isArrayOrTupleExpression(parent) && parent.type !== "ArrowFunctionExpression" && parent.type !== "AssignmentExpression" && parent.type !== "AssignmentPattern" && parent.type !== "BinaryExpression" && parent.type !== "NewExpression" && parent.type !== "ConditionalExpression" && parent.type !== "ExpressionStatement" && parent.type !== "JsExpressionRoot" && parent.type !== "JSXAttribute" && parent.type !== "JSXElement" && parent.type !== "JSXExpressionContainer" && parent.type !== "JSXFragment" && parent.type !== "LogicalExpression" && !isCallExpression(parent) && !isObjectProperty(parent) && parent.type !== "ReturnStatement" && parent.type !== "ThrowStatement" && parent.type !== "TypeCastExpression" && parent.type !== "VariableDeclarator" && parent.type !== "YieldExpression";
  }
  return false;
}
var isStatement = createTypeCheckFunction([
  "BlockStatement",
  "BreakStatement",
  "ClassBody",
  "ClassDeclaration",
  "ClassMethod",
  "ClassProperty",
  "PropertyDefinition",
  "ClassPrivateProperty",
  "ContinueStatement",
  "DebuggerStatement",
  "DeclareClass",
  "DeclareExportAllDeclaration",
  "DeclareExportDeclaration",
  "DeclareFunction",
  "DeclareInterface",
  "DeclareModule",
  "DeclareModuleExports",
  "DeclareVariable",
  "DeclareEnum",
  "DoWhileStatement",
  "EnumDeclaration",
  "ExportAllDeclaration",
  "ExportDefaultDeclaration",
  "ExportNamedDeclaration",
  "ExpressionStatement",
  "ForInStatement",
  "ForOfStatement",
  "ForStatement",
  "FunctionDeclaration",
  "IfStatement",
  "ImportDeclaration",
  "InterfaceDeclaration",
  "LabeledStatement",
  "MethodDefinition",
  "ReturnStatement",
  "SwitchStatement",
  "ThrowStatement",
  "TryStatement",
  "TSDeclareFunction",
  "TSEnumDeclaration",
  "TSImportEqualsDeclaration",
  "TSInterfaceDeclaration",
  "TSModuleDeclaration",
  "TSNamespaceExportDeclaration",
  "TypeAlias",
  "VariableDeclaration",
  "WhileStatement",
  "WithStatement"
]);
function isPathInForStatementInitializer(path11) {
  let i = 0;
  let { node } = path11;
  while (node) {
    const parent = path11.getParentNode(i++);
    if ((parent == null ? void 0 : parent.type) === "ForStatement" && parent.init === node) {
      return true;
    }
    node = parent;
  }
  return false;
}
function includesFunctionTypeInObjectType(node) {
  return hasNode(
    node,
    (n1) => n1.type === "ObjectTypeAnnotation" && hasNode(
      n1,
      (n2) => n2.type === "FunctionTypeAnnotation" || void 0
    ) || void 0
  );
}
function endsWithRightBracket(node) {
  return isObjectOrRecordExpression(node);
}
function isFollowedByRightBracket(path11) {
  const { parent, key } = path11;
  switch (parent.type) {
    case "NGPipeExpression":
      if (key === "arguments" && path11.isLast) {
        return path11.callParent(isFollowedByRightBracket);
      }
      break;
    case "ObjectProperty":
      if (key === "value") {
        return path11.callParent(() => path11.key === "properties" && path11.isLast);
      }
      break;
    case "BinaryExpression":
    case "LogicalExpression":
      if (key === "right") {
        return path11.callParent(isFollowedByRightBracket);
      }
      break;
    case "ConditionalExpression":
      if (key === "alternate") {
        return path11.callParent(isFollowedByRightBracket);
      }
      break;
    case "UnaryExpression":
      if (parent.prefix) {
        return path11.callParent(isFollowedByRightBracket);
      }
      break;
  }
  return false;
}
function shouldWrapFunctionForExportDefault(path11, options9) {
  const { node, parent } = path11;
  if (node.type === "FunctionExpression" || node.type === "ClassExpression") {
    return parent.type === "ExportDefaultDeclaration" || // in some cases the function is already wrapped
    // (e.g. `export default (function() {})();`)
    // in this case we don't need to add extra parens
    !needsParens(path11, options9);
  }
  if (!hasNakedLeftSide(node) || parent.type !== "ExportDefaultDeclaration" && needsParens(path11, options9)) {
    return false;
  }
  return path11.call(
    () => shouldWrapFunctionForExportDefault(path11, options9),
    ...getLeftSidePathName(node)
  );
}
function shouldAddParenthesesToChainElement(path11) {
  const { node, parent, grandparent, key } = path11;
  if ((node.type === "OptionalMemberExpression" || node.type === "OptionalCallExpression") && (key === "object" && parent.type === "MemberExpression" || key === "callee" && (parent.type === "CallExpression" || parent.type === "NewExpression") || parent.type === "TSNonNullExpression" && grandparent.type === "MemberExpression" && grandparent.object === parent)) {
    return true;
  }
  if (path11.match(
    () => node.type === "CallExpression" || node.type === "MemberExpression",
    (node2, name) => name === "expression" && node2.type === "ChainExpression"
  ) && (path11.match(
    void 0,
    void 0,
    (node2, name) => name === "callee" && (node2.type === "CallExpression" && !node2.optional || node2.type === "NewExpression") || name === "object" && node2.type === "MemberExpression" && !node2.optional
  ) || path11.match(
    void 0,
    void 0,
    (node2, name) => name === "expression" && node2.type === "TSNonNullExpression",
    (node2, name) => name === "object" && node2.type === "MemberExpression"
  ))) {
    return true;
  }
  if (path11.match(
    () => node.type === "CallExpression" || node.type === "MemberExpression",
    (node2, name) => name === "expression" && node2.type === "TSNonNullExpression",
    (node2, name) => name === "expression" && node2.type === "ChainExpression",
    (node2, name) => name === "object" && node2.type === "MemberExpression"
  )) {
    return true;
  }
  return false;
}
var needs_parens_default = needsParens;

// src/language-js/print/jsx.js
var jsxWhitespaceUtils = new whitespace_utils_default(" \n\r	");
var isEmptyStringOrAnyLine = (doc2) => doc2 === "" || doc2 === line || doc2 === hardline || doc2 === softline;
function printJsxElementInternal(path11, options9, print4) {
  var _a, _b;
  const {
    node
  } = path11;
  if (node.type === "JSXElement" && isEmptyJsxElement(node)) {
    return [print4("openingElement"), print4("closingElement")];
  }
  const openingLines = node.type === "JSXElement" ? print4("openingElement") : print4("openingFragment");
  const closingLines = node.type === "JSXElement" ? print4("closingElement") : print4("closingFragment");
  if (node.children.length === 1 && node.children[0].type === "JSXExpressionContainer" && (node.children[0].expression.type === "TemplateLiteral" || node.children[0].expression.type === "TaggedTemplateExpression")) {
    return [openingLines, ...path11.map(print4, "children"), closingLines];
  }
  node.children = node.children.map((child) => {
    if (isJsxWhitespaceExpression(child)) {
      return {
        type: "JSXText",
        value: " ",
        raw: " "
      };
    }
    return child;
  });
  const containsTag = node.children.some(isJsxElement);
  const containsMultipleExpressions = node.children.filter((child) => child.type === "JSXExpressionContainer").length > 1;
  const containsMultipleAttributes = node.type === "JSXElement" && node.openingElement.attributes.length > 1;
  let forcedBreak = willBreak(openingLines) || containsTag || containsMultipleAttributes || containsMultipleExpressions;
  const isMdxBlock = path11.parent.rootMarker === "mdx";
  const rawJsxWhitespace = options9.singleQuote ? "{' '}" : '{" "}';
  const jsxWhitespace = isMdxBlock ? " " : ifBreak([rawJsxWhitespace, softline], " ");
  const isFacebookTranslationTag = ((_b = (_a = node.openingElement) == null ? void 0 : _a.name) == null ? void 0 : _b.name) === "fbt";
  const children = printJsxChildren(path11, options9, print4, jsxWhitespace, isFacebookTranslationTag);
  const containsText = node.children.some((child) => isMeaningfulJsxText(child));
  for (let i = children.length - 2; i >= 0; i--) {
    const isPairOfEmptyStrings = children[i] === "" && children[i + 1] === "";
    const isPairOfHardlines = children[i] === hardline && children[i + 1] === "" && children[i + 2] === hardline;
    const isLineFollowedByJsxWhitespace = (children[i] === softline || children[i] === hardline) && children[i + 1] === "" && children[i + 2] === jsxWhitespace;
    const isJsxWhitespaceFollowedByLine = children[i] === jsxWhitespace && children[i + 1] === "" && (children[i + 2] === softline || children[i + 2] === hardline);
    const isDoubleJsxWhitespace = children[i] === jsxWhitespace && children[i + 1] === "" && children[i + 2] === jsxWhitespace;
    const isPairOfHardOrSoftLines = children[i] === softline && children[i + 1] === "" && children[i + 2] === hardline || children[i] === hardline && children[i + 1] === "" && children[i + 2] === softline;
    if (isPairOfHardlines && containsText || isPairOfEmptyStrings || isLineFollowedByJsxWhitespace || isDoubleJsxWhitespace || isPairOfHardOrSoftLines) {
      children.splice(i, 2);
    } else if (isJsxWhitespaceFollowedByLine) {
      children.splice(i + 1, 2);
    }
  }
  while (children.length > 0 && isEmptyStringOrAnyLine(at_default(
    /* isOptionalObject*/
    false,
    children,
    -1
  ))) {
    children.pop();
  }
  while (children.length > 1 && isEmptyStringOrAnyLine(children[0]) && isEmptyStringOrAnyLine(children[1])) {
    children.shift();
    children.shift();
  }
  const multilineChildren = [];
  for (const [i, child] of children.entries()) {
    if (child === jsxWhitespace) {
      if (i === 1 && children[i - 1] === "") {
        if (children.length === 2) {
          multilineChildren.push(rawJsxWhitespace);
          continue;
        }
        multilineChildren.push([rawJsxWhitespace, hardline]);
        continue;
      } else if (i === children.length - 1) {
        multilineChildren.push(rawJsxWhitespace);
        continue;
      } else if (children[i - 1] === "" && children[i - 2] === hardline) {
        multilineChildren.push(rawJsxWhitespace);
        continue;
      }
    }
    multilineChildren.push(child);
    if (willBreak(child)) {
      forcedBreak = true;
    }
  }
  const content = containsText ? fill(multilineChildren) : group(multilineChildren, {
    shouldBreak: true
  });
  if (isMdxBlock) {
    return content;
  }
  const multiLineElem = group([openingLines, indent([hardline, content]), hardline, closingLines]);
  if (forcedBreak) {
    return multiLineElem;
  }
  return conditionalGroup([group([openingLines, ...children, closingLines]), multiLineElem]);
}
function printJsxChildren(path11, options9, print4, jsxWhitespace, isFacebookTranslationTag) {
  const parts = [];
  path11.each(({
    node,
    next
  }) => {
    if (node.type === "JSXText") {
      const text = rawText(node);
      if (isMeaningfulJsxText(node)) {
        const words = jsxWhitespaceUtils.split(
          text,
          /* captureWhitespace */
          true
        );
        if (words[0] === "") {
          parts.push("");
          words.shift();
          if (/\n/.test(words[0])) {
            parts.push(separatorWithWhitespace(isFacebookTranslationTag, words[1], node, next));
          } else {
            parts.push(jsxWhitespace);
          }
          words.shift();
        }
        let endWhitespace;
        if (at_default(
          /* isOptionalObject*/
          false,
          words,
          -1
        ) === "") {
          words.pop();
          endWhitespace = words.pop();
        }
        if (words.length === 0) {
          return;
        }
        for (const [i, word] of words.entries()) {
          if (i % 2 === 1) {
            parts.push(line);
          } else {
            parts.push(word);
          }
        }
        if (endWhitespace !== void 0) {
          if (/\n/.test(endWhitespace)) {
            parts.push(separatorWithWhitespace(isFacebookTranslationTag, at_default(
              /* isOptionalObject*/
              false,
              parts,
              -1
            ), node, next));
          } else {
            parts.push(jsxWhitespace);
          }
        } else {
          parts.push(separatorNoWhitespace(isFacebookTranslationTag, at_default(
            /* isOptionalObject*/
            false,
            parts,
            -1
          ), node, next));
        }
      } else if (/\n/.test(text)) {
        if (text.match(/\n/g).length > 1) {
          parts.push("", hardline);
        }
      } else {
        parts.push("", jsxWhitespace);
      }
    } else {
      const printedChild = print4();
      parts.push(printedChild);
      const directlyFollowedByMeaningfulText = next && isMeaningfulJsxText(next);
      if (directlyFollowedByMeaningfulText) {
        const trimmed = jsxWhitespaceUtils.trim(rawText(next));
        const [firstWord] = jsxWhitespaceUtils.split(trimmed);
        parts.push(separatorNoWhitespace(isFacebookTranslationTag, firstWord, node, next));
      } else {
        parts.push(hardline);
      }
    }
  }, "children");
  return parts;
}
function separatorNoWhitespace(isFacebookTranslationTag, child, childNode, nextNode) {
  if (isFacebookTranslationTag) {
    return "";
  }
  if (childNode.type === "JSXElement" && !childNode.closingElement || (nextNode == null ? void 0 : nextNode.type) === "JSXElement" && !nextNode.closingElement) {
    return child.length === 1 ? softline : hardline;
  }
  return softline;
}
function separatorWithWhitespace(isFacebookTranslationTag, child, childNode, nextNode) {
  if (isFacebookTranslationTag) {
    return hardline;
  }
  if (child.length === 1) {
    return childNode.type === "JSXElement" && !childNode.closingElement || (nextNode == null ? void 0 : nextNode.type) === "JSXElement" && !nextNode.closingElement ? hardline : softline;
  }
  return hardline;
}
var NO_WRAP_PARENTS = /* @__PURE__ */ new Set(["ArrayExpression", "TupleExpression", "JSXAttribute", "JSXElement", "JSXExpressionContainer", "JSXFragment", "ExpressionStatement", "CallExpression", "OptionalCallExpression", "ConditionalExpression", "JsExpressionRoot"]);
function maybeWrapJsxElementInParens(path11, elem, options9) {
  const {
    parent
  } = path11;
  if (NO_WRAP_PARENTS.has(parent.type)) {
    return elem;
  }
  const shouldBreak = path11.match(void 0, (node) => node.type === "ArrowFunctionExpression", isCallExpression, (node) => node.type === "JSXExpressionContainer");
  const needsParens2 = needs_parens_default(path11, options9);
  return group([needsParens2 ? "" : ifBreak("("), indent([softline, elem]), softline, needsParens2 ? "" : ifBreak(")")], {
    shouldBreak
  });
}
function printJsxAttribute(path11, options9, print4) {
  const {
    node
  } = path11;
  const parts = [];
  parts.push(print4("name"));
  if (node.value) {
    let res;
    if (isStringLiteral(node.value)) {
      const raw = rawText(node.value);
      let final = string_replace_all_default(
        /* isOptionalObject*/
        false,
        string_replace_all_default(
          /* isOptionalObject*/
          false,
          raw.slice(1, -1),
          "&apos;",
          "'"
        ),
        "&quot;",
        '"'
      );
      const {
        escaped,
        quote,
        regex
      } = get_preferred_quote_default(final, options9.jsxSingleQuote ? "'" : '"');
      final = final.replace(regex, escaped);
      res = path11.call(() => printComments(path11, replaceEndOfLine(quote + final + quote), options9), "value");
    } else {
      res = print4("value");
    }
    parts.push("=", res);
  }
  return parts;
}
function printJsxExpressionContainer(path11, options9, print4) {
  const {
    node
  } = path11;
  const shouldInline = (node2, parent) => node2.type === "JSXEmptyExpression" || !hasComment(node2) && (isArrayOrTupleExpression(node2) || isObjectOrRecordExpression(node2) || node2.type === "ArrowFunctionExpression" || node2.type === "AwaitExpression" && (shouldInline(node2.argument, node2) || node2.argument.type === "JSXElement") || isCallExpression(node2) || node2.type === "ChainExpression" && isCallExpression(node2.expression) || node2.type === "FunctionExpression" || node2.type === "TemplateLiteral" || node2.type === "TaggedTemplateExpression" || node2.type === "DoExpression" || isJsxElement(parent) && (node2.type === "ConditionalExpression" || isBinaryish(node2)));
  if (shouldInline(node.expression, path11.parent)) {
    return group(["{", print4("expression"), lineSuffixBoundary, "}"]);
  }
  return group(["{", indent([softline, print4("expression")]), softline, lineSuffixBoundary, "}"]);
}
function printJsxOpeningElement(path11, options9, print4) {
  var _a, _b;
  const {
    node
  } = path11;
  const nameHasComments = hasComment(node.name) || hasComment(node.typeParameters);
  if (node.selfClosing && node.attributes.length === 0 && !nameHasComments) {
    return ["<", print4("name"), print4("typeParameters"), " />"];
  }
  if (((_a = node.attributes) == null ? void 0 : _a.length) === 1 && node.attributes[0].value && isStringLiteral(node.attributes[0].value) && !node.attributes[0].value.value.includes("\n") && // We should break for the following cases:
  // <div
  //   // comment
  //   attr="value"
  // >
  // <div
  //   attr="value"
  //   // comment
  // >
  !nameHasComments && !hasComment(node.attributes[0])) {
    return group(["<", print4("name"), print4("typeParameters"), " ", ...path11.map(print4, "attributes"), node.selfClosing ? " />" : ">"]);
  }
  const shouldBreak = (_b = node.attributes) == null ? void 0 : _b.some((attr) => attr.value && isStringLiteral(attr.value) && attr.value.value.includes("\n"));
  const attributeLine = options9.singleAttributePerLine && node.attributes.length > 1 ? hardline : line;
  return group(["<", print4("name"), print4("typeParameters"), indent(path11.map(() => [attributeLine, print4()], "attributes")), ...printEndOfOpeningTag(node, options9, nameHasComments)], {
    shouldBreak
  });
}
function printEndOfOpeningTag(node, options9, nameHasComments) {
  if (node.selfClosing) {
    return [line, "/>"];
  }
  const bracketSameLine = shouldPrintBracketSameLine(node, options9, nameHasComments);
  if (bracketSameLine) {
    return [">"];
  }
  return [softline, ">"];
}
function shouldPrintBracketSameLine(node, options9, nameHasComments) {
  const lastAttrHasTrailingComments = node.attributes.length > 0 && hasComment(at_default(
    /* isOptionalObject*/
    false,
    node.attributes,
    -1
  ), CommentCheckFlags.Trailing);
  return (
    // Simple tags (no attributes and no comment in tag name) should be
    // kept unbroken regardless of `bracketSameLine`.
    // jsxBracketSameLine is deprecated in favour of bracketSameLine,
    // but is still needed for backwards compatibility.
    node.attributes.length === 0 && !nameHasComments || (options9.bracketSameLine || options9.jsxBracketSameLine) && // We should print the bracket in a new line for the following cases:
    // <div
    //   // comment
    // >
    // <div
    //   attr // comment
    // >
    (!nameHasComments || node.attributes.length > 0) && !lastAttrHasTrailingComments
  );
}
function printJsxClosingElement(path11, options9, print4) {
  const {
    node
  } = path11;
  const parts = [];
  parts.push("</");
  const printed = print4("name");
  if (hasComment(node.name, CommentCheckFlags.Leading | CommentCheckFlags.Line)) {
    parts.push(indent([hardline, printed]), hardline);
  } else if (hasComment(node.name, CommentCheckFlags.Leading | CommentCheckFlags.Block)) {
    parts.push(" ", printed);
  } else {
    parts.push(printed);
  }
  parts.push(">");
  return parts;
}
function printJsxOpeningClosingFragment(path11, options9) {
  const {
    node
  } = path11;
  const nodeHasComment = hasComment(node);
  const hasOwnLineComment = hasComment(node, CommentCheckFlags.Line);
  const isOpeningFragment = node.type === "JSXOpeningFragment";
  return [isOpeningFragment ? "<" : "</", indent([hasOwnLineComment ? hardline : nodeHasComment && !isOpeningFragment ? " " : "", printDanglingComments(path11, options9)]), hasOwnLineComment ? hardline : "", ">"];
}
function printJsxElement(path11, options9, print4) {
  const elem = printComments(path11, printJsxElementInternal(path11, options9, print4), options9);
  return maybeWrapJsxElementInParens(path11, elem, options9);
}
function printJsxEmptyExpression(path11, options9) {
  const {
    node
  } = path11;
  const requiresHardline = hasComment(node, CommentCheckFlags.Line);
  return [printDanglingComments(path11, options9, {
    indent: requiresHardline
  }), requiresHardline ? hardline : ""];
}
function printJsxSpreadAttributeOrChild(path11, options9, print4) {
  const {
    node
  } = path11;
  return ["{", path11.call(({
    node: node2
  }) => {
    const printed = ["...", print4()];
    if (!hasComment(node2) || !willPrintOwnComments(path11)) {
      return printed;
    }
    return [indent([softline, printComments(path11, printed, options9)]), softline];
  }, node.type === "JSXSpreadAttribute" ? "argument" : "expression"), "}"];
}
function printJsx(path11, options9, print4) {
  const {
    node
  } = path11;
  if (!node.type.startsWith("JSX")) {
    return;
  }
  switch (node.type) {
    case "JSXAttribute":
      return printJsxAttribute(path11, options9, print4);
    case "JSXIdentifier":
      return node.name;
    case "JSXNamespacedName":
      return join(":", [print4("namespace"), print4("name")]);
    case "JSXMemberExpression":
      return join(".", [print4("object"), print4("property")]);
    case "JSXSpreadAttribute":
    case "JSXSpreadChild":
      return printJsxSpreadAttributeOrChild(path11, options9, print4);
    case "JSXExpressionContainer":
      return printJsxExpressionContainer(path11, options9, print4);
    case "JSXFragment":
    case "JSXElement":
      return printJsxElement(path11, options9, print4);
    case "JSXOpeningElement":
      return printJsxOpeningElement(path11, options9, print4);
    case "JSXClosingElement":
      return printJsxClosingElement(path11, options9, print4);
    case "JSXOpeningFragment":
    case "JSXClosingFragment":
      return printJsxOpeningClosingFragment(
        path11,
        options9
        /*, print*/
      );
    case "JSXEmptyExpression":
      return printJsxEmptyExpression(
        path11,
        options9
        /*, print*/
      );
    case "JSXText":
      throw new Error("JSXText should be handled by JSXElement");
    default:
      throw new unexpected_node_error_default(node, "JSX");
  }
}
function isEmptyJsxElement(node) {
  if (node.children.length === 0) {
    return true;
  }
  if (node.children.length > 1) {
    return false;
  }
  const child = node.children[0];
  return child.type === "JSXText" && !isMeaningfulJsxText(child);
}
function isMeaningfulJsxText(node) {
  return node.type === "JSXText" && (jsxWhitespaceUtils.hasNonWhitespaceCharacter(rawText(node)) || !/\n/.test(rawText(node)));
}
function isJsxWhitespaceExpression(node) {
  return node.type === "JSXExpressionContainer" && isStringLiteral(node.expression) && node.expression.value === " " && !hasComment(node.expression);
}
function hasJsxIgnoreComment(path11) {
  const {
    node,
    parent
  } = path11;
  if (!isJsxElement(node) || !isJsxElement(parent)) {
    return false;
  }
  const {
    index,
    siblings
  } = path11;
  let prevSibling;
  for (let i = index; i > 0; i--) {
    const candidate = siblings[i - 1];
    if (candidate.type === "JSXText" && !isMeaningfulJsxText(candidate)) {
      continue;
    }
    prevSibling = candidate;
    break;
  }
  return (prevSibling == null ? void 0 : prevSibling.type) === "JSXExpressionContainer" && prevSibling.expression.type === "JSXEmptyExpression" && hasNodeIgnoreComment(prevSibling.expression);
}

// src/language-js/comments/handle-comments.js
var handle_comments_exports = {};
__export(handle_comments_exports, {
  avoidAstMutation: () => avoidAstMutation,
  endOfLine: () => handleEndOfLineComment,
  ownLine: () => handleOwnLineComment,
  remaining: () => handleRemainingComment
});

// src/utils/get-next-non-space-non-comment-character-index.js
function getNextNonSpaceNonCommentCharacterIndex(text, startIndex) {
  let oldIdx = null;
  let nextIdx = startIndex;
  while (nextIdx !== oldIdx) {
    oldIdx = nextIdx;
    nextIdx = skipSpaces(text, nextIdx);
    nextIdx = skip_inline_comment_default(text, nextIdx);
    nextIdx = skip_trailing_comment_default(text, nextIdx);
    nextIdx = skip_newline_default(text, nextIdx);
  }
  return nextIdx;
}
var get_next_non_space_non_comment_character_index_default = getNextNonSpaceNonCommentCharacterIndex;

// src/utils/get-next-non-space-non-comment-character.js
function getNextNonSpaceNonCommentCharacter(text, startIndex) {
  const index = get_next_non_space_non_comment_character_index_default(text, startIndex);
  return index === false ? "" : text.charAt(index);
}
var get_next_non_space_non_comment_character_default = getNextNonSpaceNonCommentCharacter;

// src/utils/has-newline-in-range.js
function hasNewlineInRange(text, startIndex, endIndex) {
  for (let i = startIndex; i < endIndex; ++i) {
    if (text.charAt(i) === "\n") {
      return true;
    }
  }
  return false;
}
var has_newline_in_range_default = hasNewlineInRange;

// src/language-js/utils/is-type-cast-comment.js
function isTypeCastComment(comment) {
  return is_block_comment_default(comment) && comment.value[0] === "*" && // TypeScript expects the type to be enclosed in curly brackets, however
  // Closure Compiler accepts types in parens and even without any delimiters at all.
  // That's why we just search for "@type" and "@satisfies".
  /@(?:type|satisfies)\b/.test(comment.value);
}
var is_type_cast_comment_default = isTypeCastComment;

// src/language-js/comments/handle-comments.js
function handleOwnLineComment(context) {
  return [handleIgnoreComments, handleLastFunctionArgComments, handleMemberExpressionComments, handleIfStatementComments, handleWhileComments, handleTryStatementComments, handleClassComments, handleForComments, handleUnionTypeComments, handleOnlyComments, handleModuleSpecifiersComments, handleAssignmentPatternComments, handleMethodNameComments, handleLabeledStatementComments, handleBreakAndContinueStatementComments].some((fn) => fn(context));
}
function handleEndOfLineComment(context) {
  return [handleClosureTypeCastComments, handleLastFunctionArgComments, handleConditionalExpressionComments, handleModuleSpecifiersComments, handleIfStatementComments, handleWhileComments, handleTryStatementComments, handleClassComments, handleLabeledStatementComments, handleCallExpressionComments, handlePropertyComments, handleOnlyComments, handleVariableDeclaratorComments, handleBreakAndContinueStatementComments, handleSwitchDefaultCaseComments].some((fn) => fn(context));
}
function handleRemainingComment(context) {
  return [handleIgnoreComments, handleIfStatementComments, handleWhileComments, handleObjectPropertyAssignment, handleCommentInEmptyParens, handleMethodNameComments, handleOnlyComments, handleCommentAfterArrowParams, handleFunctionNameComments, handleTSMappedTypeComments, handleBreakAndContinueStatementComments, handleTSFunctionTrailingComments].some((fn) => fn(context));
}
function addBlockStatementFirstComment(node, comment) {
  const firstNonEmptyNode = (node.body || node.properties).find(({
    type
  }) => type !== "EmptyStatement");
  if (firstNonEmptyNode) {
    addLeadingComment(firstNonEmptyNode, comment);
  } else {
    addDanglingComment(node, comment);
  }
}
function addBlockOrNotComment(node, comment) {
  if (node.type === "BlockStatement") {
    addBlockStatementFirstComment(node, comment);
  } else {
    addLeadingComment(node, comment);
  }
}
function handleClosureTypeCastComments({
  comment,
  followingNode
}) {
  if (followingNode && is_type_cast_comment_default(comment)) {
    addLeadingComment(followingNode, comment);
    return true;
  }
  return false;
}
function handleIfStatementComments({
  comment,
  precedingNode,
  enclosingNode,
  followingNode,
  text
}) {
  if ((enclosingNode == null ? void 0 : enclosingNode.type) !== "IfStatement" || !followingNode) {
    return false;
  }
  const nextCharacter = get_next_non_space_non_comment_character_default(text, locEnd(comment));
  if (nextCharacter === ")") {
    addTrailingComment(precedingNode, comment);
    return true;
  }
  if (precedingNode === enclosingNode.consequent && followingNode === enclosingNode.alternate) {
    if (precedingNode.type === "BlockStatement") {
      addTrailingComment(precedingNode, comment);
    } else {
      const isSingleLineComment = comment.type === "SingleLine" || comment.loc.start.line === comment.loc.end.line;
      const isSameLineComment = comment.loc.start.line === precedingNode.loc.start.line;
      if (isSingleLineComment && isSameLineComment) {
        addDanglingComment(precedingNode, comment, markerForIfWithoutBlockAndSameLineComment);
      } else {
        addDanglingComment(enclosingNode, comment);
      }
    }
    return true;
  }
  if (followingNode.type === "BlockStatement") {
    addBlockStatementFirstComment(followingNode, comment);
    return true;
  }
  if (followingNode.type === "IfStatement") {
    addBlockOrNotComment(followingNode.consequent, comment);
    return true;
  }
  if (enclosingNode.consequent === followingNode) {
    addLeadingComment(followingNode, comment);
    return true;
  }
  return false;
}
function handleWhileComments({
  comment,
  precedingNode,
  enclosingNode,
  followingNode,
  text
}) {
  if ((enclosingNode == null ? void 0 : enclosingNode.type) !== "WhileStatement" || !followingNode) {
    return false;
  }
  const nextCharacter = get_next_non_space_non_comment_character_default(text, locEnd(comment));
  if (nextCharacter === ")") {
    addTrailingComment(precedingNode, comment);
    return true;
  }
  if (followingNode.type === "BlockStatement") {
    addBlockStatementFirstComment(followingNode, comment);
    return true;
  }
  if (enclosingNode.body === followingNode) {
    addLeadingComment(followingNode, comment);
    return true;
  }
  return false;
}
function handleTryStatementComments({
  comment,
  precedingNode,
  enclosingNode,
  followingNode
}) {
  if ((enclosingNode == null ? void 0 : enclosingNode.type) !== "TryStatement" && (enclosingNode == null ? void 0 : enclosingNode.type) !== "CatchClause" || !followingNode) {
    return false;
  }
  if (enclosingNode.type === "CatchClause" && precedingNode) {
    addTrailingComment(precedingNode, comment);
    return true;
  }
  if (followingNode.type === "BlockStatement") {
    addBlockStatementFirstComment(followingNode, comment);
    return true;
  }
  if (followingNode.type === "TryStatement") {
    addBlockOrNotComment(followingNode.finalizer, comment);
    return true;
  }
  if (followingNode.type === "CatchClause") {
    addBlockOrNotComment(followingNode.body, comment);
    return true;
  }
  return false;
}
function handleMemberExpressionComments({
  comment,
  enclosingNode,
  followingNode
}) {
  if (isMemberExpression(enclosingNode) && (followingNode == null ? void 0 : followingNode.type) === "Identifier") {
    addLeadingComment(enclosingNode, comment);
    return true;
  }
  return false;
}
function handleConditionalExpressionComments({
  comment,
  precedingNode,
  enclosingNode,
  followingNode,
  text
}) {
  const isSameLineAsPrecedingNode = precedingNode && !has_newline_in_range_default(text, locEnd(precedingNode), locStart(comment));
  if ((!precedingNode || !isSameLineAsPrecedingNode) && ((enclosingNode == null ? void 0 : enclosingNode.type) === "ConditionalExpression" || (enclosingNode == null ? void 0 : enclosingNode.type) === "TSConditionalType") && followingNode) {
    addLeadingComment(followingNode, comment);
    return true;
  }
  return false;
}
function handleObjectPropertyAssignment({
  comment,
  precedingNode,
  enclosingNode
}) {
  if (isObjectProperty(enclosingNode) && enclosingNode.shorthand && enclosingNode.key === precedingNode && enclosingNode.value.type === "AssignmentPattern") {
    addTrailingComment(enclosingNode.value.left, comment);
    return true;
  }
  return false;
}
var classLikeNodeTypes = /* @__PURE__ */ new Set(["ClassDeclaration", "ClassExpression", "DeclareClass", "DeclareInterface", "InterfaceDeclaration", "TSInterfaceDeclaration"]);
function handleClassComments({
  comment,
  precedingNode,
  enclosingNode,
  followingNode
}) {
  if (classLikeNodeTypes.has(enclosingNode == null ? void 0 : enclosingNode.type)) {
    if (is_non_empty_array_default(enclosingNode.decorators) && !((followingNode == null ? void 0 : followingNode.type) === "Decorator")) {
      addTrailingComment(at_default(
        /* isOptionalObject*/
        false,
        enclosingNode.decorators,
        -1
      ), comment);
      return true;
    }
    if (enclosingNode.body && followingNode === enclosingNode.body) {
      addBlockStatementFirstComment(enclosingNode.body, comment);
      return true;
    }
    if (followingNode) {
      if (enclosingNode.superClass && followingNode === enclosingNode.superClass && precedingNode && (precedingNode === enclosingNode.id || precedingNode === enclosingNode.typeParameters)) {
        addTrailingComment(precedingNode, comment);
        return true;
      }
      for (const prop of ["implements", "extends", "mixins"]) {
        if (enclosingNode[prop] && followingNode === enclosingNode[prop][0]) {
          if (precedingNode && (precedingNode === enclosingNode.id || precedingNode === enclosingNode.typeParameters || precedingNode === enclosingNode.superClass)) {
            addTrailingComment(precedingNode, comment);
          } else {
            addDanglingComment(enclosingNode, comment, prop);
          }
          return true;
        }
      }
    }
  }
  return false;
}
var propertyLikeNodeTypes = /* @__PURE__ */ new Set(["ClassMethod", "ClassProperty", "PropertyDefinition", "TSAbstractPropertyDefinition", "TSAbstractMethodDefinition", "TSDeclareMethod", "MethodDefinition", "ClassAccessorProperty", "AccessorProperty", "TSAbstractAccessorProperty"]);
function handleMethodNameComments({
  comment,
  precedingNode,
  enclosingNode,
  text
}) {
  if (enclosingNode && precedingNode && get_next_non_space_non_comment_character_default(text, locEnd(comment)) === "(" && // "MethodDefinition" is handled in getCommentChildNodes
  (enclosingNode.type === "Property" || enclosingNode.type === "TSDeclareMethod" || enclosingNode.type === "TSAbstractMethodDefinition") && precedingNode.type === "Identifier" && enclosingNode.key === precedingNode && // special Property case: { key: /*comment*/(value) };
  // comment should be attached to value instead of key
  get_next_non_space_non_comment_character_default(text, locEnd(precedingNode)) !== ":") {
    addTrailingComment(precedingNode, comment);
    return true;
  }
  if ((precedingNode == null ? void 0 : precedingNode.type) === "Decorator" && propertyLikeNodeTypes.has(enclosingNode == null ? void 0 : enclosingNode.type)) {
    addTrailingComment(precedingNode, comment);
    return true;
  }
  return false;
}
var functionLikeNodeTypes = /* @__PURE__ */ new Set(["FunctionDeclaration", "FunctionExpression", "ClassMethod", "MethodDefinition", "ObjectMethod"]);
function handleFunctionNameComments({
  comment,
  precedingNode,
  enclosingNode,
  text
}) {
  if (get_next_non_space_non_comment_character_default(text, locEnd(comment)) !== "(") {
    return false;
  }
  if (precedingNode && functionLikeNodeTypes.has(enclosingNode == null ? void 0 : enclosingNode.type)) {
    addTrailingComment(precedingNode, comment);
    return true;
  }
  return false;
}
function handleCommentAfterArrowParams({
  comment,
  enclosingNode,
  text
}) {
  if (!((enclosingNode == null ? void 0 : enclosingNode.type) === "ArrowFunctionExpression")) {
    return false;
  }
  const index = get_next_non_space_non_comment_character_index_default(text, locEnd(comment));
  if (index !== false && text.slice(index, index + 2) === "=>") {
    addDanglingComment(enclosingNode, comment);
    return true;
  }
  return false;
}
function handleCommentInEmptyParens({
  comment,
  enclosingNode,
  text
}) {
  if (get_next_non_space_non_comment_character_default(text, locEnd(comment)) !== ")") {
    return false;
  }
  if (enclosingNode && (isRealFunctionLikeNode(enclosingNode) && getFunctionParameters(enclosingNode).length === 0 || isCallLikeExpression(enclosingNode) && getCallArguments(enclosingNode).length === 0)) {
    addDanglingComment(enclosingNode, comment);
    return true;
  }
  if (((enclosingNode == null ? void 0 : enclosingNode.type) === "MethodDefinition" || (enclosingNode == null ? void 0 : enclosingNode.type) === "TSAbstractMethodDefinition") && getFunctionParameters(enclosingNode.value).length === 0) {
    addDanglingComment(enclosingNode.value, comment);
    return true;
  }
  return false;
}
function handleLastFunctionArgComments({
  comment,
  precedingNode,
  enclosingNode,
  followingNode,
  text
}) {
  if ((precedingNode == null ? void 0 : precedingNode.type) === "FunctionTypeParam" && (enclosingNode == null ? void 0 : enclosingNode.type) === "FunctionTypeAnnotation" && (followingNode == null ? void 0 : followingNode.type) !== "FunctionTypeParam") {
    addTrailingComment(precedingNode, comment);
    return true;
  }
  if (((precedingNode == null ? void 0 : precedingNode.type) === "Identifier" || (precedingNode == null ? void 0 : precedingNode.type) === "AssignmentPattern") && enclosingNode && isRealFunctionLikeNode(enclosingNode) && get_next_non_space_non_comment_character_default(text, locEnd(comment)) === ")") {
    addTrailingComment(precedingNode, comment);
    return true;
  }
  if ((enclosingNode == null ? void 0 : enclosingNode.type) === "FunctionDeclaration" && (followingNode == null ? void 0 : followingNode.type) === "BlockStatement") {
    const functionParamRightParenIndex = (() => {
      const parameters = getFunctionParameters(enclosingNode);
      if (parameters.length > 0) {
        return get_next_non_space_non_comment_character_index_default(text, locEnd(at_default(
          /* isOptionalObject*/
          false,
          parameters,
          -1
        )));
      }
      const functionParamLeftParenIndex = get_next_non_space_non_comment_character_index_default(text, locEnd(enclosingNode.id));
      return functionParamLeftParenIndex !== false && get_next_non_space_non_comment_character_index_default(text, functionParamLeftParenIndex + 1);
    })();
    if (locStart(comment) > functionParamRightParenIndex) {
      addBlockStatementFirstComment(followingNode, comment);
      return true;
    }
  }
  return false;
}
function handleLabeledStatementComments({
  comment,
  enclosingNode
}) {
  if ((enclosingNode == null ? void 0 : enclosingNode.type) === "LabeledStatement") {
    addLeadingComment(enclosingNode, comment);
    return true;
  }
  return false;
}
function handleBreakAndContinueStatementComments({
  comment,
  enclosingNode
}) {
  if (((enclosingNode == null ? void 0 : enclosingNode.type) === "ContinueStatement" || (enclosingNode == null ? void 0 : enclosingNode.type) === "BreakStatement") && !enclosingNode.label) {
    addTrailingComment(enclosingNode, comment);
    return true;
  }
  return false;
}
function handleCallExpressionComments({
  comment,
  precedingNode,
  enclosingNode
}) {
  if (isCallExpression(enclosingNode) && precedingNode && enclosingNode.callee === precedingNode && enclosingNode.arguments.length > 0) {
    addLeadingComment(enclosingNode.arguments[0], comment);
    return true;
  }
  return false;
}
function handleUnionTypeComments({
  comment,
  precedingNode,
  enclosingNode,
  followingNode
}) {
  if ((enclosingNode == null ? void 0 : enclosingNode.type) === "UnionTypeAnnotation" || (enclosingNode == null ? void 0 : enclosingNode.type) === "TSUnionType") {
    if (isPrettierIgnoreComment(comment)) {
      followingNode.prettierIgnore = true;
      comment.unignore = true;
    }
    if (precedingNode) {
      addTrailingComment(precedingNode, comment);
      return true;
    }
    return false;
  }
  if (((followingNode == null ? void 0 : followingNode.type) === "UnionTypeAnnotation" || (followingNode == null ? void 0 : followingNode.type) === "TSUnionType") && isPrettierIgnoreComment(comment)) {
    followingNode.types[0].prettierIgnore = true;
    comment.unignore = true;
  }
  return false;
}
function handlePropertyComments({
  comment,
  enclosingNode
}) {
  if (isObjectProperty(enclosingNode)) {
    addLeadingComment(enclosingNode, comment);
    return true;
  }
  return false;
}
function handleOnlyComments({
  comment,
  enclosingNode,
  followingNode,
  ast,
  isLastComment
}) {
  var _a;
  if (((_a = ast == null ? void 0 : ast.body) == null ? void 0 : _a.length) === 0) {
    if (isLastComment) {
      addDanglingComment(ast, comment);
    } else {
      addLeadingComment(ast, comment);
    }
    return true;
  }
  if ((enclosingNode == null ? void 0 : enclosingNode.type) === "Program" && enclosingNode.body.length === 0 && !is_non_empty_array_default(enclosingNode.directives)) {
    if (isLastComment) {
      addDanglingComment(enclosingNode, comment);
    } else {
      addLeadingComment(enclosingNode, comment);
    }
    return true;
  }
  if ((followingNode == null ? void 0 : followingNode.type) === "Program" && followingNode.body.length === 0 && (enclosingNode == null ? void 0 : enclosingNode.type) === "ModuleExpression") {
    addDanglingComment(followingNode, comment);
    return true;
  }
  return false;
}
function handleForComments({
  comment,
  enclosingNode
}) {
  if ((enclosingNode == null ? void 0 : enclosingNode.type) === "ForInStatement" || (enclosingNode == null ? void 0 : enclosingNode.type) === "ForOfStatement") {
    addLeadingComment(enclosingNode, comment);
    return true;
  }
  return false;
}
function handleModuleSpecifiersComments({
  comment,
  precedingNode,
  enclosingNode,
  text
}) {
  if ((enclosingNode == null ? void 0 : enclosingNode.type) === "ImportSpecifier" || (enclosingNode == null ? void 0 : enclosingNode.type) === "ExportSpecifier") {
    addLeadingComment(enclosingNode, comment);
    return true;
  }
  const isImportDeclaration = (precedingNode == null ? void 0 : precedingNode.type) === "ImportSpecifier" && (enclosingNode == null ? void 0 : enclosingNode.type) === "ImportDeclaration";
  const isExportDeclaration2 = (precedingNode == null ? void 0 : precedingNode.type) === "ExportSpecifier" && (enclosingNode == null ? void 0 : enclosingNode.type) === "ExportNamedDeclaration";
  if ((isImportDeclaration || isExportDeclaration2) && has_newline_default(text, locEnd(comment))) {
    addTrailingComment(precedingNode, comment);
    return true;
  }
  return false;
}
function handleAssignmentPatternComments({
  comment,
  enclosingNode
}) {
  if ((enclosingNode == null ? void 0 : enclosingNode.type) === "AssignmentPattern") {
    addLeadingComment(enclosingNode, comment);
    return true;
  }
  return false;
}
var assignmentLikeNodeTypes = /* @__PURE__ */ new Set(["VariableDeclarator", "AssignmentExpression", "TypeAlias", "TSTypeAliasDeclaration"]);
var complexExprNodeTypes = /* @__PURE__ */ new Set(["ObjectExpression", "RecordExpression", "ArrayExpression", "TupleExpression", "TemplateLiteral", "TaggedTemplateExpression", "ObjectTypeAnnotation", "TSTypeLiteral"]);
function handleVariableDeclaratorComments({
  comment,
  enclosingNode,
  followingNode
}) {
  if (assignmentLikeNodeTypes.has(enclosingNode == null ? void 0 : enclosingNode.type) && followingNode && (complexExprNodeTypes.has(followingNode.type) || is_block_comment_default(comment))) {
    addLeadingComment(followingNode, comment);
    return true;
  }
  return false;
}
function handleTSFunctionTrailingComments({
  comment,
  enclosingNode,
  followingNode,
  text
}) {
  if (!followingNode && ((enclosingNode == null ? void 0 : enclosingNode.type) === "TSMethodSignature" || (enclosingNode == null ? void 0 : enclosingNode.type) === "TSDeclareFunction" || (enclosingNode == null ? void 0 : enclosingNode.type) === "TSAbstractMethodDefinition") && get_next_non_space_non_comment_character_default(text, locEnd(comment)) === ";") {
    addTrailingComment(enclosingNode, comment);
    return true;
  }
  return false;
}
function handleIgnoreComments({
  comment,
  enclosingNode,
  followingNode
}) {
  if (isPrettierIgnoreComment(comment) && (enclosingNode == null ? void 0 : enclosingNode.type) === "TSMappedType" && (followingNode == null ? void 0 : followingNode.type) === "TSTypeParameter" && followingNode.constraint) {
    enclosingNode.prettierIgnore = true;
    comment.unignore = true;
    return true;
  }
}
function handleTSMappedTypeComments({
  comment,
  precedingNode,
  enclosingNode,
  followingNode
}) {
  if ((enclosingNode == null ? void 0 : enclosingNode.type) !== "TSMappedType") {
    return false;
  }
  if ((followingNode == null ? void 0 : followingNode.type) === "TSTypeParameter" && followingNode.name) {
    addLeadingComment(followingNode.name, comment);
    return true;
  }
  if ((precedingNode == null ? void 0 : precedingNode.type) === "TSTypeParameter" && precedingNode.constraint) {
    addTrailingComment(precedingNode.constraint, comment);
    return true;
  }
  return false;
}
function handleSwitchDefaultCaseComments({
  comment,
  enclosingNode,
  followingNode
}) {
  if (!enclosingNode || enclosingNode.type !== "SwitchCase" || enclosingNode.test || !followingNode || followingNode !== enclosingNode.consequent[0]) {
    return false;
  }
  if (followingNode.type === "BlockStatement" && isLineComment(comment)) {
    addBlockStatementFirstComment(followingNode, comment);
  } else {
    addDanglingComment(enclosingNode, comment);
  }
  return true;
}
var isRealFunctionLikeNode = createTypeCheckFunction(["ArrowFunctionExpression", "FunctionExpression", "FunctionDeclaration", "ObjectMethod", "ClassMethod", "TSDeclareFunction", "TSCallSignatureDeclaration", "TSConstructSignatureDeclaration", "TSMethodSignature", "TSConstructorType", "TSFunctionType", "TSDeclareMethod"]);
var avoidAstMutation = true;

// src/language-js/utils/is-indentable-block-comment.js
function isIndentableBlockComment(comment) {
  const lines = `*${comment.value}*`.split("\n");
  return lines.length > 1 && lines.every((line2) => line2.trimStart()[0] === "*");
}
var is_indentable_block_comment_default = isIndentableBlockComment;

// src/language-js/print/comment.js
function printComment2(commentPath, options9) {
  const comment = commentPath.node;
  if (isLineComment(comment)) {
    return options9.originalText.slice(locStart(comment), locEnd(comment)).trimEnd();
  }
  if (is_block_comment_default(comment)) {
    if (is_indentable_block_comment_default(comment)) {
      return printIndentableBlockComment(comment);
    }
    return ["/*", replaceEndOfLine(comment.value), "*/"];
  }
  throw new Error("Not a comment: " + JSON.stringify(comment));
}
function printIndentableBlockComment(comment) {
  const lines = comment.value.split("\n");
  return [
    "/*",
    join(
      hardline,
      lines.map(
        (line2, index) => index === 0 ? line2.trimEnd() : " " + (index < lines.length - 1 ? line2.trim() : line2.trimStart())
      )
    ),
    "*/"
  ];
}

// src/language-js/comments/printer-methods.js
var nodeTypesCanNotAttachComment = /* @__PURE__ */ new Set([
  "EmptyStatement",
  "TemplateElement",
  // In ESTree `import` is a token, `import("foo")`
  "Import",
  // There is no similar node in Babel AST
  // ```ts
  // class Foo {
  //   bar();
  //      ^^^ TSEmptyBodyFunctionExpression
  // }
  // ```
  "TSEmptyBodyFunctionExpression",
  // There is no similar node in Babel AST, `a?.b`
  "ChainExpression"
]);
function canAttachComment(node) {
  return !nodeTypesCanNotAttachComment.has(node.type);
}
function getCommentChildNodes(node, options9) {
  var _a;
  if ((options9.parser === "typescript" || options9.parser === "flow" || options9.parser === "acorn" || options9.parser === "espree" || options9.parser === "meriyah" || options9.parser === "__babel_estree") && node.type === "MethodDefinition" && ((_a = node.value) == null ? void 0 : _a.type) === "FunctionExpression" && getFunctionParameters(node.value).length === 0 && !node.value.returnType && !is_non_empty_array_default(node.value.typeParameters) && node.value.body) {
    return [...node.decorators || [], node.key, node.value.body];
  }
}
function hasPrettierIgnore(path11) {
  return hasNodeIgnoreComment(path11.node) || hasJsxIgnoreComment(path11);
}
function willPrintOwnComments({
  node,
  parent
}) {
  return (isJsxElement(node) || parent && (parent.type === "JSXSpreadAttribute" || parent.type === "JSXSpreadChild" || parent.type === "UnionTypeAnnotation" || parent.type === "TSUnionType" || (parent.type === "ClassDeclaration" || parent.type === "ClassExpression") && parent.superClass === node)) && (!hasNodeIgnoreComment(node) || parent.type === "UnionTypeAnnotation" || parent.type === "TSUnionType");
}
function isGap(text, {
  parser
}) {
  if (parser === "flow" || parser === "babel-flow") {
    text = string_replace_all_default(
      /* isOptionalObject*/
      false,
      text,
      /[\s(]/g,
      ""
    );
    return text === "" || text === "/*" || text === "/*::";
  }
}

// src/language-js/print/html-binding.js
function printHtmlBinding(path11, options9, print4) {
  var _a;
  const { node, isRoot } = path11;
  if (isRoot) {
    (_a = options9.__onHtmlBindingRoot) == null ? void 0 : _a.call(options9, node, options9);
  }
  if (node.type !== "File") {
    return;
  }
  if (options9.__isVueBindings || options9.__isVueForBindingLeft) {
    const parameterDocs = path11.map(print4, "program", "body", 0, "params");
    if (parameterDocs.length === 1) {
      return parameterDocs[0];
    }
    const doc2 = join([",", line], parameterDocs);
    return options9.__isVueForBindingLeft ? ["(", indent([softline, group(doc2)]), softline, ")"] : doc2;
  }
}
function isVueEventBindingExpression(node) {
  switch (node.type) {
    case "MemberExpression":
      switch (node.property.type) {
        case "Identifier":
        case "NumericLiteral":
        case "StringLiteral":
          return isVueEventBindingExpression(node.object);
      }
      return false;
    case "Identifier":
      return true;
    default:
      return false;
  }
}

// src/document/constants.js
var DOC_TYPE_GROUP = "group";
var DOC_TYPE_FILL = "fill";

// src/language-js/print/binaryish.js
var uid = 0;
function printBinaryishExpression(path11, options9, print4) {
  const {
    node,
    parent,
    grandparent,
    key
  } = path11;
  const isInsideParenthesis = key !== "body" && (parent.type === "IfStatement" || parent.type === "WhileStatement" || parent.type === "SwitchStatement" || parent.type === "DoWhileStatement");
  const isHackPipeline = isEnabledHackPipeline(options9) && node.operator === "|>";
  const parts = printBinaryishExpressions(
    path11,
    print4,
    options9,
    /* isNested */
    false,
    isInsideParenthesis
  );
  if (isInsideParenthesis) {
    return parts;
  }
  if (isHackPipeline) {
    return group(parts);
  }
  if (isCallExpression(parent) && parent.callee === node || parent.type === "UnaryExpression" || isMemberExpression(parent) && !parent.computed) {
    return group([indent([softline, ...parts]), softline]);
  }
  const shouldNotIndent = parent.type === "ReturnStatement" || parent.type === "ThrowStatement" || parent.type === "JSXExpressionContainer" && grandparent.type === "JSXAttribute" || node.operator !== "|" && parent.type === "JsExpressionRoot" || node.type !== "NGPipeExpression" && (parent.type === "NGRoot" && options9.parser === "__ng_binding" || parent.type === "NGMicrosyntaxExpression" && grandparent.type === "NGMicrosyntax" && grandparent.body.length === 1) || node === parent.body && parent.type === "ArrowFunctionExpression" || node !== parent.body && parent.type === "ForStatement" || parent.type === "ConditionalExpression" && grandparent.type !== "ReturnStatement" && grandparent.type !== "ThrowStatement" && !isCallExpression(grandparent) || parent.type === "TemplateLiteral";
  const shouldIndentIfInlining = parent.type === "AssignmentExpression" || parent.type === "VariableDeclarator" || parent.type === "ClassProperty" || parent.type === "PropertyDefinition" || parent.type === "TSAbstractPropertyDefinition" || parent.type === "ClassPrivateProperty" || isObjectProperty(parent);
  const samePrecedenceSubExpression = isBinaryish(node.left) && shouldFlatten(node.operator, node.left.operator);
  if (shouldNotIndent || shouldInlineLogicalExpression(node) && !samePrecedenceSubExpression || !shouldInlineLogicalExpression(node) && shouldIndentIfInlining) {
    return group(parts);
  }
  if (parts.length === 0) {
    return "";
  }
  const hasJsx = isJsxElement(node.right);
  const firstGroupIndex = parts.findIndex((part) => typeof part !== "string" && !Array.isArray(part) && part.type === DOC_TYPE_GROUP);
  const headParts = parts.slice(0, firstGroupIndex === -1 ? 1 : firstGroupIndex + 1);
  const rest = parts.slice(headParts.length, hasJsx ? -1 : void 0);
  const groupId = Symbol("logicalChain-" + ++uid);
  const chain = group([
    // Don't include the initial expression in the indentation
    // level. The first item is guaranteed to be the first
    // left-most expression.
    ...headParts,
    indent(rest)
  ], {
    id: groupId
  });
  if (!hasJsx) {
    return chain;
  }
  const jsxPart = at_default(
    /* isOptionalObject*/
    false,
    parts,
    -1
  );
  return group([chain, indentIfBreak(jsxPart, {
    groupId
  })]);
}
function printBinaryishExpressions(path11, print4, options9, isNested, isInsideParenthesis) {
  const {
    node
  } = path11;
  if (!isBinaryish(node)) {
    return [group(print4())];
  }
  let parts = [];
  if (shouldFlatten(node.operator, node.left.operator)) {
    parts = path11.call((left) => printBinaryishExpressions(
      left,
      print4,
      options9,
      /* isNested */
      true,
      isInsideParenthesis
    ), "left");
  } else {
    parts.push(group(print4("left")));
  }
  const shouldInline = shouldInlineLogicalExpression(node);
  const lineBeforeOperator = (node.operator === "|>" || node.type === "NGPipeExpression" || node.operator === "|" && options9.parser === "__vue_expression") && !hasLeadingOwnLineComment(options9.originalText, node.right);
  const operator = node.type === "NGPipeExpression" ? "|" : node.operator;
  const rightSuffix = node.type === "NGPipeExpression" && node.arguments.length > 0 ? group(indent([line, ": ", join([line, ": "], path11.map(() => align(2, group(print4())), "arguments"))])) : "";
  let right;
  if (shouldInline) {
    right = [operator, " ", print4("right"), rightSuffix];
  } else {
    const isHackPipeline = isEnabledHackPipeline(options9) && operator === "|>";
    const rightContent = isHackPipeline ? path11.call((left) => printBinaryishExpressions(
      left,
      print4,
      options9,
      /* isNested */
      true,
      isInsideParenthesis
    ), "right") : print4("right");
    right = [lineBeforeOperator ? line : "", operator, lineBeforeOperator ? " " : line, rightContent, rightSuffix];
  }
  const {
    parent
  } = path11;
  const shouldBreak = hasComment(node.left, CommentCheckFlags.Trailing | CommentCheckFlags.Line);
  const shouldGroup = shouldBreak || !(isInsideParenthesis && node.type === "LogicalExpression") && parent.type !== node.type && node.left.type !== node.type && node.right.type !== node.type;
  parts.push(lineBeforeOperator ? "" : " ", shouldGroup ? group(right, {
    shouldBreak
  }) : right);
  if (isNested && hasComment(node)) {
    const printed = cleanDoc(printComments(path11, parts, options9));
    if (Array.isArray(printed) || printed.type === DOC_TYPE_FILL) {
      return getDocParts(printed);
    }
    return [printed];
  }
  return parts;
}
function shouldInlineLogicalExpression(node) {
  if (node.type !== "LogicalExpression") {
    return false;
  }
  if (isObjectOrRecordExpression(node.right) && node.right.properties.length > 0) {
    return true;
  }
  if (isArrayOrTupleExpression(node.right) && node.right.elements.length > 0) {
    return true;
  }
  if (isJsxElement(node.right)) {
    return true;
  }
  return false;
}

// src/language-js/print/angular.js
function printAngular(path11, options9, print4) {
  const { node } = path11;
  if (!node.type.startsWith("NG")) {
    return;
  }
  switch (node.type) {
    case "NGRoot":
      return [
        print4("node"),
        hasComment(node.node) ? " //" + getComments(node.node)[0].value.trimEnd() : ""
      ];
    case "NGPipeExpression":
      return printBinaryishExpression(path11, options9, print4);
    case "NGChainedExpression":
      return group(
        join(
          [";", line],
          path11.map(
            () => hasNgSideEffect(path11) ? print4() : ["(", print4(), ")"],
            "expressions"
          )
        )
      );
    case "NGEmptyExpression":
      return "";
    case "NGMicrosyntax":
      return path11.map(
        () => [
          path11.isFirst ? "" : isNgForOf(path11) ? " " : [";", line],
          print4()
        ],
        "body"
      );
    case "NGMicrosyntaxKey":
      return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/i.test(node.name) ? node.name : JSON.stringify(node.name);
    case "NGMicrosyntaxExpression":
      return [
        print4("expression"),
        node.alias === null ? "" : [" as ", print4("alias")]
      ];
    case "NGMicrosyntaxKeyedExpression": {
      const { index, parent } = path11;
      const shouldNotPrintColon = isNgForOf(path11) || (index === 1 && (node.key.name === "then" || node.key.name === "else") || index === 2 && node.key.name === "else" && parent.body[index - 1].type === "NGMicrosyntaxKeyedExpression" && parent.body[index - 1].key.name === "then") && parent.body[0].type === "NGMicrosyntaxExpression";
      return [
        print4("key"),
        shouldNotPrintColon ? " " : ": ",
        print4("expression")
      ];
    }
    case "NGMicrosyntaxLet":
      return [
        "let ",
        print4("key"),
        node.value === null ? "" : [" = ", print4("value")]
      ];
    case "NGMicrosyntaxAs":
      return [print4("key"), " as ", print4("alias")];
    default:
      throw new unexpected_node_error_default(node, "Angular");
  }
}
function isNgForOf({ node, index, parent }) {
  return node.type === "NGMicrosyntaxKeyedExpression" && node.key.name === "of" && index === 1 && parent.body[0].type === "NGMicrosyntaxLet" && parent.body[0].value === null;
}
function hasNgSideEffect(path11) {
  return hasNode(path11.node, (node) => {
    switch (node.type) {
      case "CallExpression":
      case "OptionalCallExpression":
      case "AssignmentExpression":
        return true;
    }
  });
}

// src/language-js/print/flow.js
import assert6 from "assert";

// src/utils/make-string.js
function makeString(rawText2, enclosingQuote, unescapeUnnecessaryEscapes) {
  const otherQuote = enclosingQuote === '"' ? "'" : '"';
  const regex = /\\(.)|(["'])/gs;
  const raw = string_replace_all_default(
    /* isOptionalObject*/
    false,
    rawText2,
    regex,
    (match, escaped, quote) => {
      if (escaped === otherQuote) {
        return escaped;
      }
      if (quote === enclosingQuote) {
        return "\\" + quote;
      }
      if (quote) {
        return quote;
      }
      return unescapeUnnecessaryEscapes && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(escaped) ? escaped : "\\" + escaped;
    }
  );
  return enclosingQuote + raw + enclosingQuote;
}
var make_string_default = makeString;

// src/utils/print-string.js
function printString(raw, options9) {
  const rawContent = raw.slice(1, -1);
  const enclosingQuote = options9.parser === "json" || options9.parser === "json5" && options9.quoteProps === "preserve" && !options9.singleQuote ? '"' : options9.__isInHtmlAttribute ? "'" : get_preferred_quote_default(rawContent, options9.singleQuote ? "'" : '"').quote;
  return make_string_default(
    rawContent,
    enclosingQuote,
    !(options9.parser === "css" || options9.parser === "less" || options9.parser === "scss" || options9.__embeddedInHtml)
  );
}
var print_string_default = printString;

// src/utils/print-number.js
function printNumber(rawNumber) {
  return rawNumber.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(?=\d)/, "$1$2").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
}
var print_number_default = printNumber;

// src/utils/create-group-id-mapper.js
function createGroupIdMapper(description) {
  const groupIds = /* @__PURE__ */ new WeakMap();
  return function(node) {
    if (!groupIds.has(node)) {
      groupIds.set(node, Symbol(description));
    }
    return groupIds.get(node);
  };
}
var create_group_id_mapper_default = createGroupIdMapper;

// src/language-js/print/misc.js
function printOptionalToken(path11) {
  const { node } = path11;
  if (!node.optional || // It's an optional computed method parsed by typescript-estree.
  // "?" is printed in `printMethod`.
  node.type === "Identifier" && node === path11.parent.key) {
    return "";
  }
  if (isCallExpression(node) || isMemberExpression(node) && node.computed || node.type === "OptionalIndexedAccessType") {
    return "?.";
  }
  return "?";
}
function printDefiniteToken(path11) {
  return path11.node.definite || path11.match(
    void 0,
    (node, name) => name === "id" && node.type === "VariableDeclarator" && node.definite
  ) ? "!" : "";
}
var flowDeclareNodeTypes = /* @__PURE__ */ new Set([
  "DeclareClass",
  "DeclareFunction",
  "DeclareVariable",
  "DeclareExportDeclaration",
  "DeclareExportAllDeclaration",
  "DeclareOpaqueType",
  "DeclareTypeAlias",
  "DeclareEnum",
  "DeclareInterface"
]);
function printDeclareToken(path11) {
  const { node } = path11;
  return (
    // TypeScript
    node.declare || // Flow
    flowDeclareNodeTypes.has(node.type) && path11.parent.type !== "DeclareExportDeclaration" ? "declare " : ""
  );
}
var tsAbstractNodeTypes = /* @__PURE__ */ new Set([
  "TSAbstractMethodDefinition",
  "TSAbstractPropertyDefinition",
  "TSAbstractAccessorProperty"
]);
function printAbstractToken({ node }) {
  return node.abstract || tsAbstractNodeTypes.has(node.type) ? "abstract " : "";
}
function printFunctionTypeParameters(path11, options9, print4) {
  const fun = path11.node;
  if (fun.typeArguments) {
    return print4("typeArguments");
  }
  if (fun.typeParameters) {
    return print4("typeParameters");
  }
  return "";
}
function printBindExpressionCallee(path11, options9, print4) {
  return ["::", print4("callee")];
}
function adjustClause(node, clause, forceSpace) {
  if (node.type === "EmptyStatement") {
    return ";";
  }
  if (node.type === "BlockStatement" || forceSpace) {
    return [" ", clause];
  }
  return indent([line, clause]);
}
function printRestSpread(path11, print4) {
  return ["...", print4("argument"), printTypeAnnotationProperty(path11, print4)];
}
function printTypeScriptAccessibilityToken(node) {
  return node.accessibility ? node.accessibility + " " : "";
}

// src/language-js/print/array.js
function printEmptyArray(path11, options9, openBracket, closeBracket) {
  const {
    node
  } = path11;
  if (!hasComment(node, CommentCheckFlags.Dangling)) {
    return [openBracket, closeBracket];
  }
  return group([openBracket, printDanglingComments(path11, options9, {
    indent: true
  }), softline, closeBracket]);
}
function printArray(path11, options9, print4) {
  const {
    node
  } = path11;
  const parts = [];
  const openBracket = node.type === "TupleExpression" ? "#[" : "[";
  const closeBracket = "]";
  const elementsProperty = (
    // TODO: Remove `types` when babel changes AST of `TupleTypeAnnotation`
    node.type === "TupleTypeAnnotation" && node.types ? "types" : node.type === "TSTupleType" || node.type === "TupleTypeAnnotation" ? "elementTypes" : "elements"
  );
  const elements = node[elementsProperty];
  if (elements.length === 0) {
    parts.push(printEmptyArray(path11, options9, openBracket, closeBracket));
  } else {
    const lastElem = at_default(
      /* isOptionalObject*/
      false,
      elements,
      -1
    );
    const canHaveTrailingComma = (lastElem == null ? void 0 : lastElem.type) !== "RestElement";
    const needsForcedTrailingComma = lastElem === null;
    const groupId = Symbol("array");
    const shouldBreak = !options9.__inJestEach && elements.length > 1 && elements.every((element, i, elements2) => {
      const elementType = element == null ? void 0 : element.type;
      if (!isArrayOrTupleExpression(element) && !isObjectOrRecordExpression(element)) {
        return false;
      }
      const nextElement = elements2[i + 1];
      if (nextElement && elementType !== nextElement.type) {
        return false;
      }
      const itemsKey = isArrayOrTupleExpression(element) ? "elements" : "properties";
      return element[itemsKey] && element[itemsKey].length > 1;
    });
    const shouldUseConciseFormatting = isConciselyPrintedArray(node, options9);
    const trailingComma = !canHaveTrailingComma ? "" : needsForcedTrailingComma ? "," : !shouldPrintComma(options9) ? "" : shouldUseConciseFormatting ? ifBreak(",", "", {
      groupId
    }) : ifBreak(",");
    parts.push(group([openBracket, indent([softline, shouldUseConciseFormatting ? printArrayItemsConcisely(path11, options9, print4, trailingComma) : [printArrayItems(path11, options9, elementsProperty, print4), trailingComma], printDanglingComments(path11, options9)]), softline, closeBracket], {
      shouldBreak,
      id: groupId
    }));
  }
  parts.push(printOptionalToken(path11), printTypeAnnotationProperty(path11, print4));
  return parts;
}
function isConciselyPrintedArray(node, options9) {
  return isArrayOrTupleExpression(node) && node.elements.length > 1 && node.elements.every((element) => element && (isNumericLiteral(element) || isSignedNumericLiteral(element) && !hasComment(element.argument)) && !hasComment(element, CommentCheckFlags.Trailing | CommentCheckFlags.Line, (comment) => !has_newline_default(options9.originalText, locStart(comment), {
    backwards: true
  })));
}
function printArrayItems(path11, options9, elementsProperty, print4) {
  const parts = [];
  path11.each(({
    node,
    isLast
  }) => {
    parts.push(node ? group(print4()) : "");
    if (!isLast) {
      parts.push([",", line, node && isNextLineEmpty2(node, options9) ? softline : ""]);
    }
  }, elementsProperty);
  return parts;
}
function printArrayItemsConcisely(path11, options9, print4, trailingComma) {
  const parts = [];
  path11.each(({
    node,
    isLast,
    next
  }) => {
    parts.push([print4(), isLast ? trailingComma : ","]);
    if (!isLast) {
      parts.push(isNextLineEmpty2(node, options9) ? [hardline, hardline] : hasComment(next, CommentCheckFlags.Leading | CommentCheckFlags.Line) ? hardline : line);
    }
  }, "elements");
  return fill(parts);
}

// src/language-js/print/call-arguments.js
function printCallArguments(path11, options9, print4) {
  const {
    node
  } = path11;
  const args = getCallArguments(node);
  if (args.length === 0) {
    return ["(", printDanglingComments(path11, options9), ")"];
  }
  if (isReactHookCallWithDepsArray(args)) {
    return ["(", print4(["arguments", 0]), ", ", print4(["arguments", 1]), ")"];
  }
  let anyArgEmptyLine = false;
  const lastArgIndex = args.length - 1;
  const printedArguments = [];
  iterateCallArgumentsPath(path11, ({
    node: arg
  }, index) => {
    let argDoc = print4();
    if (index === lastArgIndex) {
    } else if (isNextLineEmpty2(arg, options9)) {
      anyArgEmptyLine = true;
      argDoc = [argDoc, ",", hardline, hardline];
    } else {
      argDoc = [argDoc, ",", line];
    }
    printedArguments.push(argDoc);
  });
  const isDynamicImport = node.type === "ImportExpression" || node.callee.type === "Import";
  const maybeTrailingComma = !isDynamicImport && shouldPrintComma(options9, "all") ? "," : "";
  function allArgsBrokenOut() {
    return group(["(", indent([line, ...printedArguments]), maybeTrailingComma, line, ")"], {
      shouldBreak: true
    });
  }
  if (anyArgEmptyLine || path11.parent.type !== "Decorator" && isFunctionCompositionArgs(args)) {
    return allArgsBrokenOut();
  }
  if (shouldExpandFirstArg(args)) {
    const tailArgs = printedArguments.slice(1);
    if (tailArgs.some(willBreak)) {
      return allArgsBrokenOut();
    }
    let firstArg;
    try {
      firstArg = print4(getCallArgumentSelector(node, 0), {
        expandFirstArg: true
      });
    } catch (caught) {
      if (caught instanceof ArgExpansionBailout) {
        return allArgsBrokenOut();
      }
      throw caught;
    }
    if (willBreak(firstArg)) {
      return [breakParent, conditionalGroup([["(", group(firstArg, {
        shouldBreak: true
      }), ", ", ...tailArgs, ")"], allArgsBrokenOut()])];
    }
    return conditionalGroup([["(", firstArg, ", ", ...tailArgs, ")"], ["(", group(firstArg, {
      shouldBreak: true
    }), ", ", ...tailArgs, ")"], allArgsBrokenOut()]);
  }
  if (shouldExpandLastArg(args, printedArguments, options9)) {
    const headArgs = printedArguments.slice(0, -1);
    if (headArgs.some(willBreak)) {
      return allArgsBrokenOut();
    }
    let lastArg;
    try {
      lastArg = print4(getCallArgumentSelector(node, -1), {
        expandLastArg: true
      });
    } catch (caught) {
      if (caught instanceof ArgExpansionBailout) {
        return allArgsBrokenOut();
      }
      throw caught;
    }
    if (willBreak(lastArg)) {
      return [breakParent, conditionalGroup([["(", ...headArgs, group(lastArg, {
        shouldBreak: true
      }), ")"], allArgsBrokenOut()])];
    }
    return conditionalGroup([["(", ...headArgs, lastArg, ")"], ["(", ...headArgs, group(lastArg, {
      shouldBreak: true
    }), ")"], allArgsBrokenOut()]);
  }
  const contents = ["(", indent([softline, ...printedArguments]), ifBreak(maybeTrailingComma), softline, ")"];
  if (isLongCurriedCallExpression(path11)) {
    return contents;
  }
  return group(contents, {
    shouldBreak: printedArguments.some(willBreak) || anyArgEmptyLine
  });
}
function couldExpandArg(arg, arrowChainRecursion = false) {
  return isObjectOrRecordExpression(arg) && (arg.properties.length > 0 || hasComment(arg)) || isArrayOrTupleExpression(arg) && (arg.elements.length > 0 || hasComment(arg)) || arg.type === "TSTypeAssertion" && couldExpandArg(arg.expression) || isTSTypeExpression(arg) && couldExpandArg(arg.expression) || arg.type === "FunctionExpression" || arg.type === "ArrowFunctionExpression" && // we want to avoid breaking inside composite return types but not simple keywords
  // https://github.com/prettier/prettier/issues/4070
  // export class Thing implements OtherThing {
  //   do: (type: Type) => Provider<Prop> = memoize(
  //     (type: ObjectType): Provider<Opts> => {}
  //   );
  // }
  // https://github.com/prettier/prettier/issues/6099
  // app.get("/", (req, res): void => {
  //   res.send("Hello World!");
  // });
  (!arg.returnType || !arg.returnType.typeAnnotation || arg.returnType.typeAnnotation.type !== "TSTypeReference" || // https://github.com/prettier/prettier/issues/7542
  isNonEmptyBlockStatement(arg.body)) && (arg.body.type === "BlockStatement" || arg.body.type === "ArrowFunctionExpression" && couldExpandArg(arg.body, true) || isObjectOrRecordExpression(arg.body) || isArrayOrTupleExpression(arg.body) || !arrowChainRecursion && (isCallExpression(arg.body) || arg.body.type === "ConditionalExpression") || isJsxElement(arg.body)) || arg.type === "DoExpression" || arg.type === "ModuleExpression";
}
function shouldExpandLastArg(args, argDocs, options9) {
  var _a, _b;
  const lastArg = at_default(
    /* isOptionalObject*/
    false,
    args,
    -1
  );
  if (args.length === 1) {
    const lastArgDoc = at_default(
      /* isOptionalObject*/
      false,
      argDocs,
      -1
    );
    if (((_a = lastArgDoc.label) == null ? void 0 : _a.embed) && ((_b = lastArgDoc.label) == null ? void 0 : _b.hug) !== false) {
      return true;
    }
  }
  const penultimateArg = at_default(
    /* isOptionalObject*/
    false,
    args,
    -2
  );
  return !hasComment(lastArg, CommentCheckFlags.Leading) && !hasComment(lastArg, CommentCheckFlags.Trailing) && couldExpandArg(lastArg) && // If the last two arguments are of the same type,
  // disable last element expansion.
  (!penultimateArg || penultimateArg.type !== lastArg.type) && // useMemo(() => func(), [foo, bar, baz])
  (args.length !== 2 || penultimateArg.type !== "ArrowFunctionExpression" || !isArrayOrTupleExpression(lastArg)) && !(args.length > 1 && isConciselyPrintedArray(lastArg, options9));
}
function shouldExpandFirstArg(args) {
  if (args.length !== 2) {
    return false;
  }
  const [firstArg, secondArg] = args;
  if (firstArg.type === "ModuleExpression" && isTypeModuleObjectExpression(secondArg)) {
    return true;
  }
  return !hasComment(firstArg) && (firstArg.type === "FunctionExpression" || firstArg.type === "ArrowFunctionExpression" && firstArg.body.type === "BlockStatement") && secondArg.type !== "FunctionExpression" && secondArg.type !== "ArrowFunctionExpression" && secondArg.type !== "ConditionalExpression" && isHopefullyShortCallArgument(secondArg) && !couldExpandArg(secondArg);
}
function isHopefullyShortCallArgument(node) {
  var _a;
  if (node.type === "ParenthesizedExpression") {
    return isHopefullyShortCallArgument(node.expression);
  }
  if (isTSTypeExpression(node)) {
    let {
      typeAnnotation
    } = node;
    if (typeAnnotation.type === "TSArrayType") {
      typeAnnotation = typeAnnotation.elementType;
      if (typeAnnotation.type === "TSArrayType") {
        typeAnnotation = typeAnnotation.elementType;
      }
    }
    if ((typeAnnotation.type === "GenericTypeAnnotation" || typeAnnotation.type === "TSTypeReference") && ((_a = typeAnnotation.typeParameters) == null ? void 0 : _a.params.length) === 1) {
      typeAnnotation = typeAnnotation.typeParameters.params[0];
    }
    return isSimpleType(typeAnnotation) && isSimpleCallArgument(node.expression, 1);
  }
  if (isCallLikeExpression(node) && getCallArguments(node).length > 1) {
    return false;
  }
  if (isBinaryish(node)) {
    return isSimpleCallArgument(node.left, 1) && isSimpleCallArgument(node.right, 1);
  }
  return isRegExpLiteral(node) || isSimpleCallArgument(node);
}
function isReactHookCallWithDepsArray(args) {
  return args.length === 2 && args[0].type === "ArrowFunctionExpression" && getFunctionParameters(args[0]).length === 0 && args[0].body.type === "BlockStatement" && args[1].type === "ArrayExpression" && !args.some((arg) => hasComment(arg));
}
function isNonEmptyBlockStatement(node) {
  return node.type === "BlockStatement" && (node.body.some((node2) => node2.type !== "EmptyStatement") || hasComment(node, CommentCheckFlags.Dangling));
}
function isTypeModuleObjectExpression(node) {
  return node.type === "ObjectExpression" && node.properties.length === 1 && isObjectProperty(node.properties[0]) && node.properties[0].key.type === "Identifier" && node.properties[0].key.name === "type" && isStringLiteral(node.properties[0].value) && node.properties[0].value.value === "module";
}
var call_arguments_default = printCallArguments;

// src/language-js/print/member.js
function printMemberExpression(path11, options9, print4) {
  var _a;
  const objectDoc = print4("object");
  const lookupDoc = printMemberLookup(path11, options9, print4);
  const { node, parent } = path11;
  const firstNonMemberParent = path11.findAncestor(
    (node2) => !(isMemberExpression(node2) || node2.type === "TSNonNullExpression")
  );
  const shouldInline = firstNonMemberParent && (firstNonMemberParent.type === "NewExpression" || firstNonMemberParent.type === "BindExpression" || firstNonMemberParent.type === "AssignmentExpression" && firstNonMemberParent.left.type !== "Identifier") || node.computed || node.object.type === "Identifier" && node.property.type === "Identifier" && !isMemberExpression(parent) || (parent.type === "AssignmentExpression" || parent.type === "VariableDeclarator") && (isCallExpression(node.object) && node.object.arguments.length > 0 || node.object.type === "TSNonNullExpression" && isCallExpression(node.object.expression) && node.object.expression.arguments.length > 0 || ((_a = objectDoc.label) == null ? void 0 : _a.memberChain));
  return label(objectDoc.label, [
    objectDoc,
    shouldInline ? lookupDoc : group(indent([softline, lookupDoc]))
  ]);
}
function printMemberLookup(path11, options9, print4) {
  const property = print4("property");
  const { node } = path11;
  const optional = printOptionalToken(path11);
  if (!node.computed) {
    return [optional, ".", property];
  }
  if (!node.property || isNumericLiteral(node.property)) {
    return [optional, "[", property, "]"];
  }
  return group([optional, "[", indent([softline, property]), softline, "]"]);
}

// src/language-js/print/member-chain.js
function printMemberChain(path11, options9, print4) {
  const {
    parent
  } = path11;
  const isExpressionStatement = !parent || parent.type === "ExpressionStatement";
  const printedNodes = [];
  function shouldInsertEmptyLineAfter(node2) {
    const {
      originalText
    } = options9;
    const nextCharIndex = get_next_non_space_non_comment_character_index_default(originalText, locEnd(node2));
    const nextChar = originalText.charAt(nextCharIndex);
    if (nextChar === ")") {
      return nextCharIndex !== false && is_next_line_empty_default(originalText, nextCharIndex + 1);
    }
    return isNextLineEmpty2(node2, options9);
  }
  function rec(path12) {
    const {
      node: node2
    } = path12;
    if (isCallExpression(node2) && (isMemberish(node2.callee) || isCallExpression(node2.callee))) {
      printedNodes.unshift({
        node: node2,
        printed: [printComments(path12, [printOptionalToken(path12), printFunctionTypeParameters(path12, options9, print4), call_arguments_default(path12, options9, print4)], options9), shouldInsertEmptyLineAfter(node2) ? hardline : ""]
      });
      path12.call((callee) => rec(callee), "callee");
    } else if (isMemberish(node2)) {
      printedNodes.unshift({
        node: node2,
        needsParens: needs_parens_default(path12, options9),
        printed: printComments(path12, isMemberExpression(node2) ? printMemberLookup(path12, options9, print4) : printBindExpressionCallee(path12, options9, print4), options9)
      });
      path12.call((object) => rec(object), "object");
    } else if (node2.type === "TSNonNullExpression") {
      printedNodes.unshift({
        node: node2,
        printed: printComments(path12, "!", options9)
      });
      path12.call((expression) => rec(expression), "expression");
    } else {
      printedNodes.unshift({
        node: node2,
        printed: print4()
      });
    }
  }
  const {
    node
  } = path11;
  printedNodes.unshift({
    node,
    printed: [printOptionalToken(path11), printFunctionTypeParameters(path11, options9, print4), call_arguments_default(path11, options9, print4)]
  });
  if (node.callee) {
    path11.call((callee) => rec(callee), "callee");
  }
  const groups = [];
  let currentGroup = [printedNodes[0]];
  let i = 1;
  for (; i < printedNodes.length; ++i) {
    if (printedNodes[i].node.type === "TSNonNullExpression" || isCallExpression(printedNodes[i].node) || isMemberExpression(printedNodes[i].node) && printedNodes[i].node.computed && isNumericLiteral(printedNodes[i].node.property)) {
      currentGroup.push(printedNodes[i]);
    } else {
      break;
    }
  }
  if (!isCallExpression(printedNodes[0].node)) {
    for (; i + 1 < printedNodes.length; ++i) {
      if (isMemberish(printedNodes[i].node) && isMemberish(printedNodes[i + 1].node)) {
        currentGroup.push(printedNodes[i]);
      } else {
        break;
      }
    }
  }
  groups.push(currentGroup);
  currentGroup = [];
  let hasSeenCallExpression = false;
  for (; i < printedNodes.length; ++i) {
    if (hasSeenCallExpression && isMemberish(printedNodes[i].node)) {
      if (printedNodes[i].node.computed && isNumericLiteral(printedNodes[i].node.property)) {
        currentGroup.push(printedNodes[i]);
        continue;
      }
      groups.push(currentGroup);
      currentGroup = [];
      hasSeenCallExpression = false;
    }
    if (isCallExpression(printedNodes[i].node) || printedNodes[i].node.type === "ImportExpression") {
      hasSeenCallExpression = true;
    }
    currentGroup.push(printedNodes[i]);
    if (hasComment(printedNodes[i].node, CommentCheckFlags.Trailing)) {
      groups.push(currentGroup);
      currentGroup = [];
      hasSeenCallExpression = false;
    }
  }
  if (currentGroup.length > 0) {
    groups.push(currentGroup);
  }
  function isFactory(name) {
    return /^[A-Z]|^[$_]+$/.test(name);
  }
  function isShort(name) {
    return name.length <= options9.tabWidth;
  }
  function shouldNotWrap(groups2) {
    var _a;
    const hasComputed = (_a = groups2[1][0]) == null ? void 0 : _a.node.computed;
    if (groups2[0].length === 1) {
      const firstNode = groups2[0][0].node;
      return firstNode.type === "ThisExpression" || firstNode.type === "Identifier" && (isFactory(firstNode.name) || isExpressionStatement && isShort(firstNode.name) || hasComputed);
    }
    const lastNode = at_default(
      /* isOptionalObject*/
      false,
      groups2[0],
      -1
    ).node;
    return isMemberExpression(lastNode) && lastNode.property.type === "Identifier" && (isFactory(lastNode.property.name) || hasComputed);
  }
  const shouldMerge = groups.length >= 2 && !hasComment(groups[1][0].node) && shouldNotWrap(groups);
  function printGroup(printedGroup) {
    const printed = printedGroup.map((tuple) => tuple.printed);
    if (printedGroup.length > 0 && at_default(
      /* isOptionalObject*/
      false,
      printedGroup,
      -1
    ).needsParens) {
      return ["(", ...printed, ")"];
    }
    return printed;
  }
  function printIndentedGroup(groups2) {
    if (groups2.length === 0) {
      return "";
    }
    return indent(group([hardline, join(hardline, groups2.map(printGroup))]));
  }
  const printedGroups = groups.map(printGroup);
  const oneLine = printedGroups;
  const cutoff = shouldMerge ? 3 : 2;
  const flatGroups = groups.flat();
  const nodeHasComment = flatGroups.slice(1, -1).some((node2) => hasComment(node2.node, CommentCheckFlags.Leading)) || flatGroups.slice(0, -1).some((node2) => hasComment(node2.node, CommentCheckFlags.Trailing)) || groups[cutoff] && hasComment(groups[cutoff][0].node, CommentCheckFlags.Leading);
  if (groups.length <= cutoff && !nodeHasComment) {
    if (isLongCurriedCallExpression(path11)) {
      return oneLine;
    }
    return group(oneLine);
  }
  const lastNodeBeforeIndent = at_default(
    /* isOptionalObject*/
    false,
    groups[shouldMerge ? 1 : 0],
    -1
  ).node;
  const shouldHaveEmptyLineBeforeIndent = !isCallExpression(lastNodeBeforeIndent) && shouldInsertEmptyLineAfter(lastNodeBeforeIndent);
  const expanded = [printGroup(groups[0]), shouldMerge ? groups.slice(1, 2).map(printGroup) : "", shouldHaveEmptyLineBeforeIndent ? hardline : "", printIndentedGroup(groups.slice(shouldMerge ? 2 : 1))];
  const callExpressions = printedNodes.map(({
    node: node2
  }) => node2).filter(isCallExpression);
  function lastGroupWillBreakAndOtherCallsHaveFunctionArguments() {
    const lastGroupNode = at_default(
      /* isOptionalObject*/
      false,
      at_default(
        /* isOptionalObject*/
        false,
        groups,
        -1
      ),
      -1
    ).node;
    const lastGroupDoc = at_default(
      /* isOptionalObject*/
      false,
      printedGroups,
      -1
    );
    return isCallExpression(lastGroupNode) && willBreak(lastGroupDoc) && callExpressions.slice(0, -1).some((node2) => node2.arguments.some(isFunctionOrArrowExpression));
  }
  let result;
  if (nodeHasComment || callExpressions.length > 2 && callExpressions.some((expr) => !expr.arguments.every((arg) => isSimpleCallArgument(arg))) || printedGroups.slice(0, -1).some(willBreak) || lastGroupWillBreakAndOtherCallsHaveFunctionArguments()) {
    result = group(expanded);
  } else {
    result = [
      // We only need to check `oneLine` because if `expanded` is chosen
      // that means that the parent group has already been broken
      // naturally
      willBreak(oneLine) || shouldHaveEmptyLineBeforeIndent ? breakParent : "",
      conditionalGroup([oneLine, expanded])
    ];
  }
  return label({
    memberChain: true
  }, result);
}
var member_chain_default = printMemberChain;

// src/language-js/print/call-expression.js
function printCallExpression(path11, options9, print4) {
  var _a;
  const { node, parent } = path11;
  const isNew = node.type === "NewExpression";
  const isDynamicImport = node.type === "ImportExpression";
  const optional = printOptionalToken(path11);
  const args = getCallArguments(node);
  const isTemplateLiteralSingleArg = args.length === 1 && isTemplateOnItsOwnLine(args[0], options9.originalText);
  if (isTemplateLiteralSingleArg || // Dangling comments are not handled, all these special cases should have arguments #9668
  args.length > 0 && !isNew && !isDynamicImport && // We want to keep CommonJS- and AMD-style require calls, and AMD-style
  // define calls, as a unit.
  // e.g. `define(["some/lib"], (lib) => {`
  (isCommonsJsOrAmdCall(node, parent) || // Keep test declarations on a single line
  // e.g. `it('long name', () => {`
  isTestCall(node, parent))) {
    const printed = [];
    iterateCallArgumentsPath(path11, () => {
      printed.push(print4());
    });
    if (!(isTemplateLiteralSingleArg && ((_a = printed[0].label) == null ? void 0 : _a.embed))) {
      return [
        isNew ? "new " : "",
        print4("callee"),
        optional,
        printFunctionTypeParameters(path11, options9, print4),
        "(",
        join(", ", printed),
        ")"
      ];
    }
  }
  if (!isDynamicImport && !isNew && isMemberish(node.callee) && !path11.call((path12) => needs_parens_default(path12, options9), "callee")) {
    return member_chain_default(path11, options9, print4);
  }
  const contents = [
    isNew ? "new " : "",
    isDynamicImport ? "import" : print4("callee"),
    optional,
    printFunctionTypeParameters(path11, options9, print4),
    call_arguments_default(path11, options9, print4)
  ];
  if (isDynamicImport || isCallExpression(node.callee)) {
    return group(contents);
  }
  return contents;
}
function isCommonsJsOrAmdCall(node, parentNode) {
  if (node.callee.type !== "Identifier") {
    return false;
  }
  if (node.callee.name === "require") {
    return true;
  }
  if (node.callee.name === "define") {
    const args = getCallArguments(node);
    return parentNode.type === "ExpressionStatement" && (args.length === 1 || args.length === 2 && args[0].type === "ArrayExpression" || args.length === 3 && isStringLiteral(args[0]) && args[1].type === "ArrayExpression");
  }
  return false;
}

// src/language-js/print/literal.js
function printLiteral(path11, options9) {
  const { node } = path11;
  switch (node.type) {
    case "RegExpLiteral":
      return printRegex(node);
    case "BigIntLiteral":
      return printBigInt(node.extra.raw);
    case "NumericLiteral":
      return print_number_default(node.extra.raw);
    case "StringLiteral":
      return replaceEndOfLine(print_string_default(node.extra.raw, options9));
    case "NullLiteral":
      return "null";
    case "BooleanLiteral":
      return String(node.value);
    case "DecimalLiteral":
      return print_number_default(node.value) + "m";
    case "DirectiveLiteral":
      return printDirective(node.extra.raw, options9);
    case "Literal": {
      if (node.regex) {
        return printRegex(node.regex);
      }
      if (node.bigint) {
        return printBigInt(node.raw);
      }
      if (node.decimal) {
        return print_number_default(node.decimal) + "m";
      }
      const { value } = node;
      if (typeof value === "number") {
        return print_number_default(node.raw);
      }
      if (typeof value === "string") {
        return isDirective(path11) ? printDirective(node.raw, options9) : replaceEndOfLine(print_string_default(node.raw, options9));
      }
      return String(value);
    }
  }
}
function isDirective(path11) {
  if (path11.key !== "expression") {
    return;
  }
  const { parent } = path11;
  return parent.type === "ExpressionStatement" && parent.directive;
}
function printBigInt(raw) {
  return raw.toLowerCase();
}
function printRegex({ pattern, flags }) {
  flags = [...flags].sort().join("");
  return `/${pattern}/${flags}`;
}
function printDirective(rawText2, options9) {
  const rawContent = rawText2.slice(1, -1);
  if (rawContent.includes('"') || rawContent.includes("'")) {
    return rawText2;
  }
  const enclosingQuote = options9.singleQuote ? "'" : '"';
  return enclosingQuote + rawContent + enclosingQuote;
}
var isLiteral = createTypeCheckFunction([
  "Literal",
  // Babel, flow uses `BigIntLiteral` too
  "BigIntLiteral",
  "BooleanLiteral",
  "DecimalLiteral",
  "DirectiveLiteral",
  "NullLiteral",
  "NumericLiteral",
  "RegExpLiteral",
  "StringLiteral"
]);

// src/language-js/print/assignment.js
function printAssignment(path11, options9, print4, leftDoc, operator, rightPropertyName) {
  const layout = chooseLayout(path11, options9, print4, leftDoc, rightPropertyName);
  const rightDoc = rightPropertyName ? print4(rightPropertyName, { assignmentLayout: layout }) : "";
  switch (layout) {
    case "break-after-operator":
      return group([group(leftDoc), operator, group(indent([line, rightDoc]))]);
    case "never-break-after-operator":
      return group([group(leftDoc), operator, " ", rightDoc]);
    case "fluid": {
      const groupId = Symbol("assignment");
      return group([
        group(leftDoc),
        operator,
        group(indent(line), { id: groupId }),
        lineSuffixBoundary,
        indentIfBreak(rightDoc, { groupId })
      ]);
    }
    case "break-lhs":
      return group([leftDoc, operator, " ", group(rightDoc)]);
    case "chain":
      return [group(leftDoc), operator, line, rightDoc];
    case "chain-tail":
      return [group(leftDoc), operator, indent([line, rightDoc])];
    case "chain-tail-arrow-chain":
      return [group(leftDoc), operator, rightDoc];
    case "only-left":
      return leftDoc;
  }
}
function printAssignmentExpression(path11, options9, print4) {
  const { node } = path11;
  return printAssignment(
    path11,
    options9,
    print4,
    print4("left"),
    [" ", node.operator],
    "right"
  );
}
function printVariableDeclarator(path11, options9, print4) {
  return printAssignment(path11, options9, print4, print4("id"), " =", "init");
}
function chooseLayout(path11, options9, print4, leftDoc, rightPropertyName) {
  const { node } = path11;
  const rightNode = node[rightPropertyName];
  if (!rightNode) {
    return "only-left";
  }
  const isTail = !isAssignment(rightNode);
  const shouldUseChainFormatting = path11.match(
    isAssignment,
    isAssignmentOrVariableDeclarator,
    (node2) => !isTail || node2.type !== "ExpressionStatement" && node2.type !== "VariableDeclaration"
  );
  if (shouldUseChainFormatting) {
    return !isTail ? "chain" : rightNode.type === "ArrowFunctionExpression" && rightNode.body.type === "ArrowFunctionExpression" ? "chain-tail-arrow-chain" : "chain-tail";
  }
  const isHeadOfLongChain = !isTail && isAssignment(rightNode.right);
  if (isHeadOfLongChain || hasLeadingOwnLineComment(options9.originalText, rightNode)) {
    return "break-after-operator";
  }
  if (rightNode.type === "CallExpression" && rightNode.callee.name === "require" || // do not put values on a separate line from the key in json
  options9.parser === "json5" || options9.parser === "json") {
    return "never-break-after-operator";
  }
  if (isComplexDestructuring(node) || isComplexTypeAliasParams(node) || hasComplexTypeAnnotation(node) || isArrowFunctionVariableDeclarator(node) && canBreak(leftDoc)) {
    return "break-lhs";
  }
  const hasShortKey = isObjectPropertyWithShortKey(node, leftDoc, options9);
  if (path11.call(
    () => shouldBreakAfterOperator(path11, options9, print4, hasShortKey),
    rightPropertyName
  )) {
    return "break-after-operator";
  }
  if (hasShortKey || rightNode.type === "TemplateLiteral" || rightNode.type === "TaggedTemplateExpression" || rightNode.type === "BooleanLiteral" || isNumericLiteral(rightNode) || rightNode.type === "ClassExpression") {
    return "never-break-after-operator";
  }
  return "fluid";
}
function shouldBreakAfterOperator(path11, options9, print4, hasShortKey) {
  const rightNode = path11.node;
  if (isBinaryish(rightNode) && !shouldInlineLogicalExpression(rightNode)) {
    return true;
  }
  switch (rightNode.type) {
    case "StringLiteralTypeAnnotation":
    case "SequenceExpression":
      return true;
    case "ConditionalExpression": {
      const { test } = rightNode;
      return isBinaryish(test) && !shouldInlineLogicalExpression(test);
    }
    case "ClassExpression":
      return is_non_empty_array_default(rightNode.decorators);
  }
  if (hasShortKey) {
    return false;
  }
  let node = rightNode;
  const propertiesForPath = [];
  for (; ; ) {
    if (node.type === "UnaryExpression") {
      node = node.argument;
      propertiesForPath.push("argument");
    } else if (node.type === "TSNonNullExpression") {
      node = node.expression;
      propertiesForPath.push("expression");
    } else {
      break;
    }
  }
  if (isStringLiteral(node) || path11.call(
    () => isPoorlyBreakableMemberOrCallChain(path11, options9, print4),
    ...propertiesForPath
  )) {
    return true;
  }
  return false;
}
function isComplexDestructuring(node) {
  if (isAssignmentOrVariableDeclarator(node)) {
    const leftNode = node.left || node.id;
    return leftNode.type === "ObjectPattern" && leftNode.properties.length > 2 && leftNode.properties.some(
      (property) => {
        var _a;
        return isObjectProperty(property) && (!property.shorthand || ((_a = property.value) == null ? void 0 : _a.type) === "AssignmentPattern");
      }
    );
  }
  return false;
}
function isAssignment(node) {
  return node.type === "AssignmentExpression";
}
function isAssignmentOrVariableDeclarator(node) {
  return isAssignment(node) || node.type === "VariableDeclarator";
}
function isComplexTypeAliasParams(node) {
  const typeParams = getTypeParametersFromTypeAlias(node);
  if (is_non_empty_array_default(typeParams)) {
    const constraintPropertyName = node.type === "TSTypeAliasDeclaration" ? "constraint" : "bound";
    if (typeParams.length > 1 && typeParams.some((param) => param[constraintPropertyName] || param.default)) {
      return true;
    }
  }
  return false;
}
var isTypeAlias = createTypeCheckFunction([
  "TSTypeAliasDeclaration",
  "TypeAlias"
]);
function getTypeParametersFromTypeAlias(node) {
  var _a;
  if (isTypeAlias(node)) {
    return (_a = node.typeParameters) == null ? void 0 : _a.params;
  }
}
function hasComplexTypeAnnotation(node) {
  if (node.type !== "VariableDeclarator") {
    return false;
  }
  const { typeAnnotation } = node.id;
  if (!typeAnnotation || !typeAnnotation.typeAnnotation) {
    return false;
  }
  const typeParams = getTypeParametersFromTypeReference(
    typeAnnotation.typeAnnotation
  );
  return is_non_empty_array_default(typeParams) && typeParams.length > 1 && typeParams.some(
    (param) => is_non_empty_array_default(getTypeParametersFromTypeReference(param)) || param.type === "TSConditionalType"
  );
}
function isArrowFunctionVariableDeclarator(node) {
  var _a;
  return node.type === "VariableDeclarator" && ((_a = node.init) == null ? void 0 : _a.type) === "ArrowFunctionExpression";
}
var isTypeReference = createTypeCheckFunction([
  "TSTypeReference",
  "GenericTypeAnnotation"
]);
function getTypeParametersFromTypeReference(node) {
  var _a;
  if (isTypeReference(node)) {
    return (_a = node.typeParameters) == null ? void 0 : _a.params;
  }
}
function isPoorlyBreakableMemberOrCallChain(path11, options9, print4, deep = false) {
  var _a;
  const { node } = path11;
  const goDeeper = () => isPoorlyBreakableMemberOrCallChain(path11, options9, print4, true);
  if (node.type === "ChainExpression" || node.type === "TSNonNullExpression") {
    return path11.call(goDeeper, "expression");
  }
  if (isCallExpression(node)) {
    const doc2 = printCallExpression(path11, options9, print4);
    if ((_a = doc2.label) == null ? void 0 : _a.memberChain) {
      return false;
    }
    const args = getCallArguments(node);
    const isPoorlyBreakableCall = args.length === 0 || args.length === 1 && isLoneShortArgument(args[0], options9);
    if (!isPoorlyBreakableCall) {
      return false;
    }
    if (isCallExpressionWithComplexTypeArguments(node, print4)) {
      return false;
    }
    return path11.call(goDeeper, "callee");
  }
  if (isMemberExpression(node)) {
    return path11.call(goDeeper, "object");
  }
  return deep && (node.type === "Identifier" || node.type === "ThisExpression");
}
var LONE_SHORT_ARGUMENT_THRESHOLD_RATE = 0.25;
function isLoneShortArgument(node, { printWidth }) {
  if (hasComment(node)) {
    return false;
  }
  const threshold = printWidth * LONE_SHORT_ARGUMENT_THRESHOLD_RATE;
  if (node.type === "ThisExpression" || node.type === "Identifier" && node.name.length <= threshold || isSignedNumericLiteral(node) && !hasComment(node.argument)) {
    return true;
  }
  const regexpPattern = node.type === "Literal" && "regex" in node && node.regex.pattern || node.type === "RegExpLiteral" && node.pattern;
  if (regexpPattern) {
    return regexpPattern.length <= threshold;
  }
  if (isStringLiteral(node)) {
    return rawText(node).length <= threshold;
  }
  if (node.type === "TemplateLiteral") {
    return node.expressions.length === 0 && node.quasis[0].value.raw.length <= threshold && !node.quasis[0].value.raw.includes("\n");
  }
  return isLiteral(node);
}
function isObjectPropertyWithShortKey(node, keyDoc, options9) {
  if (!isObjectProperty(node)) {
    return false;
  }
  keyDoc = cleanDoc(keyDoc);
  const MIN_OVERLAP_FOR_BREAK = 3;
  return typeof keyDoc === "string" && get_string_width_default(keyDoc) < options9.tabWidth + MIN_OVERLAP_FOR_BREAK;
}
function isCallExpressionWithComplexTypeArguments(node, print4) {
  const typeArgs = getTypeArgumentsFromCallExpression(node);
  if (is_non_empty_array_default(typeArgs)) {
    if (typeArgs.length > 1) {
      return true;
    }
    if (typeArgs.length === 1) {
      const firstArg = typeArgs[0];
      if (firstArg.type === "TSUnionType" || firstArg.type === "UnionTypeAnnotation" || firstArg.type === "TSIntersectionType" || firstArg.type === "IntersectionTypeAnnotation" || firstArg.type === "TSTypeLiteral" || firstArg.type === "ObjectTypeAnnotation") {
        return true;
      }
    }
    const typeArgsKeyName = node.typeParameters ? "typeParameters" : "typeArguments";
    if (willBreak(print4(typeArgsKeyName))) {
      return true;
    }
  }
  return false;
}
function getTypeArgumentsFromCallExpression(node) {
  var _a;
  return (_a = node.typeParameters ?? node.typeArguments) == null ? void 0 : _a.params;
}

// src/language-js/print/function-parameters.js
function printFunctionParameters(path11, print4, options9, expandArg, printTypeParams) {
  const functionNode = path11.node;
  const parameters = getFunctionParameters(functionNode);
  const typeParams = printTypeParams ? printFunctionTypeParameters(path11, options9, print4) : "";
  if (parameters.length === 0) {
    return [
      typeParams,
      "(",
      printDanglingComments(path11, options9, {
        filter: (comment) => get_next_non_space_non_comment_character_default(
          options9.originalText,
          locEnd(comment)
        ) === ")"
      }),
      ")"
    ];
  }
  const { parent } = path11;
  const isParametersInTestCall = isTestCall(parent);
  const shouldHugParameters = shouldHugTheOnlyFunctionParameter(functionNode);
  const printed = [];
  iterateFunctionParametersPath(path11, (parameterPath, index) => {
    const isLastParameter = index === parameters.length - 1;
    if (isLastParameter && functionNode.rest) {
      printed.push("...");
    }
    printed.push(print4());
    if (isLastParameter) {
      return;
    }
    printed.push(",");
    if (isParametersInTestCall || shouldHugParameters) {
      printed.push(" ");
    } else if (isNextLineEmpty2(parameters[index], options9)) {
      printed.push(hardline, hardline);
    } else {
      printed.push(line);
    }
  });
  if (expandArg && !isDecoratedFunction(path11)) {
    if (willBreak(typeParams) || willBreak(printed)) {
      throw new ArgExpansionBailout();
    }
    return group([removeLines(typeParams), "(", removeLines(printed), ")"]);
  }
  const hasNotParameterDecorator = parameters.every((node) => !node.decorators);
  if (shouldHugParameters && hasNotParameterDecorator) {
    return [typeParams, "(", ...printed, ")"];
  }
  if (isParametersInTestCall) {
    return [typeParams, "(", ...printed, ")"];
  }
  const isFlowShorthandWithOneArg = (isObjectTypePropertyAFunction(parent) || isTypeAnnotationAFunction(parent) || parent.type === "TypeAlias" || parent.type === "UnionTypeAnnotation" || parent.type === "TSUnionType" || parent.type === "IntersectionTypeAnnotation" || parent.type === "FunctionTypeAnnotation" && parent.returnType === functionNode) && parameters.length === 1 && parameters[0].name === null && // `type q = (this: string) => void;`
  functionNode.this !== parameters[0] && parameters[0].typeAnnotation && functionNode.typeParameters === null && isSimpleType(parameters[0].typeAnnotation) && !functionNode.rest;
  if (isFlowShorthandWithOneArg) {
    if (options9.arrowParens === "always") {
      return ["(", ...printed, ")"];
    }
    return printed;
  }
  return [
    typeParams,
    "(",
    indent([softline, ...printed]),
    ifBreak(
      !hasRestParameter(functionNode) && shouldPrintComma(options9, "all") ? "," : ""
    ),
    softline,
    ")"
  ];
}
function shouldHugTheOnlyFunctionParameter(node) {
  if (!node) {
    return false;
  }
  const parameters = getFunctionParameters(node);
  if (parameters.length !== 1) {
    return false;
  }
  const [parameter] = parameters;
  return !hasComment(parameter) && (parameter.type === "ObjectPattern" || parameter.type === "ArrayPattern" || parameter.type === "Identifier" && parameter.typeAnnotation && (parameter.typeAnnotation.type === "TypeAnnotation" || parameter.typeAnnotation.type === "TSTypeAnnotation") && isObjectType(parameter.typeAnnotation.typeAnnotation) || parameter.type === "FunctionTypeParam" && isObjectType(parameter.typeAnnotation) && parameter !== node.rest || parameter.type === "AssignmentPattern" && (parameter.left.type === "ObjectPattern" || parameter.left.type === "ArrayPattern") && (parameter.right.type === "Identifier" || isObjectOrRecordExpression(parameter.right) && parameter.right.properties.length === 0 || isArrayOrTupleExpression(parameter.right) && parameter.right.elements.length === 0));
}
function getReturnTypeNode(functionNode) {
  let returnTypeNode;
  if (functionNode.returnType) {
    returnTypeNode = functionNode.returnType;
    if (returnTypeNode.typeAnnotation) {
      returnTypeNode = returnTypeNode.typeAnnotation;
    }
  } else if (functionNode.typeAnnotation) {
    returnTypeNode = functionNode.typeAnnotation;
  }
  return returnTypeNode;
}
function shouldGroupFunctionParameters(functionNode, returnTypeDoc) {
  var _a;
  const returnTypeNode = getReturnTypeNode(functionNode);
  if (!returnTypeNode) {
    return false;
  }
  const typeParameters = (_a = functionNode.typeParameters) == null ? void 0 : _a.params;
  if (typeParameters) {
    if (typeParameters.length > 1) {
      return false;
    }
    if (typeParameters.length === 1) {
      const typeParameter = typeParameters[0];
      if (typeParameter.constraint || typeParameter.default) {
        return false;
      }
    }
  }
  return getFunctionParameters(functionNode).length === 1 && (isObjectType(returnTypeNode) || willBreak(returnTypeDoc));
}
function isDecoratedFunction(path11) {
  return path11.match(
    (node) => node.type === "ArrowFunctionExpression" && node.body.type === "BlockStatement",
    (node, name) => {
      if (node.type === "CallExpression" && name === "arguments" && node.arguments.length === 1 && node.callee.type === "CallExpression") {
        const decorator = node.callee.callee;
        return decorator.type === "Identifier" || decorator.type === "MemberExpression" && !decorator.computed && decorator.object.type === "Identifier" && decorator.property.type === "Identifier";
      }
      return false;
    },
    (node, name) => node.type === "VariableDeclarator" && name === "init" || node.type === "ExportDefaultDeclaration" && name === "declaration" || node.type === "TSExportAssignment" && name === "expression" || node.type === "AssignmentExpression" && name === "right" && node.left.type === "MemberExpression" && node.left.object.type === "Identifier" && node.left.object.name === "module" && node.left.property.type === "Identifier" && node.left.property.name === "exports",
    (node) => node.type !== "VariableDeclaration" || node.kind === "const" && node.declarations.length === 1
  );
}

// src/language-js/print/type-annotation.js
function shouldHugType(node) {
  if (isSimpleType(node) || isObjectType(node)) {
    return true;
  }
  if (node.type === "UnionTypeAnnotation" || node.type === "TSUnionType") {
    const voidCount = node.types.filter(
      (node2) => node2.type === "VoidTypeAnnotation" || node2.type === "TSVoidKeyword" || node2.type === "NullLiteralTypeAnnotation" || node2.type === "TSNullKeyword"
    ).length;
    const hasObject = node.types.some(
      (node2) => node2.type === "ObjectTypeAnnotation" || node2.type === "TSTypeLiteral" || // This is a bit aggressive but captures Array<{x}>
      node2.type === "GenericTypeAnnotation" || node2.type === "TSTypeReference"
    );
    const hasComments2 = node.types.some((node2) => hasComment(node2));
    if (node.types.length - 1 === voidCount && hasObject && !hasComments2) {
      return true;
    }
  }
  return false;
}
function printOpaqueType(path11, options9, print4) {
  const semi = options9.semi ? ";" : "";
  const { node } = path11;
  const parts = [
    printDeclareToken(path11),
    "opaque type ",
    print4("id"),
    print4("typeParameters")
  ];
  if (node.supertype) {
    parts.push(": ", print4("supertype"));
  }
  if (node.impltype) {
    parts.push(" = ", print4("impltype"));
  }
  parts.push(semi);
  return parts;
}
function printTypeAlias(path11, options9, print4) {
  const semi = options9.semi ? ";" : "";
  const { node } = path11;
  const parts = [printDeclareToken(path11)];
  parts.push("type ", print4("id"), print4("typeParameters"));
  const rightPropertyName = node.type === "TSTypeAliasDeclaration" ? "typeAnnotation" : "right";
  return [
    printAssignment(path11, options9, print4, parts, " =", rightPropertyName),
    semi
  ];
}
function printIntersectionType(path11, options9, print4) {
  const { node } = path11;
  const types = path11.map(print4, "types");
  const result = [];
  let wasIndented = false;
  for (let i = 0; i < types.length; ++i) {
    if (i === 0) {
      result.push(types[i]);
    } else if (isObjectType(node.types[i - 1]) && isObjectType(node.types[i])) {
      result.push([" & ", wasIndented ? indent(types[i]) : types[i]]);
    } else if (!isObjectType(node.types[i - 1]) && !isObjectType(node.types[i])) {
      result.push(indent([" &", line, types[i]]));
    } else {
      if (i > 1) {
        wasIndented = true;
      }
      result.push(" & ", i > 1 ? indent(types[i]) : types[i]);
    }
  }
  return group(result);
}
function printUnionType(path11, options9, print4) {
  const { node } = path11;
  const { parent } = path11;
  const shouldIndent = parent.type !== "TypeParameterInstantiation" && parent.type !== "TSTypeParameterInstantiation" && parent.type !== "GenericTypeAnnotation" && parent.type !== "TSTypeReference" && parent.type !== "TSTypeAssertion" && parent.type !== "TupleTypeAnnotation" && parent.type !== "TSTupleType" && !(parent.type === "FunctionTypeParam" && !parent.name && path11.grandparent.this !== parent) && !((parent.type === "TypeAlias" || parent.type === "VariableDeclarator" || parent.type === "TSTypeAliasDeclaration") && hasLeadingOwnLineComment(options9.originalText, node));
  const shouldHug = shouldHugType(node);
  const printed = path11.map((typePath) => {
    let printedType = print4();
    if (!shouldHug) {
      printedType = align(2, printedType);
    }
    return printComments(typePath, printedType, options9);
  }, "types");
  if (shouldHug) {
    return join(" | ", printed);
  }
  const shouldAddStartLine = shouldIndent && !hasLeadingOwnLineComment(options9.originalText, node);
  const code = [
    ifBreak([shouldAddStartLine ? line : "", "| "]),
    join([line, "| "], printed)
  ];
  if (needs_parens_default(path11, options9)) {
    return group([indent(code), softline]);
  }
  if (parent.type === "TupleTypeAnnotation" || parent.type === "TSTupleType") {
    const elementTypes = parent[
      // TODO: Remove `types` when babel changes AST of `TupleTypeAnnotation`
      parent.type === "TupleTypeAnnotation" && parent.types ? "types" : "elementTypes"
    ];
    if (elementTypes.length > 1) {
      return group([
        indent([ifBreak(["(", softline]), code]),
        softline,
        ifBreak(")")
      ]);
    }
  }
  return group(shouldIndent ? indent(code) : code);
}
function isFlowArrowFunctionTypeAnnotation(path11) {
  var _a;
  const { node, parent } = path11;
  return node.type === "FunctionTypeAnnotation" && (isObjectTypePropertyAFunction(parent) || !((parent.type === "ObjectTypeProperty" || parent.type === "ObjectTypeInternalSlot") && !parent.variance && !parent.optional && hasSameLocStart(parent, node) || parent.type === "ObjectTypeCallProperty" || ((_a = path11.getParentNode(2)) == null ? void 0 : _a.type) === "DeclareFunction"));
}
function printFunctionType(path11, options9, print4) {
  const { node } = path11;
  const parts = [
    // `TSConstructorType` only
    printAbstractToken(path11)
  ];
  if (node.type === "TSConstructorType" || node.type === "TSConstructSignatureDeclaration") {
    parts.push("new ");
  }
  let parametersDoc = printFunctionParameters(
    path11,
    print4,
    options9,
    /* expandArg */
    false,
    /* printTypeParams */
    true
  );
  const returnTypeDoc = [];
  if (node.type === "FunctionTypeAnnotation") {
    returnTypeDoc.push(
      isFlowArrowFunctionTypeAnnotation(path11) ? " => " : ": ",
      print4("returnType")
    );
  } else {
    returnTypeDoc.push(
      printTypeAnnotationProperty(
        path11,
        print4,
        node.returnType ? "returnType" : "typeAnnotation"
      )
    );
  }
  if (shouldGroupFunctionParameters(node, returnTypeDoc)) {
    parametersDoc = group(parametersDoc);
  }
  parts.push(parametersDoc, returnTypeDoc);
  return group(parts);
}
function printIndexedAccessType(path11, options9, print4) {
  return [
    print4("objectType"),
    printOptionalToken(path11),
    "[",
    print4("indexType"),
    "]"
  ];
}
function printJSDocType(path11, print4, token) {
  const { node } = path11;
  return [
    node.postfix ? "" : token,
    printTypeAnnotationProperty(path11, print4),
    node.postfix ? token : ""
  ];
}
function printRestType(path11, options9, print4) {
  const { node } = path11;
  return [
    "...",
    ...node.type === "TupleTypeSpreadElement" && node.label ? [print4("label"), ": "] : [],
    print4("typeAnnotation")
  ];
}
function printNamedTupleMember(path11, options9, print4) {
  const { node } = path11;
  return [
    // `TupleTypeLabeledElement` only
    node.variance ? print4("variance") : "",
    print4("label"),
    node.optional ? "?" : "",
    ": ",
    print4("elementType")
  ];
}
var typeAnnotationNodesCheckedLeadingComments = /* @__PURE__ */ new WeakSet();
function printTypeAnnotationProperty(path11, print4, propertyName = "typeAnnotation") {
  const {
    node: { [propertyName]: typeAnnotation }
  } = path11;
  if (!typeAnnotation) {
    return "";
  }
  let shouldPrintLeadingSpace = false;
  if (typeAnnotation.type === "TSTypeAnnotation" || typeAnnotation.type === "TypeAnnotation") {
    const firstToken = path11.call(getTypeAnnotationFirstToken, propertyName);
    if (firstToken === "=>" || firstToken === ":" && hasComment(typeAnnotation, CommentCheckFlags.Leading)) {
      shouldPrintLeadingSpace = true;
    }
    typeAnnotationNodesCheckedLeadingComments.add(typeAnnotation);
  }
  return shouldPrintLeadingSpace ? [" ", print4(propertyName)] : print4(propertyName);
}
var getTypeAnnotationFirstToken = (path11) => {
  if (
    // TypeScript
    path11.match(
      (node) => node.type === "TSTypeAnnotation",
      (node, key) => (key === "returnType" || key === "typeAnnotation") && (node.type === "TSFunctionType" || node.type === "TSConstructorType")
    )
  ) {
    return "=>";
  }
  if (
    // TypeScript
    path11.match(
      (node) => node.type === "TSTypeAnnotation",
      (node, key) => key === "typeAnnotation" && (node.type === "TSJSDocNullableType" || node.type === "TSJSDocNonNullableType" || node.type === "TSTypePredicate")
    ) || /*
        Flow
    
        ```js
        declare function foo(): void;
                            ^^^^^^^^ `TypeAnnotation`
        ```
        */
    path11.match(
      (node) => node.type === "TypeAnnotation",
      (node, key) => key === "typeAnnotation" && node.type === "Identifier",
      (node, key) => key === "id" && node.type === "DeclareFunction"
    )
  ) {
    return "";
  }
  return ":";
};
function printTypeAnnotation(path11, options9, print4) {
  if (false) {
    const { node } = path11;
    if (!typeAnnotationNodesCheckedLeadingComments.has(node)) {
      throw Object.assign(
        new Error(
          `'${node.type}' should be printed by '${printTypeAnnotationProperty.name}' function.`
        ),
        { parentNode: path11.parent, propertyName: path11.key }
      );
    }
  }
  const token = getTypeAnnotationFirstToken(path11);
  return token ? [token, " ", print4("typeAnnotation")] : print4("typeAnnotation");
}

// src/language-js/print/type-parameters.js
var getTypeParametersGroupId = create_group_id_mapper_default("typeParameters");
function printTypeParameters(path11, options9, print4, paramsKey) {
  const { node } = path11;
  if (!node[paramsKey]) {
    return "";
  }
  if (!Array.isArray(node[paramsKey])) {
    return print4(paramsKey);
  }
  const grandparent = path11.getNode(2);
  const isParameterInTestCall = grandparent && isTestCall(grandparent);
  const isArrowFunctionVariable = path11.match(
    (node2) => !(node2[paramsKey].length === 1 && isObjectType(node2[paramsKey][0])),
    void 0,
    (node2, name) => name === "typeAnnotation",
    (node2) => node2.type === "Identifier",
    isArrowFunctionVariableDeclarator
  );
  const shouldInline = node[paramsKey].length === 0 || !isArrowFunctionVariable && (isParameterInTestCall || node[paramsKey].length === 1 && (node[paramsKey][0].type === "NullableTypeAnnotation" || shouldHugType(node[paramsKey][0])));
  if (shouldInline) {
    return [
      "<",
      join(", ", path11.map(print4, paramsKey)),
      printDanglingCommentsForInline(path11, options9),
      ">"
    ];
  }
  const trailingComma = node.type === "TSTypeParameterInstantiation" ? "" : getFunctionParameters(node).length === 1 && isTSXFile(options9) && !node[paramsKey][0].constraint && path11.parent.type === "ArrowFunctionExpression" ? "," : shouldPrintComma(options9) ? ifBreak(",") : "";
  return group(
    [
      "<",
      indent([softline, join([",", line], path11.map(print4, paramsKey))]),
      trailingComma,
      softline,
      ">"
    ],
    { id: getTypeParametersGroupId(node) }
  );
}
function printDanglingCommentsForInline(path11, options9) {
  const { node } = path11;
  if (!hasComment(node, CommentCheckFlags.Dangling)) {
    return "";
  }
  const hasOnlyBlockComments = !hasComment(node, CommentCheckFlags.Line);
  const printed = printDanglingComments(path11, options9, {
    indent: !hasOnlyBlockComments
  });
  if (hasOnlyBlockComments) {
    return printed;
  }
  return [printed, hardline];
}
function printTypeParameter(path11, options9, print4) {
  const { node, parent } = path11;
  const parts = [node.type === "TSTypeParameter" && node.const ? "const " : ""];
  const name = node.type === "TSTypeParameter" ? print4("name") : node.name;
  if (parent.type === "TSMappedType") {
    if (parent.readonly) {
      parts.push(
        getTypeScriptMappedTypeModifier(parent.readonly, "readonly"),
        " "
      );
    }
    parts.push("[", name);
    if (node.constraint) {
      parts.push(" in ", print4("constraint"));
    }
    if (parent.nameType) {
      parts.push(
        " as ",
        path11.callParent(() => print4("nameType"))
      );
    }
    parts.push("]");
    return parts;
  }
  if (node.variance) {
    parts.push(print4("variance"));
  }
  if (node.in) {
    parts.push("in ");
  }
  if (node.out) {
    parts.push("out ");
  }
  parts.push(name);
  if (node.bound) {
    parts.push(printTypeAnnotationProperty(path11, print4, "bound"));
  }
  if (node.constraint) {
    parts.push(" extends ", print4("constraint"));
  }
  if (node.default) {
    parts.push(" = ", print4("default"));
  }
  return parts;
}

// src/language-js/print/function.js
import assert5 from "assert";

// src/language-js/print/property.js
var needsQuoteProps = /* @__PURE__ */ new WeakMap();
function printPropertyKey(path11, options9, print4) {
  const { node } = path11;
  if (node.computed) {
    return ["[", print4("key"), "]"];
  }
  const { parent } = path11;
  const { key } = node;
  if (options9.quoteProps === "consistent" && !needsQuoteProps.has(parent)) {
    const objectHasStringProp = (parent.properties || parent.body || parent.members).some(
      (prop) => !prop.computed && prop.key && isStringLiteral(prop.key) && !isStringPropSafeToUnquote(prop, options9)
    );
    needsQuoteProps.set(parent, objectHasStringProp);
  }
  if ((key.type === "Identifier" || isNumericLiteral(key) && isSimpleNumber(print_number_default(rawText(key))) && // Avoid converting 999999999999999999999 to 1e+21, 0.99999999999999999 to 1 and 1.0 to 1.
  String(key.value) === print_number_default(rawText(key)) && // Quoting number keys is safe in JS and Flow, but not in TypeScript (as
  // mentioned in `isStringPropSafeToUnquote`).
  !(options9.parser === "typescript" || options9.parser === "babel-ts")) && (options9.parser === "json" || options9.quoteProps === "consistent" && needsQuoteProps.get(parent))) {
    const prop = print_string_default(
      JSON.stringify(
        key.type === "Identifier" ? key.name : key.value.toString()
      ),
      options9
    );
    return path11.call((keyPath) => printComments(keyPath, prop, options9), "key");
  }
  if (isStringPropSafeToUnquote(node, options9) && (options9.quoteProps === "as-needed" || options9.quoteProps === "consistent" && !needsQuoteProps.get(parent))) {
    return path11.call(
      (keyPath) => printComments(
        keyPath,
        /^\d/.test(key.value) ? print_number_default(key.value) : key.value,
        options9
      ),
      "key"
    );
  }
  return print4("key");
}
function printProperty(path11, options9, print4) {
  const { node } = path11;
  if (node.shorthand) {
    return print4("value");
  }
  return printAssignment(
    path11,
    options9,
    print4,
    printPropertyKey(path11, options9, print4),
    ":",
    "value"
  );
}

// src/language-js/print/function.js
var isMethod = (node) => node.type === "ObjectMethod" || node.type === "ClassMethod" || node.type === "ClassPrivateMethod" || node.type === "MethodDefinition" || node.type === "TSAbstractMethodDefinition" || node.type === "TSDeclareMethod" || (node.type === "Property" || node.type === "ObjectProperty") && (node.method || node.kind === "get" || node.kind === "set");
var isMethodValue = (path11) => path11.node.type === "FunctionExpression" && path11.key === "value" && isMethod(path11.parent);
function printFunction(path11, print4, options9, args) {
  if (isMethodValue(path11)) {
    return printMethodValue(path11, options9, print4);
  }
  const { node } = path11;
  let expandArg = false;
  if ((node.type === "FunctionDeclaration" || node.type === "FunctionExpression") && (args == null ? void 0 : args.expandLastArg)) {
    const { parent } = path11;
    if (isCallExpression(parent) && (getCallArguments(parent).length > 1 || getFunctionParameters(node).every(
      (param) => param.type === "Identifier" && !param.typeAnnotation
    ))) {
      expandArg = true;
    }
  }
  const parts = [
    printDeclareToken(path11),
    node.async ? "async " : "",
    `function${node.generator ? "*" : ""} `,
    node.id ? print4("id") : ""
  ];
  const parametersDoc = printFunctionParameters(
    path11,
    print4,
    options9,
    expandArg
  );
  const returnTypeDoc = printReturnType(path11, print4);
  const shouldGroupParameters = shouldGroupFunctionParameters(
    node,
    returnTypeDoc
  );
  parts.push(
    printFunctionTypeParameters(path11, options9, print4),
    group([
      shouldGroupParameters ? group(parametersDoc) : parametersDoc,
      returnTypeDoc
    ]),
    node.body ? " " : "",
    print4("body")
  );
  if (options9.semi && (node.declare || !node.body)) {
    parts.push(";");
  }
  return parts;
}
function printMethod(path11, options9, print4) {
  const { node } = path11;
  const { kind } = node;
  const value = node.value || node;
  const parts = [];
  if (!kind || kind === "init" || kind === "method" || kind === "constructor") {
    if (value.async) {
      parts.push("async ");
    }
  } else {
    assert5.ok(kind === "get" || kind === "set");
    parts.push(kind, " ");
  }
  if (value.generator) {
    parts.push("*");
  }
  parts.push(
    printPropertyKey(path11, options9, print4),
    node.optional || node.key.optional ? "?" : "",
    node === value ? printMethodValue(path11, options9, print4) : print4("value")
  );
  return parts;
}
function printMethodValue(path11, options9, print4) {
  const { node } = path11;
  const parametersDoc = printFunctionParameters(path11, print4, options9);
  const returnTypeDoc = printReturnType(path11, print4);
  const shouldGroupParameters = shouldGroupFunctionParameters(
    node,
    returnTypeDoc
  );
  const parts = [
    printFunctionTypeParameters(path11, options9, print4),
    group([
      shouldGroupParameters ? group(parametersDoc) : parametersDoc,
      returnTypeDoc
    ])
  ];
  if (node.body) {
    parts.push(" ", print4("body"));
  } else {
    parts.push(options9.semi ? ";" : "");
  }
  return parts;
}
function printArrowFunctionSignature(path11, options9, print4, args) {
  const { node } = path11;
  const parts = [];
  if (node.async) {
    parts.push("async ");
  }
  if (shouldPrintParamsWithoutParens(path11, options9)) {
    parts.push(print4(["params", 0]));
  } else {
    const expandArg = (args == null ? void 0 : args.expandLastArg) || (args == null ? void 0 : args.expandFirstArg);
    let returnTypeDoc = printReturnType(path11, print4);
    if (expandArg) {
      if (willBreak(returnTypeDoc)) {
        throw new ArgExpansionBailout();
      }
      returnTypeDoc = group(removeLines(returnTypeDoc));
    }
    parts.push(
      group([
        printFunctionParameters(
          path11,
          print4,
          options9,
          expandArg,
          /* printTypeParams */
          true
        ),
        returnTypeDoc
      ])
    );
  }
  const dangling = printDanglingComments(path11, options9, {
    filter(comment) {
      const nextCharacter = get_next_non_space_non_comment_character_index_default(
        options9.originalText,
        locEnd(comment)
      );
      return nextCharacter !== false && options9.originalText.slice(nextCharacter, nextCharacter + 2) === "=>";
    }
  });
  if (dangling) {
    parts.push(" ", dangling);
  }
  return parts;
}
function printArrowChain(path11, args, signatures, shouldBreak, bodyDoc, tailNode) {
  const { parent, key } = path11;
  const isCallee = isCallLikeExpression(parent) && key === "callee";
  const isAssignmentRhs = Boolean(args == null ? void 0 : args.assignmentLayout);
  const shouldPutBodyOnSeparateLine = tailNode.body.type !== "BlockStatement" && !isObjectOrRecordExpression(tailNode.body) && tailNode.body.type !== "SequenceExpression";
  const shouldBreakBeforeChain = isCallee && shouldPutBodyOnSeparateLine || (args == null ? void 0 : args.assignmentLayout) === "chain-tail-arrow-chain";
  const groupId = Symbol("arrow-chain");
  if (isCallLikeExpression(parent) && !isCallee || isBinaryish(parent)) {
    signatures = [dedent(signatures[0]), ...signatures.slice(1)];
  }
  if (tailNode.body.type === "SequenceExpression") {
    bodyDoc = group(["(", indent([softline, bodyDoc]), softline, ")"]);
  }
  return group([
    group(
      indent([
        isCallee || isAssignmentRhs ? softline : "",
        group(join([" =>", line], signatures), { shouldBreak })
      ]),
      { id: groupId, shouldBreak: shouldBreakBeforeChain }
    ),
    " =>",
    indentIfBreak(
      shouldPutBodyOnSeparateLine ? indent([line, bodyDoc]) : [" ", bodyDoc],
      { groupId }
    ),
    isCallee ? ifBreak(softline, "", { groupId }) : ""
  ]);
}
function printArrowFunction(path11, options9, print4, args) {
  var _a, _b;
  let { node } = path11;
  const signatures = [];
  const body = [];
  let chainShouldBreak = false;
  (function rec() {
    const doc2 = printArrowFunctionSignature(path11, options9, print4, args);
    if (signatures.length === 0) {
      signatures.push(doc2);
    } else {
      const { leading, trailing } = printCommentsSeparately(path11, options9);
      signatures.push([leading, doc2]);
      body.unshift(trailing);
    }
    chainShouldBreak = chainShouldBreak || // Always break the chain if:
    node.returnType && getFunctionParameters(node).length > 0 || node.typeParameters || getFunctionParameters(node).some((param) => param.type !== "Identifier");
    if (node.body.type !== "ArrowFunctionExpression" || (args == null ? void 0 : args.expandLastArg)) {
      body.unshift(print4("body", args));
    } else {
      node = node.body;
      path11.call(rec, "body");
    }
  })();
  if (signatures.length > 1) {
    return printArrowChain(
      path11,
      args,
      signatures,
      chainShouldBreak,
      body,
      node
    );
  }
  const parts = signatures;
  parts.push(" =>");
  if (!hasLeadingOwnLineComment(options9.originalText, node.body) && (isArrayOrTupleExpression(node.body) || isObjectOrRecordExpression(node.body) || node.body.type === "BlockStatement" || isJsxElement(node.body) || ((_a = body[0].label) == null ? void 0 : _a.hug) !== false && (((_b = body[0].label) == null ? void 0 : _b.embed) || isTemplateOnItsOwnLine(node.body, options9.originalText)) || node.body.type === "ArrowFunctionExpression" || node.body.type === "DoExpression")) {
    return group([...parts, " ", body]);
  }
  if (node.body.type === "SequenceExpression") {
    return group([
      ...parts,
      group([" (", indent([softline, body]), softline, ")"])
    ]);
  }
  const shouldAddSoftLine = ((args == null ? void 0 : args.expandLastArg) || path11.parent.type === "JSXExpressionContainer") && !hasComment(node);
  const printTrailingComma = (args == null ? void 0 : args.expandLastArg) && shouldPrintComma(options9, "all");
  const shouldAddParens = node.body.type === "ConditionalExpression" && !startsWithNoLookaheadToken(
    node.body,
    (node2) => node2.type === "ObjectExpression"
  );
  return group([
    ...parts,
    group([
      indent([
        line,
        shouldAddParens ? ifBreak("", "(") : "",
        body,
        shouldAddParens ? ifBreak("", ")") : ""
      ]),
      shouldAddSoftLine ? [ifBreak(printTrailingComma ? "," : ""), softline] : ""
    ])
  ]);
}
function canPrintParamsWithoutParens(node) {
  const parameters = getFunctionParameters(node);
  return parameters.length === 1 && !node.typeParameters && !hasComment(node, CommentCheckFlags.Dangling) && parameters[0].type === "Identifier" && !parameters[0].typeAnnotation && !hasComment(parameters[0]) && !parameters[0].optional && !node.predicate && !node.returnType;
}
function shouldPrintParamsWithoutParens(path11, options9) {
  if (options9.arrowParens === "always") {
    return false;
  }
  if (options9.arrowParens === "avoid") {
    const { node } = path11;
    return canPrintParamsWithoutParens(node);
  }
  return false;
}
function printReturnType(path11, print4) {
  const { node } = path11;
  const returnType = printTypeAnnotationProperty(path11, print4, "returnType");
  const parts = [returnType];
  if (node.predicate) {
    parts.push(node.returnType ? " " : ": ", print4("predicate"));
  }
  return parts;
}
function printReturnOrThrowArgument(path11, options9, print4) {
  const { node } = path11;
  const semi = options9.semi ? ";" : "";
  const parts = [];
  if (node.argument) {
    let argumentDoc = print4("argument");
    if (returnArgumentHasLeadingComment(options9, node.argument)) {
      argumentDoc = ["(", indent([hardline, argumentDoc]), hardline, ")"];
    } else if (isBinaryish(node.argument) || node.argument.type === "SequenceExpression") {
      argumentDoc = group([
        ifBreak("("),
        indent([softline, argumentDoc]),
        softline,
        ifBreak(")")
      ]);
    }
    parts.push(" ", argumentDoc);
  }
  const hasDanglingComments = hasComment(node, CommentCheckFlags.Dangling);
  const shouldPrintSemiBeforeComments = semi && hasDanglingComments && hasComment(node, CommentCheckFlags.Last | CommentCheckFlags.Line);
  if (shouldPrintSemiBeforeComments) {
    parts.push(semi);
  }
  if (hasDanglingComments) {
    parts.push(" ", printDanglingComments(path11, options9));
  }
  if (!shouldPrintSemiBeforeComments) {
    parts.push(semi);
  }
  return parts;
}
function printReturnStatement(path11, options9, print4) {
  return ["return", printReturnOrThrowArgument(path11, options9, print4)];
}
function printThrowStatement(path11, options9, print4) {
  return ["throw", printReturnOrThrowArgument(path11, options9, print4)];
}
function returnArgumentHasLeadingComment(options9, argument) {
  if (hasLeadingOwnLineComment(options9.originalText, argument)) {
    return true;
  }
  if (hasNakedLeftSide(argument)) {
    let leftMost = argument;
    let newLeftMost;
    while (newLeftMost = getLeftSide(leftMost)) {
      leftMost = newLeftMost;
      if (hasLeadingOwnLineComment(options9.originalText, leftMost)) {
        return true;
      }
    }
  }
  return false;
}

// src/language-js/print/decorators.js
function printClassMemberDecorators(path11, options9, print4) {
  const { node } = path11;
  return group([
    join(line, path11.map(print4, "decorators")),
    hasNewlineBetweenOrAfterDecorators(node, options9) ? hardline : line
  ]);
}
function printDecoratorsBeforeExport(path11, options9, print4) {
  return [
    join(hardline, path11.map(print4, "declaration", "decorators")),
    hardline
  ];
}
function printDecorators(path11, options9, print4) {
  const { node, parent } = path11;
  const { decorators } = node;
  if (!is_non_empty_array_default(decorators) || // If the parent node is an export declaration and the decorator
  // was written before the export, the export will be responsible
  // for printing the decorators.
  hasDecoratorsBeforeExport(parent)) {
    return;
  }
  const shouldBreak = node.type === "ClassExpression" || node.type === "ClassDeclaration" || hasNewlineBetweenOrAfterDecorators(node, options9);
  return [
    path11.key === "declaration" && isExportDeclaration(parent) ? hardline : shouldBreak ? breakParent : "",
    join(line, path11.map(print4, "decorators")),
    line
  ];
}
function hasNewlineBetweenOrAfterDecorators(node, options9) {
  return node.decorators.some(
    (decorator) => has_newline_default(options9.originalText, locEnd(decorator))
  );
}
function hasDecoratorsBeforeExport(node) {
  var _a;
  if (node.type !== "ExportDefaultDeclaration" && node.type !== "ExportNamedDeclaration" && node.type !== "DeclareExportDeclaration") {
    return false;
  }
  const decorators = (_a = node.declaration) == null ? void 0 : _a.decorators;
  return is_non_empty_array_default(decorators) && hasSameLocStart(node, decorators[0]);
}

// src/language-js/print/class.js
var isClassProperty = createTypeCheckFunction([
  "ClassProperty",
  "PropertyDefinition",
  "ClassPrivateProperty",
  "ClassAccessorProperty",
  "AccessorProperty",
  "TSAbstractPropertyDefinition",
  "TSAbstractAccessorProperty"
]);
function printClass(path11, options9, print4) {
  const { node } = path11;
  const parts = [printDeclareToken(path11), printAbstractToken(path11), "class"];
  const groupMode = hasComment(node.id, CommentCheckFlags.Trailing) || hasComment(node.typeParameters, CommentCheckFlags.Trailing) || hasComment(node.superClass) || is_non_empty_array_default(node.extends) || // DeclareClass
  is_non_empty_array_default(node.mixins) || is_non_empty_array_default(node.implements);
  const partsGroup = [];
  const extendsParts = [];
  if (node.id) {
    partsGroup.push(" ", print4("id"));
  }
  partsGroup.push(print4("typeParameters"));
  if (node.superClass) {
    const printed = [
      printSuperClass(path11, options9, print4),
      print4("superTypeParameters")
    ];
    const printedWithComments = path11.call(
      (superClass) => ["extends ", printComments(superClass, printed, options9)],
      "superClass"
    );
    if (groupMode) {
      extendsParts.push(line, group(printedWithComments));
    } else {
      extendsParts.push(" ", printedWithComments);
    }
  } else {
    extendsParts.push(printHeritageClauses(path11, options9, print4, "extends"));
  }
  extendsParts.push(
    printHeritageClauses(path11, options9, print4, "mixins"),
    printHeritageClauses(path11, options9, print4, "implements")
  );
  if (groupMode) {
    let printedPartsGroup;
    if (shouldIndentOnlyHeritageClauses(node)) {
      printedPartsGroup = [...partsGroup, indent(extendsParts)];
    } else {
      printedPartsGroup = indent([...partsGroup, extendsParts]);
    }
    parts.push(group(printedPartsGroup, { id: getHeritageGroupId(node) }));
  } else {
    parts.push(...partsGroup, ...extendsParts);
  }
  parts.push(" ", print4("body"));
  return parts;
}
var getHeritageGroupId = create_group_id_mapper_default("heritageGroup");
function printHardlineAfterHeritage(node) {
  return ifBreak(hardline, "", { groupId: getHeritageGroupId(node) });
}
function hasMultipleHeritage(node) {
  return ["extends", "mixins", "implements"].reduce(
    (count, key) => count + (Array.isArray(node[key]) ? node[key].length : 0),
    node.superClass ? 1 : 0
  ) > 1;
}
function shouldIndentOnlyHeritageClauses(node) {
  return node.typeParameters && !hasComment(
    node.typeParameters,
    CommentCheckFlags.Trailing | CommentCheckFlags.Line
  ) && !hasMultipleHeritage(node);
}
function printHeritageClauses(path11, options9, print4, listName) {
  const { node } = path11;
  if (!is_non_empty_array_default(node[listName])) {
    return "";
  }
  const printedLeadingComments = printDanglingComments(path11, options9, {
    marker: listName
  });
  return [
    shouldIndentOnlyHeritageClauses(node) ? ifBreak(" ", line, {
      groupId: getTypeParametersGroupId(node.typeParameters)
    }) : line,
    printedLeadingComments,
    printedLeadingComments && hardline,
    listName,
    group(indent([line, join([",", line], path11.map(print4, listName))]))
  ];
}
function printSuperClass(path11, options9, print4) {
  const printed = print4("superClass");
  const { parent } = path11;
  if (parent.type === "AssignmentExpression") {
    return group(
      ifBreak(["(", indent([softline, printed]), softline, ")"], printed)
    );
  }
  return printed;
}
function printClassMethod(path11, options9, print4) {
  const { node } = path11;
  const parts = [];
  if (is_non_empty_array_default(node.decorators)) {
    parts.push(printClassMemberDecorators(path11, options9, print4));
  }
  parts.push(printTypeScriptAccessibilityToken(node));
  if (node.static) {
    parts.push("static ");
  }
  parts.push(printAbstractToken(path11));
  if (node.override) {
    parts.push("override ");
  }
  parts.push(printMethod(path11, options9, print4));
  return parts;
}
function printClassProperty(path11, options9, print4) {
  const { node } = path11;
  const parts = [];
  const semi = options9.semi ? ";" : "";
  if (is_non_empty_array_default(node.decorators)) {
    parts.push(printClassMemberDecorators(path11, options9, print4));
  }
  parts.push(printTypeScriptAccessibilityToken(node), printDeclareToken(path11));
  if (node.static) {
    parts.push("static ");
  }
  parts.push(printAbstractToken(path11));
  if (node.override) {
    parts.push("override ");
  }
  if (node.readonly) {
    parts.push("readonly ");
  }
  if (node.variance) {
    parts.push(print4("variance"));
  }
  if (node.type === "ClassAccessorProperty" || node.type === "AccessorProperty" || node.type === "TSAbstractAccessorProperty") {
    parts.push("accessor ");
  }
  parts.push(
    printPropertyKey(path11, options9, print4),
    printOptionalToken(path11),
    printDefiniteToken(path11),
    printTypeAnnotationProperty(path11, print4)
  );
  const isAbstractProperty = node.type === "TSAbstractPropertyDefinition" || node.type === "TSAbstractAccessorProperty";
  return [
    printAssignment(
      path11,
      options9,
      print4,
      parts,
      " =",
      isAbstractProperty ? void 0 : "value"
    ),
    semi
  ];
}
function printClassBody(path11, options9, print4) {
  const { node } = path11;
  const parts = [];
  path11.each(({ node: node2, next, isLast }) => {
    parts.push(print4());
    if (!options9.semi && isClassProperty(node2) && shouldPrintSemicolonAfterClassProperty(node2, next)) {
      parts.push(";");
    }
    if (!isLast) {
      parts.push(hardline);
      if (isNextLineEmpty2(node2, options9)) {
        parts.push(hardline);
      }
    }
  }, "body");
  if (hasComment(node, CommentCheckFlags.Dangling)) {
    parts.push(printDanglingComments(path11, options9));
  }
  return [
    is_non_empty_array_default(node.body) ? printHardlineAfterHeritage(path11.parent) : "",
    "{",
    parts.length > 0 ? [indent([hardline, parts]), hardline] : "",
    "}"
  ];
}
function shouldPrintSemicolonAfterClassProperty(node, nextNode) {
  var _a;
  const { type, name } = node.key;
  if (!node.computed && type === "Identifier" && (name === "static" || name === "get" || name === "set" || // TODO: Remove this https://github.com/microsoft/TypeScript/issues/51707 is fixed
  name === "accessor") && !node.value && !node.typeAnnotation) {
    return true;
  }
  if (!nextNode) {
    return false;
  }
  if (nextNode.static || nextNode.accessibility) {
    return false;
  }
  if (!nextNode.computed) {
    const name2 = (_a = nextNode.key) == null ? void 0 : _a.name;
    if (name2 === "in" || name2 === "instanceof") {
      return true;
    }
  }
  if (isClassProperty(nextNode) && nextNode.variance && !nextNode.static && !nextNode.declare) {
    return true;
  }
  switch (nextNode.type) {
    case "ClassProperty":
    case "PropertyDefinition":
    case "TSAbstractPropertyDefinition":
      return nextNode.computed;
    case "MethodDefinition":
    case "TSAbstractMethodDefinition":
    case "ClassMethod":
    case "ClassPrivateMethod": {
      const isAsync = nextNode.value ? nextNode.value.async : nextNode.async;
      if (isAsync || nextNode.kind === "get" || nextNode.kind === "set") {
        return false;
      }
      const isGenerator = nextNode.value ? nextNode.value.generator : nextNode.generator;
      if (nextNode.computed || isGenerator) {
        return true;
      }
      return false;
    }
    case "TSIndexSignature":
      return true;
  }
  return false;
}

// src/language-js/print/interface.js
function printInterface(path11, options9, print4) {
  const { node } = path11;
  const parts = [printDeclareToken(path11), "interface"];
  const partsGroup = [];
  const extendsParts = [];
  if (node.type !== "InterfaceTypeAnnotation") {
    partsGroup.push(" ", print4("id"), print4("typeParameters"));
  }
  const shouldIndentOnlyHeritageClauses2 = node.typeParameters && !hasComment(
    node.typeParameters,
    CommentCheckFlags.Trailing | CommentCheckFlags.Line
  );
  if (is_non_empty_array_default(node.extends)) {
    extendsParts.push(
      shouldIndentOnlyHeritageClauses2 ? ifBreak(" ", line, {
        groupId: getTypeParametersGroupId(node.typeParameters)
      }) : line,
      "extends ",
      (node.extends.length === 1 ? identity : indent)(
        join([",", line], path11.map(print4, "extends"))
      )
    );
  }
  if (hasComment(node.id, CommentCheckFlags.Trailing) || is_non_empty_array_default(node.extends)) {
    if (shouldIndentOnlyHeritageClauses2) {
      parts.push(group([...partsGroup, indent(extendsParts)]));
    } else {
      parts.push(group(indent([...partsGroup, ...extendsParts])));
    }
  } else {
    parts.push(...partsGroup, ...extendsParts);
  }
  parts.push(" ", print4("body"));
  return group(parts);
}

// src/language-js/print/module.js
function printImportDeclaration(path11, options9, print4) {
  const { node } = path11;
  const semi = options9.semi ? ";" : "";
  const parts = [];
  const { importKind } = node;
  parts.push("import");
  if (node.module) {
    parts.push(" module");
  }
  if (importKind && importKind !== "value") {
    parts.push(" ", importKind);
  }
  parts.push(
    printModuleSpecifiers(path11, options9, print4),
    printModuleSource(path11, options9, print4),
    printImportAssertions(path11, options9, print4),
    semi
  );
  return parts;
}
function printExportDeclaration(path11, options9, print4) {
  const { node } = path11;
  const parts = [];
  if (hasDecoratorsBeforeExport(node)) {
    parts.push(printDecoratorsBeforeExport(path11, options9, print4));
  }
  const { type, exportKind, declaration } = node;
  parts.push(printDeclareToken(path11), "export");
  const isDefaultExport = node.default || type === "ExportDefaultDeclaration";
  if (isDefaultExport) {
    parts.push(" default");
  }
  if (hasComment(node, CommentCheckFlags.Dangling)) {
    parts.push(" ", printDanglingComments(path11, options9));
    if (needsHardlineAfterDanglingComment(node)) {
      parts.push(hardline);
    }
  }
  if (declaration) {
    parts.push(" ", print4("declaration"));
  } else {
    parts.push(
      exportKind === "type" ? " type" : "",
      printModuleSpecifiers(path11, options9, print4),
      printModuleSource(path11, options9, print4),
      printImportAssertions(path11, options9, print4)
    );
  }
  if (shouldExportDeclarationPrintSemi(node, options9)) {
    parts.push(";");
  }
  return parts;
}
function printExportAllDeclaration(path11, options9, print4) {
  const { node } = path11;
  const semi = options9.semi ? ";" : "";
  const parts = [printDeclareToken(path11), "export"];
  const { exportKind, exported } = node;
  if (exportKind === "type") {
    parts.push(" type");
  }
  parts.push(" *");
  if (exported) {
    parts.push(" as ", print4("exported"));
  }
  parts.push(
    printModuleSource(path11, options9, print4),
    printImportAssertions(path11, options9, print4),
    semi
  );
  return parts;
}
function shouldExportDeclarationPrintSemi(node, options9) {
  if (!options9.semi) {
    return false;
  }
  const { type, declaration } = node;
  const isDefaultExport = node.default || type === "ExportDefaultDeclaration";
  if (!declaration) {
    return true;
  }
  const { type: declarationType } = declaration;
  if (isDefaultExport && declarationType !== "ClassDeclaration" && declarationType !== "FunctionDeclaration" && declarationType !== "TSInterfaceDeclaration" && declarationType !== "DeclareClass" && declarationType !== "DeclareFunction" && declarationType !== "TSDeclareFunction" && declarationType !== "EnumDeclaration") {
    return true;
  }
  return false;
}
function printModuleSource(path11, options9, print4) {
  const { node } = path11;
  if (!node.source) {
    return "";
  }
  const parts = [];
  if (!shouldNotPrintSpecifiers(node, options9)) {
    parts.push(" from");
  }
  parts.push(" ", print4("source"));
  return parts;
}
function printModuleSpecifiers(path11, options9, print4) {
  const { node } = path11;
  if (shouldNotPrintSpecifiers(node, options9)) {
    return "";
  }
  const parts = [" "];
  if (is_non_empty_array_default(node.specifiers)) {
    const standaloneSpecifiers = [];
    const groupedSpecifiers = [];
    path11.each(() => {
      const specifierType = path11.node.type;
      if (specifierType === "ExportNamespaceSpecifier" || specifierType === "ExportDefaultSpecifier" || specifierType === "ImportNamespaceSpecifier" || specifierType === "ImportDefaultSpecifier") {
        standaloneSpecifiers.push(print4());
      } else if (specifierType === "ExportSpecifier" || specifierType === "ImportSpecifier") {
        groupedSpecifiers.push(print4());
      } else {
        throw new unexpected_node_error_default(node, "specifier");
      }
    }, "specifiers");
    parts.push(join(", ", standaloneSpecifiers));
    if (groupedSpecifiers.length > 0) {
      if (standaloneSpecifiers.length > 0) {
        parts.push(", ");
      }
      const canBreak2 = groupedSpecifiers.length > 1 || standaloneSpecifiers.length > 0 || node.specifiers.some((node2) => hasComment(node2));
      if (canBreak2) {
        parts.push(
          group([
            "{",
            indent([
              options9.bracketSpacing ? line : softline,
              join([",", line], groupedSpecifiers)
            ]),
            ifBreak(shouldPrintComma(options9) ? "," : ""),
            options9.bracketSpacing ? line : softline,
            "}"
          ])
        );
      } else {
        parts.push([
          "{",
          options9.bracketSpacing ? " " : "",
          ...groupedSpecifiers,
          options9.bracketSpacing ? " " : "",
          "}"
        ]);
      }
    }
  } else {
    parts.push("{}");
  }
  return parts;
}
function shouldNotPrintSpecifiers(node, options9) {
  const { type, importKind, source, specifiers } = node;
  if (type !== "ImportDeclaration" || is_non_empty_array_default(specifiers) || importKind === "type") {
    return false;
  }
  return !/{\s*}/.test(
    options9.originalText.slice(locStart(node), locStart(source))
  );
}
function printImportAssertions(path11, options9, print4) {
  const { node } = path11;
  if (is_non_empty_array_default(node.assertions)) {
    return [
      " assert {",
      options9.bracketSpacing ? " " : "",
      join(", ", path11.map(print4, "assertions")),
      options9.bracketSpacing ? " " : "",
      "}"
    ];
  }
  return "";
}
function printModuleSpecifier(path11, options9, print4) {
  const { node } = path11;
  const { type } = node;
  const parts = [];
  const kind = type === "ImportSpecifier" ? node.importKind : node.exportKind;
  if (kind && kind !== "value") {
    parts.push(kind, " ");
  }
  const isImport = type.startsWith("Import");
  const leftSideProperty = isImport ? "imported" : "local";
  const rightSideProperty = isImport ? "local" : "exported";
  const leftSideNode = node[leftSideProperty];
  const rightSideNode = node[rightSideProperty];
  let left = "";
  let right = "";
  if (type === "ExportNamespaceSpecifier" || type === "ImportNamespaceSpecifier") {
    left = "*";
  } else if (leftSideNode) {
    left = print4(leftSideProperty);
  }
  if (rightSideNode && !isShorthandSpecifier(node)) {
    right = print4(rightSideProperty);
  }
  parts.push(left, left && right ? " as " : "", right);
  return parts;
}
function isShorthandSpecifier(specifier) {
  if (specifier.type !== "ImportSpecifier" && specifier.type !== "ExportSpecifier") {
    return false;
  }
  const {
    local,
    [specifier.type === "ImportSpecifier" ? "imported" : "exported"]: importedOrExported
  } = specifier;
  if (local.type !== importedOrExported.type || !hasSameLoc(local, importedOrExported)) {
    return false;
  }
  if (isStringLiteral(local)) {
    return local.value === importedOrExported.value && rawText(local) === rawText(importedOrExported);
  }
  switch (local.type) {
    case "Identifier":
      return local.name === importedOrExported.name;
    default:
      return false;
  }
}

// src/language-js/print/object.js
function printObject(path11, options9, print4) {
  var _a;
  const semi = options9.semi ? ";" : "";
  const {
    node
  } = path11;
  const isTypeAnnotation = node.type === "ObjectTypeAnnotation";
  const isEnumBody = node.type === "TSEnumDeclaration" || node.type === "EnumBooleanBody" || node.type === "EnumNumberBody" || node.type === "EnumStringBody" || node.type === "EnumSymbolBody";
  const fields = [node.type === "TSTypeLiteral" || isEnumBody ? "members" : node.type === "TSInterfaceBody" ? "body" : "properties"];
  if (isTypeAnnotation) {
    fields.push("indexers", "callProperties", "internalSlots");
  }
  const propsAndLoc = fields.flatMap((field) => path11.map(({
    node: node2
  }) => ({
    node: node2,
    printed: print4(),
    loc: locStart(node2)
  }), field));
  if (fields.length > 1) {
    propsAndLoc.sort((a, b) => a.loc - b.loc);
  }
  const {
    parent,
    key
  } = path11;
  const isFlowInterfaceLikeBody = isTypeAnnotation && key === "body" && (parent.type === "InterfaceDeclaration" || parent.type === "DeclareInterface" || parent.type === "DeclareClass");
  const shouldBreak = node.type === "TSInterfaceBody" || isEnumBody || isFlowInterfaceLikeBody || node.type === "ObjectPattern" && parent.type !== "FunctionDeclaration" && parent.type !== "FunctionExpression" && parent.type !== "ArrowFunctionExpression" && parent.type !== "ObjectMethod" && parent.type !== "ClassMethod" && parent.type !== "ClassPrivateMethod" && parent.type !== "AssignmentPattern" && parent.type !== "CatchClause" && node.properties.some((property) => property.value && (property.value.type === "ObjectPattern" || property.value.type === "ArrayPattern")) || node.type !== "ObjectPattern" && propsAndLoc.length > 0 && has_newline_in_range_default(options9.originalText, locStart(node), propsAndLoc[0].loc);
  const separator = isFlowInterfaceLikeBody ? ";" : node.type === "TSInterfaceBody" || node.type === "TSTypeLiteral" ? ifBreak(semi, ";") : ",";
  const leftBrace = node.type === "RecordExpression" ? "#{" : node.exact ? "{|" : "{";
  const rightBrace = node.exact ? "|}" : "}";
  let separatorParts = [];
  const props = propsAndLoc.map((prop) => {
    const result = [...separatorParts, group(prop.printed)];
    separatorParts = [separator, line];
    if ((prop.node.type === "TSPropertySignature" || prop.node.type === "TSMethodSignature" || prop.node.type === "TSConstructSignatureDeclaration") && hasComment(prop.node, CommentCheckFlags.PrettierIgnore)) {
      separatorParts.shift();
    }
    if (isNextLineEmpty2(prop.node, options9)) {
      separatorParts.push(hardline);
    }
    return result;
  });
  if (node.inexact || node.hasUnknownMembers) {
    let printed;
    if (hasComment(node, CommentCheckFlags.Dangling)) {
      const hasLineComments = hasComment(node, CommentCheckFlags.Line);
      const printedDanglingComments = printDanglingComments(path11, options9);
      printed = [printedDanglingComments, hasLineComments || has_newline_default(options9.originalText, locEnd(at_default(
        /* isOptionalObject*/
        false,
        getComments(node),
        -1
      ))) ? hardline : line, "..."];
    } else {
      printed = ["..."];
    }
    props.push([...separatorParts, ...printed]);
  }
  const lastElem = (_a = at_default(
    /* isOptionalObject*/
    false,
    propsAndLoc,
    -1
  )) == null ? void 0 : _a.node;
  const canHaveTrailingSeparator = !(node.inexact || node.hasUnknownMembers || lastElem && (lastElem.type === "RestElement" || (lastElem.type === "TSPropertySignature" || lastElem.type === "TSCallSignatureDeclaration" || lastElem.type === "TSMethodSignature" || lastElem.type === "TSConstructSignatureDeclaration") && hasComment(lastElem, CommentCheckFlags.PrettierIgnore)));
  let content;
  if (props.length === 0) {
    if (!hasComment(node, CommentCheckFlags.Dangling)) {
      return [leftBrace, rightBrace, printTypeAnnotationProperty(path11, print4)];
    }
    content = group([leftBrace, printDanglingComments(path11, options9, {
      indent: true
    }), softline, rightBrace, printOptionalToken(path11), printTypeAnnotationProperty(path11, print4)]);
  } else {
    content = [isFlowInterfaceLikeBody && is_non_empty_array_default(node.properties) ? printHardlineAfterHeritage(parent) : "", leftBrace, indent([options9.bracketSpacing ? line : softline, ...props]), ifBreak(canHaveTrailingSeparator && (separator !== "," || shouldPrintComma(options9)) ? separator : ""), options9.bracketSpacing ? line : softline, rightBrace, printOptionalToken(path11), printTypeAnnotationProperty(path11, print4)];
  }
  if (path11.match((node2) => node2.type === "ObjectPattern" && !node2.decorators, shouldHugTheOnlyParameter) || isObjectType(node) && (path11.match(void 0, (node2, name) => name === "typeAnnotation", (node2, name) => name === "typeAnnotation", shouldHugTheOnlyParameter) || path11.match(void 0, (node2, name) => node2.type === "FunctionTypeParam" && name === "typeAnnotation", shouldHugTheOnlyParameter)) || // Assignment printing logic (printAssignment) is responsible
  // for adding a group if needed
  !shouldBreak && path11.match((node2) => node2.type === "ObjectPattern", (node2) => node2.type === "AssignmentExpression" || node2.type === "VariableDeclarator")) {
    return content;
  }
  return group(content, {
    shouldBreak
  });
}
function shouldHugTheOnlyParameter(node, name) {
  return (name === "params" || name === "parameters" || name === "this" || name === "rest") && shouldHugTheOnlyFunctionParameter(node);
}

// src/language-js/print/enum.js
function printEnumMembers(path11, print4, options9) {
  return printObject(path11, options9, print4);
}
function printEnumMember(path11, print4) {
  const { node } = path11;
  let idDoc = print4("id");
  if (node.computed) {
    idDoc = ["[", idDoc, "]"];
  }
  let initializerDoc = "";
  if (node.initializer) {
    initializerDoc = print4("initializer");
  }
  if (node.init) {
    initializerDoc = print4("init");
  }
  if (!initializerDoc) {
    return idDoc;
  }
  return [idDoc, " = ", initializerDoc];
}
function printEnumBody(path11, print4, options9) {
  const { node } = path11;
  let type;
  if (node.type === "EnumSymbolBody" || node.explicitType) {
    switch (node.type) {
      case "EnumBooleanBody":
        type = "boolean";
        break;
      case "EnumNumberBody":
        type = "number";
        break;
      case "EnumStringBody":
        type = "string";
        break;
      case "EnumSymbolBody":
        type = "symbol";
        break;
    }
  }
  return [type ? `of ${type} ` : "", printEnumMembers(path11, print4, options9)];
}
function printEnumDeclaration(path11, print4, options9) {
  const { node } = path11;
  return [
    printDeclareToken(path11),
    node.const ? "const " : "",
    "enum ",
    print4("id"),
    " ",
    node.type === "TSEnumDeclaration" ? printEnumMembers(path11, print4, options9) : print4("body")
  ];
}

// src/language-js/print/flow.js
function printFlow(path11, options9, print4) {
  const { node } = path11;
  const semi = options9.semi ? ";" : "";
  switch (node.type) {
    case "DeclareClass":
      return printClass(path11, options9, print4);
    case "DeclareFunction":
      return [
        printDeclareToken(path11),
        "function ",
        print4("id"),
        node.predicate ? " " : "",
        print4("predicate"),
        semi
      ];
    case "DeclareModule":
      return ["declare module ", print4("id"), " ", print4("body")];
    case "DeclareModuleExports":
      return [
        "declare module.exports",
        printTypeAnnotationProperty(path11, print4),
        semi
      ];
    case "DeclareVariable":
      return [
        printDeclareToken(path11),
        // TODO: Only use `node.kind` when babel update AST
        node.kind ?? "var",
        " ",
        print4("id"),
        semi
      ];
    case "DeclareExportDeclaration":
      return printExportDeclaration(path11, options9, print4);
    case "DeclareExportAllDeclaration":
      return printExportAllDeclaration(path11, options9, print4);
    case "DeclareOpaqueType":
    case "OpaqueType":
      return printOpaqueType(path11, options9, print4);
    case "DeclareTypeAlias":
    case "TypeAlias":
      return printTypeAlias(path11, options9, print4);
    case "IntersectionTypeAnnotation":
      return printIntersectionType(path11, options9, print4);
    case "UnionTypeAnnotation":
      return printUnionType(path11, options9, print4);
    case "FunctionTypeAnnotation":
      return printFunctionType(path11, options9, print4);
    case "TupleTypeAnnotation":
      return printArray(path11, options9, print4);
    case "TupleTypeLabeledElement":
      return printNamedTupleMember(path11, options9, print4);
    case "TupleTypeSpreadElement":
      return printRestType(path11, options9, print4);
    case "GenericTypeAnnotation":
      return [
        print4("id"),
        printTypeParameters(path11, options9, print4, "typeParameters")
      ];
    case "IndexedAccessType":
    case "OptionalIndexedAccessType":
      return printIndexedAccessType(path11, options9, print4);
    case "TypeAnnotation":
      return printTypeAnnotation(path11, options9, print4);
    case "TypeParameter":
      return printTypeParameter(path11, options9, print4);
    case "TypeofTypeAnnotation":
      return ["typeof ", print4("argument")];
    case "ExistsTypeAnnotation":
      return "*";
    case "EmptyTypeAnnotation":
      return "empty";
    case "MixedTypeAnnotation":
      return "mixed";
    case "ArrayTypeAnnotation":
      return [print4("elementType"), "[]"];
    case "BooleanLiteralTypeAnnotation":
      return String(node.value);
    case "DeclareEnum":
    case "EnumDeclaration":
      return printEnumDeclaration(path11, print4, options9);
    case "EnumBooleanBody":
    case "EnumNumberBody":
    case "EnumStringBody":
    case "EnumSymbolBody":
      return printEnumBody(path11, print4, options9);
    case "EnumBooleanMember":
    case "EnumNumberMember":
    case "EnumStringMember":
    case "EnumDefaultedMember":
      return printEnumMember(path11, print4);
    case "FunctionTypeParam": {
      const name = node.name ? print4("name") : path11.parent.this === node ? "this" : "";
      return [
        name,
        printOptionalToken(path11),
        // `flow` doesn't wrap the `typeAnnotation` with `TypeAnnotation`, so the colon
        // needs to be added separately.
        name ? ": " : "",
        print4("typeAnnotation")
      ];
    }
    case "DeclareInterface":
    case "InterfaceDeclaration":
    case "InterfaceTypeAnnotation":
      return printInterface(path11, options9, print4);
    case "ClassImplements":
    case "InterfaceExtends":
      return [print4("id"), print4("typeParameters")];
    case "NullableTypeAnnotation":
      return ["?", print4("typeAnnotation")];
    case "Variance": {
      const { kind } = node;
      assert6.ok(kind === "plus" || kind === "minus");
      return kind === "plus" ? "+" : "-";
    }
    case "ObjectTypeCallProperty":
      return [node.static ? "static " : "", print4("value")];
    case "ObjectTypeIndexer":
      return [
        node.static ? "static " : "",
        node.variance ? print4("variance") : "",
        "[",
        print4("id"),
        node.id ? ": " : "",
        print4("key"),
        "]: ",
        print4("value")
      ];
    case "ObjectTypeProperty": {
      let modifier = "";
      if (node.proto) {
        modifier = "proto ";
      } else if (node.static) {
        modifier = "static ";
      }
      return [
        modifier,
        isGetterOrSetter(node) ? node.kind + " " : "",
        node.variance ? print4("variance") : "",
        printPropertyKey(path11, options9, print4),
        printOptionalToken(path11),
        isFunctionNotation(node) ? "" : ": ",
        print4("value")
      ];
    }
    case "ObjectTypeAnnotation":
      return printObject(path11, options9, print4);
    case "ObjectTypeInternalSlot":
      return [
        node.static ? "static " : "",
        "[[",
        print4("id"),
        "]]",
        printOptionalToken(path11),
        node.method ? "" : ": ",
        print4("value")
      ];
    case "ObjectTypeSpreadProperty":
      return printRestSpread(path11, print4);
    case "QualifiedTypeofIdentifier":
    case "QualifiedTypeIdentifier":
      return [print4("qualification"), ".", print4("id")];
    case "StringLiteralTypeAnnotation":
      return replaceEndOfLine(print_string_default(rawText(node), options9));
    case "NumberLiteralTypeAnnotation":
      return print_number_default(node.raw ?? node.extra.raw);
    case "BigIntLiteralTypeAnnotation":
      return printBigInt(node.raw ?? node.extra.raw);
    case "TypeCastExpression":
      return [
        "(",
        print4("expression"),
        printTypeAnnotationProperty(path11, print4),
        ")"
      ];
    case "TypeParameterDeclaration":
    case "TypeParameterInstantiation":
      return printTypeParameters(path11, options9, print4, "params");
    case "InferredPredicate":
      return "%checks";
    case "DeclaredPredicate":
      return ["%checks(", print4("value"), ")"];
    case "AnyTypeAnnotation":
      return "any";
    case "BooleanTypeAnnotation":
      return "boolean";
    case "BigIntTypeAnnotation":
      return "bigint";
    case "NullLiteralTypeAnnotation":
      return "null";
    case "NumberTypeAnnotation":
      return "number";
    case "SymbolTypeAnnotation":
      return "symbol";
    case "StringTypeAnnotation":
      return "string";
    case "VoidTypeAnnotation":
      return "void";
    case "ThisTypeAnnotation":
      return "this";
    case "NeverTypeAnnotation":
      return "never";
    case "UndefinedTypeAnnotation":
      return "undefined";
    case "UnknownTypeAnnotation":
      return "unknown";
    case "Node":
    case "Printable":
    case "SourceLocation":
    case "Position":
    case "Statement":
    case "Function":
    case "Pattern":
    case "Expression":
    case "Declaration":
    case "Specifier":
    case "NamedSpecifier":
    case "Comment":
    case "MemberTypeAnnotation":
    case "Type":
      throw new unexpected_node_error_default(node, "Flow");
  }
}

// src/language-js/utils/is-ts-keyword-type.js
function isTsKeywordType({ type }) {
  return type.startsWith("TS") && type.endsWith("Keyword");
}
var is_ts_keyword_type_default = isTsKeywordType;

// src/language-js/print/ternary.js
function conditionalExpressionChainContainsJsx(node) {
  const conditionalExpressions = [node];
  for (let index = 0; index < conditionalExpressions.length; index++) {
    const conditionalExpression = conditionalExpressions[index];
    for (const property of ["test", "consequent", "alternate"]) {
      const node2 = conditionalExpression[property];
      if (isJsxElement(node2)) {
        return true;
      }
      if (node2.type === "ConditionalExpression") {
        conditionalExpressions.push(node2);
      }
    }
  }
  return false;
}
function printTernaryTest(path11, options9, print4) {
  const { node } = path11;
  const isConditionalExpression = node.type === "ConditionalExpression";
  const alternateNodePropertyName = isConditionalExpression ? "alternate" : "falseType";
  const { parent } = path11;
  const printed = isConditionalExpression ? print4("test") : [print4("checkType"), " ", "extends", " ", print4("extendsType")];
  if (parent.type === node.type && parent[alternateNodePropertyName] === node) {
    return align(2, printed);
  }
  return printed;
}
var ancestorNameMap = /* @__PURE__ */ new Map([
  ["AssignmentExpression", "right"],
  ["VariableDeclarator", "init"],
  ["ReturnStatement", "argument"],
  ["ThrowStatement", "argument"],
  ["UnaryExpression", "argument"],
  ["YieldExpression", "argument"]
]);
function shouldExtraIndentForConditionalExpression(path11) {
  const { node } = path11;
  if (node.type !== "ConditionalExpression") {
    return false;
  }
  let parent;
  let child = node;
  for (let ancestorCount = 0; !parent; ancestorCount++) {
    const node2 = path11.getParentNode(ancestorCount);
    if (node2.type === "ChainExpression" && node2.expression === child || isCallExpression(node2) && node2.callee === child || isMemberExpression(node2) && node2.object === child || node2.type === "TSNonNullExpression" && node2.expression === child) {
      child = node2;
      continue;
    }
    if (node2.type === "NewExpression" && node2.callee === child || isTSTypeExpression(node2) && node2.expression === child) {
      parent = path11.getParentNode(ancestorCount + 1);
      child = node2;
    } else {
      parent = node2;
    }
  }
  if (child === node) {
    return false;
  }
  return parent[ancestorNameMap.get(parent.type)] === child;
}
function printTernary(path11, options9, print4) {
  const { node } = path11;
  const isConditionalExpression = node.type === "ConditionalExpression";
  const consequentNodePropertyName = isConditionalExpression ? "consequent" : "trueType";
  const alternateNodePropertyName = isConditionalExpression ? "alternate" : "falseType";
  const testNodePropertyNames = isConditionalExpression ? ["test"] : ["checkType", "extendsType"];
  const consequentNode = node[consequentNodePropertyName];
  const alternateNode = node[alternateNodePropertyName];
  const parts = [];
  let jsxMode = false;
  const { parent } = path11;
  const isParentTest = parent.type === node.type && testNodePropertyNames.some((prop) => parent[prop] === node);
  let forceNoIndent = parent.type === node.type && !isParentTest;
  let currentParent;
  let previousParent;
  let i = 0;
  do {
    previousParent = currentParent || node;
    currentParent = path11.getParentNode(i);
    i++;
  } while (currentParent && currentParent.type === node.type && testNodePropertyNames.every(
    (prop) => currentParent[prop] !== previousParent
  ));
  const firstNonConditionalParent = currentParent || parent;
  const lastConditionalParent = previousParent;
  if (isConditionalExpression && (isJsxElement(node[testNodePropertyNames[0]]) || isJsxElement(consequentNode) || isJsxElement(alternateNode) || conditionalExpressionChainContainsJsx(lastConditionalParent))) {
    jsxMode = true;
    forceNoIndent = true;
    const wrap = (doc2) => [
      ifBreak("("),
      indent([softline, doc2]),
      softline,
      ifBreak(")")
    ];
    const isNil = (node2) => node2.type === "NullLiteral" || node2.type === "Literal" && node2.value === null || node2.type === "Identifier" && node2.name === "undefined";
    parts.push(
      " ? ",
      isNil(consequentNode) ? print4(consequentNodePropertyName) : wrap(print4(consequentNodePropertyName)),
      " : ",
      alternateNode.type === node.type || isNil(alternateNode) ? print4(alternateNodePropertyName) : wrap(print4(alternateNodePropertyName))
    );
  } else {
    const part = [
      line,
      "? ",
      consequentNode.type === node.type ? ifBreak("", "(") : "",
      align(2, print4(consequentNodePropertyName)),
      consequentNode.type === node.type ? ifBreak("", ")") : "",
      line,
      ": ",
      alternateNode.type === node.type ? print4(alternateNodePropertyName) : align(2, print4(alternateNodePropertyName))
    ];
    parts.push(
      parent.type !== node.type || parent[alternateNodePropertyName] === node || isParentTest ? part : options9.useTabs ? dedent(indent(part)) : align(Math.max(0, options9.tabWidth - 2), part)
    );
  }
  const shouldBreak = [
    consequentNodePropertyName,
    alternateNodePropertyName,
    ...testNodePropertyNames
  ].some(
    (property) => hasComment(
      node[property],
      (comment) => is_block_comment_default(comment) && has_newline_in_range_default(
        options9.originalText,
        locStart(comment),
        locEnd(comment)
      )
    )
  );
  const maybeGroup = (doc2) => parent === firstNonConditionalParent ? group(doc2, { shouldBreak }) : shouldBreak ? [doc2, breakParent] : doc2;
  const breakClosingParen = !jsxMode && (isMemberExpression(parent) || parent.type === "NGPipeExpression" && parent.left === node) && !parent.computed;
  const shouldExtraIndent = shouldExtraIndentForConditionalExpression(path11);
  const result = maybeGroup([
    printTernaryTest(path11, options9, print4),
    forceNoIndent ? parts : indent(parts),
    isConditionalExpression && breakClosingParen && !shouldExtraIndent ? softline : ""
  ]);
  return isParentTest || shouldExtraIndent ? group([indent([softline, result]), softline]) : result;
}

// src/language-js/print/statement.js
function printStatementSequence(path11, options9, print4, property) {
  const { node } = path11;
  const parts = [];
  const lastStatement = getLastStatement(node[property]);
  path11.each(({ node: node2 }) => {
    if (node2.type === "EmptyStatement") {
      return;
    }
    parts.push(print4());
    if (node2 !== lastStatement) {
      parts.push(hardline);
      if (isNextLineEmpty2(node2, options9)) {
        parts.push(hardline);
      }
    }
  }, property);
  return parts;
}
function getLastStatement(statements) {
  for (let i = statements.length - 1; i >= 0; i--) {
    const statement = statements[i];
    if (statement.type !== "EmptyStatement") {
      return statement;
    }
  }
}

// src/language-js/print/block.js
function printBlock(path11, options9, print4) {
  const {
    node
  } = path11;
  const parts = [];
  if (node.type === "StaticBlock") {
    parts.push("static ");
  }
  parts.push("{");
  const printed = printBlockBody(path11, options9, print4);
  if (printed) {
    parts.push(indent([hardline, printed]), hardline);
  } else {
    const {
      parent
    } = path11;
    const parentParent = path11.grandparent;
    if (!(parent.type === "ArrowFunctionExpression" || parent.type === "FunctionExpression" || parent.type === "FunctionDeclaration" || parent.type === "ObjectMethod" || parent.type === "ClassMethod" || parent.type === "ClassPrivateMethod" || parent.type === "ForStatement" || parent.type === "WhileStatement" || parent.type === "DoWhileStatement" || parent.type === "DoExpression" || parent.type === "CatchClause" && !parentParent.finalizer || parent.type === "TSModuleDeclaration" || parent.type === "TSDeclareFunction" || node.type === "StaticBlock")) {
      parts.push(hardline);
    }
  }
  parts.push("}");
  return parts;
}
function printBlockBody(path11, options9, print4) {
  var _a;
  const {
    node
  } = path11;
  const hasDirectives = is_non_empty_array_default(node.directives);
  const hasBody = node.body.some((node2) => node2.type !== "EmptyStatement");
  const hasDanglingComments = hasComment(node, CommentCheckFlags.Dangling);
  if (!hasDirectives && !hasBody && !hasDanglingComments) {
    return "";
  }
  const parts = [];
  if (hasDirectives) {
    parts.push(printStatementSequence(path11, options9, print4, "directives"));
    if (hasBody || hasDanglingComments) {
      parts.push(hardline);
      if (isNextLineEmpty2(at_default(
        /* isOptionalObject*/
        false,
        node.directives,
        -1
      ), options9)) {
        parts.push(hardline);
      }
    }
  }
  if (hasBody) {
    parts.push(printStatementSequence(path11, options9, print4, "body"));
  }
  if (hasDanglingComments) {
    parts.push(printDanglingComments(path11, options9));
  }
  if (node.type === "Program" && ((_a = path11.parent) == null ? void 0 : _a.type) !== "ModuleExpression") {
    parts.push(hardline);
  }
  return parts;
}

// src/language-js/print/typescript.js
function printTypescript(path11, options9, print4) {
  var _a;
  const { node } = path11;
  if (!node.type.startsWith("TS")) {
    return;
  }
  if (is_ts_keyword_type_default(node)) {
    return node.type.slice(2, -7).toLowerCase();
  }
  const semi = options9.semi ? ";" : "";
  const parts = [];
  switch (node.type) {
    case "TSThisType":
      return "this";
    case "TSTypeAssertion": {
      const shouldBreakAfterCast = !(isArrayOrTupleExpression(node.expression) || isObjectOrRecordExpression(node.expression));
      const castGroup = group([
        "<",
        indent([softline, print4("typeAnnotation")]),
        softline,
        ">"
      ]);
      const exprContents = [
        ifBreak("("),
        indent([softline, print4("expression")]),
        softline,
        ifBreak(")")
      ];
      if (shouldBreakAfterCast) {
        return conditionalGroup([
          [castGroup, print4("expression")],
          [castGroup, group(exprContents, { shouldBreak: true })],
          [castGroup, print4("expression")]
        ]);
      }
      return group([castGroup, print4("expression")]);
    }
    case "TSDeclareFunction":
      return printFunction(path11, print4, options9);
    case "TSExportAssignment":
      return ["export = ", print4("expression"), semi];
    case "TSModuleBlock":
      return printBlock(path11, options9, print4);
    case "TSInterfaceBody":
    case "TSTypeLiteral":
      return printObject(path11, options9, print4);
    case "TSTypeAliasDeclaration":
      return printTypeAlias(path11, options9, print4);
    case "TSQualifiedName":
      return join(".", [print4("left"), print4("right")]);
    case "TSAbstractMethodDefinition":
    case "TSDeclareMethod":
      return printClassMethod(path11, options9, print4);
    case "TSAbstractAccessorProperty":
    case "TSAbstractPropertyDefinition":
      return printClassProperty(path11, options9, print4);
    case "TSInterfaceHeritage":
    case "TSClassImplements":
    case "TSExpressionWithTypeArguments":
    case "TSInstantiationExpression":
      return [print4("expression"), print4("typeParameters")];
    case "TSTemplateLiteralType":
      return printTemplateLiteral(path11, print4, options9);
    case "TSNamedTupleMember":
      return printNamedTupleMember(path11, options9, print4);
    case "TSRestType":
      return printRestType(path11, options9, print4);
    case "TSOptionalType":
      return [print4("typeAnnotation"), "?"];
    case "TSInterfaceDeclaration":
      return printInterface(path11, options9, print4);
    case "TSTypeParameterDeclaration":
    case "TSTypeParameterInstantiation":
      return printTypeParameters(path11, options9, print4, "params");
    case "TSTypeParameter":
      return printTypeParameter(path11, options9, print4);
    case "TSAsExpression":
    case "TSSatisfiesExpression": {
      const operator = node.type === "TSAsExpression" ? "as" : "satisfies";
      parts.push(print4("expression"), ` ${operator} `, print4("typeAnnotation"));
      const { parent } = path11;
      if (isCallExpression(parent) && parent.callee === node || isMemberExpression(parent) && parent.object === node) {
        return group([indent([softline, ...parts]), softline]);
      }
      return parts;
    }
    case "TSArrayType":
      return [print4("elementType"), "[]"];
    case "TSPropertySignature":
      return [
        node.readonly ? "readonly " : "",
        printPropertyKey(path11, options9, print4),
        printOptionalToken(path11),
        printTypeAnnotationProperty(path11, print4)
      ];
    case "TSParameterProperty":
      return [
        printTypeScriptAccessibilityToken(node),
        node.static ? "static " : "",
        node.override ? "override " : "",
        node.readonly ? "readonly " : "",
        print4("parameter")
      ];
    case "TSTypeQuery":
      return ["typeof ", print4("exprName"), print4("typeParameters")];
    case "TSIndexSignature": {
      const trailingComma = node.parameters.length > 1 ? ifBreak(shouldPrintComma(options9) ? "," : "") : "";
      const parametersGroup = group([
        indent([
          softline,
          join([", ", softline], path11.map(print4, "parameters"))
        ]),
        trailingComma,
        softline
      ]);
      const isClassMember = path11.parent.type === "ClassBody" && path11.key === "body";
      return [
        // `static` only allowed in class member
        isClassMember && node.static ? "static " : "",
        node.readonly ? "readonly " : "",
        "[",
        node.parameters ? parametersGroup : "",
        "]",
        printTypeAnnotationProperty(path11, print4),
        isClassMember ? semi : ""
      ];
    }
    case "TSTypePredicate":
      return [
        node.asserts ? "asserts " : "",
        print4("parameterName"),
        node.typeAnnotation ? [" is ", printTypeAnnotationProperty(path11, print4)] : ""
      ];
    case "TSNonNullExpression":
      return [print4("expression"), "!"];
    case "TSImportType":
      return [
        !node.isTypeOf ? "" : "typeof ",
        "import(",
        print4(node.parameter ? "parameter" : "argument"),
        ")",
        !node.qualifier ? "" : [".", print4("qualifier")],
        printTypeParameters(path11, options9, print4, "typeParameters")
      ];
    case "TSLiteralType":
      return print4("literal");
    case "TSIndexedAccessType":
      return printIndexedAccessType(path11, options9, print4);
    case "TSTypeOperator":
      return [node.operator, " ", print4("typeAnnotation")];
    case "TSMappedType": {
      const shouldBreak = has_newline_in_range_default(
        options9.originalText,
        locStart(node),
        locEnd(node)
      );
      return group(
        [
          "{",
          indent([
            options9.bracketSpacing ? line : softline,
            print4("typeParameter"),
            node.optional ? getTypeScriptMappedTypeModifier(node.optional, "?") : "",
            node.typeAnnotation ? ": " : "",
            print4("typeAnnotation"),
            ifBreak(semi)
          ]),
          printDanglingComments(path11, options9),
          options9.bracketSpacing ? line : softline,
          "}"
        ],
        { shouldBreak }
      );
    }
    case "TSMethodSignature": {
      const kind = node.kind && node.kind !== "method" ? `${node.kind} ` : "";
      parts.push(
        printTypeScriptAccessibilityToken(node),
        kind,
        node.computed ? "[" : "",
        print4("key"),
        node.computed ? "]" : "",
        printOptionalToken(path11)
      );
      const parametersDoc = printFunctionParameters(
        path11,
        print4,
        options9,
        /* expandArg */
        false,
        /* printTypeParams */
        true
      );
      const returnTypePropertyName = node.returnType ? "returnType" : "typeAnnotation";
      const returnTypeNode = node[returnTypePropertyName];
      const returnTypeDoc = returnTypeNode ? printTypeAnnotationProperty(path11, print4, returnTypePropertyName) : "";
      const shouldGroupParameters = shouldGroupFunctionParameters(
        node,
        returnTypeDoc
      );
      parts.push(shouldGroupParameters ? group(parametersDoc) : parametersDoc);
      if (returnTypeNode) {
        parts.push(group(returnTypeDoc));
      }
      return group(parts);
    }
    case "TSNamespaceExportDeclaration":
      parts.push("export as namespace ", print4("id"));
      if (options9.semi) {
        parts.push(";");
      }
      return group(parts);
    case "TSEnumDeclaration":
      return printEnumDeclaration(path11, print4, options9);
    case "TSEnumMember":
      return printEnumMember(path11, print4);
    case "TSImportEqualsDeclaration":
      if (node.isExport) {
        parts.push("export ");
      }
      parts.push("import ");
      if (node.importKind && node.importKind !== "value") {
        parts.push(node.importKind, " ");
      }
      parts.push(print4("id"), " = ", print4("moduleReference"));
      if (options9.semi) {
        parts.push(";");
      }
      return group(parts);
    case "TSExternalModuleReference":
      return ["require(", print4("expression"), ")"];
    case "TSModuleDeclaration": {
      const { parent } = path11;
      const parentIsDeclaration = parent.type === "TSModuleDeclaration";
      const bodyIsDeclaration = ((_a = node.body) == null ? void 0 : _a.type) === "TSModuleDeclaration";
      if (parentIsDeclaration) {
        parts.push(".");
      } else {
        parts.push(printDeclareToken(path11));
        const isGlobal = node.kind === "global" || // TODO: Use `node.kind` when babel update AST
        // https://github.com/typescript-eslint/typescript-eslint/pull/6443
        node.global;
        if (!isGlobal) {
          const kind = node.kind ?? // TODO: Use `node.kind` when babel update AST
          (isStringLiteral(node.id) || /(?:^|\s)module(?:\s|$)/.test(
            options9.originalText.slice(locStart(node), locStart(node.id))
          ) ? "module" : "namespace");
          parts.push(kind, " ");
        }
      }
      parts.push(print4("id"));
      if (bodyIsDeclaration) {
        parts.push(print4("body"));
      } else if (node.body) {
        parts.push(" ", group(print4("body")));
      } else {
        parts.push(semi);
      }
      return parts;
    }
    case "TSConditionalType":
      return printTernary(path11, options9, print4);
    case "TSInferType":
      return ["infer", " ", print4("typeParameter")];
    case "TSIntersectionType":
      return printIntersectionType(path11, options9, print4);
    case "TSUnionType":
      return printUnionType(path11, options9, print4);
    case "TSFunctionType":
    case "TSCallSignatureDeclaration":
    case "TSConstructorType":
    case "TSConstructSignatureDeclaration":
      return printFunctionType(path11, options9, print4);
    case "TSTupleType":
      return printArray(path11, options9, print4);
    case "TSTypeReference":
      return [
        print4("typeName"),
        printTypeParameters(path11, options9, print4, "typeParameters")
      ];
    case "TSTypeAnnotation":
      return printTypeAnnotation(path11, options9, print4);
    case "TSEmptyBodyFunctionExpression":
      return printMethodValue(path11, options9, print4);
    case "TSJSDocAllType":
      return "*";
    case "TSJSDocUnknownType":
      return "?";
    case "TSJSDocNullableType":
      return printJSDocType(
        path11,
        print4,
        /* token */
        "?"
      );
    case "TSJSDocNonNullableType":
      return printJSDocType(
        path11,
        print4,
        /* token */
        "!"
      );
    default:
      throw new unexpected_node_error_default(node, "TypeScript");
  }
}

// src/language-js/print/semicolon.js
function shouldPrintLeadingSemicolon(path11, options9) {
  if (options9.semi || isTheOnlyJsxElementInMarkdown(options9, path11)) {
    return false;
  }
  const { node, key, parent } = path11;
  if (node.type === "ExpressionStatement" && // `Program.directives` don't need leading semicolon
  (key === "body" && (parent.type === "Program" || parent.type === "BlockStatement" || parent.type === "StaticBlock" || parent.type === "TSModuleBlock") || key === "consequent" && parent.type === "SwitchCase") && path11.call(() => expressionNeedsASIProtection(path11, options9), "expression")) {
    return true;
  }
  return false;
}
function expressionNeedsASIProtection(path11, options9) {
  const { node } = path11;
  switch (node.type) {
    case "ParenthesizedExpression":
    case "TypeCastExpression":
    case "ArrayExpression":
    case "ArrayPattern":
    case "TemplateLiteral":
    case "TemplateElement":
    case "RegExpLiteral":
      return true;
    case "ArrowFunctionExpression":
      if (!shouldPrintParamsWithoutParens(path11, options9)) {
        return true;
      }
      break;
    case "UnaryExpression": {
      const { prefix, operator } = node;
      if (prefix && (operator === "+" || operator === "-")) {
        return true;
      }
      break;
    }
    case "BindExpression":
      if (!node.object) {
        return true;
      }
      break;
    case "Literal":
      if (node.regex) {
        return true;
      }
      break;
    default:
      if (isJsxElement(node)) {
        return true;
      }
  }
  if (needs_parens_default(path11, options9)) {
    return true;
  }
  if (!hasNakedLeftSide(node)) {
    return false;
  }
  return path11.call(
    () => expressionNeedsASIProtection(path11, options9),
    ...getLeftSidePathName(node)
  );
}

// src/language-js/printer-estree.js
function genericPrint(path11, options9, print4, args) {
  const { node } = path11;
  const printed = printPathNoParens(path11, options9, print4, args);
  if (!printed) {
    return "";
  }
  const { type } = node;
  if (type === "ClassMethod" || type === "ClassPrivateMethod" || type === "ClassProperty" || type === "ClassAccessorProperty" || type === "AccessorProperty" || type === "TSAbstractAccessorProperty" || type === "PropertyDefinition" || type === "TSAbstractPropertyDefinition" || type === "ClassPrivateProperty" || type === "MethodDefinition" || type === "TSAbstractMethodDefinition" || type === "TSDeclareMethod") {
    return printed;
  }
  let parts = [printed];
  const printedDecorators = printDecorators(path11, options9, print4);
  const isClassExpressionWithDecorators = node.type === "ClassExpression" && printedDecorators;
  if (printedDecorators) {
    parts = [...printedDecorators, printed];
    if (!isClassExpressionWithDecorators) {
      return group(parts);
    }
  }
  const needsParens2 = needs_parens_default(path11, options9);
  const needsSemi = shouldPrintLeadingSemicolon(path11, options9);
  if (!needsParens2) {
    if (needsSemi) {
      parts.unshift(";");
    }
    if (parts.length === 1 && parts[0] === printed) {
      return printed;
    }
    return parts;
  }
  if (isClassExpressionWithDecorators) {
    parts = [indent([line, ...parts])];
  }
  parts.unshift("(");
  if (needsSemi) {
    parts.unshift(";");
  }
  if (isClassExpressionWithDecorators) {
    parts.push(line);
  }
  parts.push(")");
  return parts;
}
function printPathNoParens(path11, options9, print4, args) {
  for (const printer10 of [
    printLiteral,
    printHtmlBinding,
    printAngular,
    printJsx,
    printFlow,
    printTypescript
  ]) {
    const printed = printer10(path11, options9, print4);
    if (printed !== void 0) {
      return printed;
    }
  }
  const { node } = path11;
  const semi = options9.semi ? ";" : "";
  let parts = [];
  switch (node.type) {
    case "JsExpressionRoot":
      return print4("node");
    case "JsonRoot":
      return [print4("node"), hardline];
    case "File":
      return print4("program");
    case "Program":
      return printBlockBody(path11, options9, print4);
    case "EmptyStatement":
      return "";
    case "ExpressionStatement": {
      if (options9.parser === "__vue_event_binding" || options9.parser === "__vue_ts_event_binding") {
        const { parent } = path11;
        if (parent.type === "Program" && parent.body.length === 1 && parent.body[0] === node) {
          return [
            print4("expression"),
            isVueEventBindingExpression(node.expression) ? ";" : ""
          ];
        }
      }
      const danglingComment = printDanglingComments(path11, options9, {
        marker: markerForIfWithoutBlockAndSameLineComment
      });
      return [
        print4("expression"),
        isTheOnlyJsxElementInMarkdown(options9, path11) ? "" : semi,
        danglingComment ? [" ", danglingComment] : ""
      ];
    }
    case "ChainExpression":
      return print4("expression");
    case "ParenthesizedExpression": {
      const shouldHug = !hasComment(node.expression) && (isObjectOrRecordExpression(node.expression) || isArrayOrTupleExpression(node.expression));
      if (shouldHug) {
        return ["(", print4("expression"), ")"];
      }
      return group([
        "(",
        indent([softline, print4("expression")]),
        softline,
        ")"
      ]);
    }
    case "AssignmentExpression":
      return printAssignmentExpression(path11, options9, print4);
    case "VariableDeclarator":
      return printVariableDeclarator(path11, options9, print4);
    case "BinaryExpression":
    case "LogicalExpression":
      return printBinaryishExpression(path11, options9, print4);
    case "AssignmentPattern":
      return [print4("left"), " = ", print4("right")];
    case "OptionalMemberExpression":
    case "MemberExpression":
      return printMemberExpression(path11, options9, print4);
    case "MetaProperty":
      return [print4("meta"), ".", print4("property")];
    case "BindExpression":
      if (node.object) {
        parts.push(print4("object"));
      }
      parts.push(
        group(
          indent([softline, printBindExpressionCallee(path11, options9, print4)])
        )
      );
      return parts;
    case "Identifier":
      return [
        node.name,
        printOptionalToken(path11),
        printDefiniteToken(path11),
        printTypeAnnotationProperty(path11, print4)
      ];
    case "V8IntrinsicIdentifier":
      return ["%", node.name];
    case "SpreadElement":
    case "SpreadElementPattern":
    case "SpreadPropertyPattern":
    case "RestElement":
      return printRestSpread(path11, print4);
    case "FunctionDeclaration":
    case "FunctionExpression":
      return printFunction(path11, print4, options9, args);
    case "ArrowFunctionExpression":
      return printArrowFunction(path11, options9, print4, args);
    case "YieldExpression":
      parts.push("yield");
      if (node.delegate) {
        parts.push("*");
      }
      if (node.argument) {
        parts.push(" ", print4("argument"));
      }
      return parts;
    case "AwaitExpression":
      parts.push("await");
      if (node.argument) {
        parts.push(" ", print4("argument"));
        const { parent } = path11;
        if (isCallExpression(parent) && parent.callee === node || isMemberExpression(parent) && parent.object === node) {
          parts = [indent([softline, ...parts]), softline];
          const parentAwaitOrBlock = path11.findAncestor(
            (node2) => node2.type === "AwaitExpression" || node2.type === "BlockStatement"
          );
          if ((parentAwaitOrBlock == null ? void 0 : parentAwaitOrBlock.type) !== "AwaitExpression" || !startsWithNoLookaheadToken(
            parentAwaitOrBlock.argument,
            (leftmostNode) => leftmostNode === node
          )) {
            return group(parts);
          }
        }
      }
      return parts;
    case "ExportDefaultDeclaration":
    case "ExportNamedDeclaration":
      return printExportDeclaration(path11, options9, print4);
    case "ExportAllDeclaration":
      return printExportAllDeclaration(path11, options9, print4);
    case "ImportDeclaration":
      return printImportDeclaration(path11, options9, print4);
    case "ImportSpecifier":
    case "ExportSpecifier":
    case "ImportNamespaceSpecifier":
    case "ExportNamespaceSpecifier":
    case "ImportDefaultSpecifier":
    case "ExportDefaultSpecifier":
      return printModuleSpecifier(path11, options9, print4);
    case "ImportAttribute":
      return [print4("key"), ": ", print4("value")];
    case "Import":
      return "import";
    case "BlockStatement":
    case "StaticBlock":
      return printBlock(path11, options9, print4);
    case "ClassBody":
      return printClassBody(path11, options9, print4);
    case "ThrowStatement":
      return printThrowStatement(path11, options9, print4);
    case "ReturnStatement":
      return printReturnStatement(path11, options9, print4);
    case "NewExpression":
    case "ImportExpression":
    case "OptionalCallExpression":
    case "CallExpression":
      return printCallExpression(path11, options9, print4);
    case "ObjectExpression":
    case "ObjectPattern":
    case "RecordExpression":
      return printObject(path11, options9, print4);
    case "ObjectProperty":
    case "Property":
      if (node.method || node.kind === "get" || node.kind === "set") {
        return printMethod(path11, options9, print4);
      }
      return printProperty(path11, options9, print4);
    case "ObjectMethod":
      return printMethod(path11, options9, print4);
    case "Decorator":
      return ["@", print4("expression")];
    case "ArrayExpression":
    case "ArrayPattern":
    case "TupleExpression":
      return printArray(path11, options9, print4);
    case "SequenceExpression": {
      const { parent } = path11;
      if (parent.type === "ExpressionStatement" || parent.type === "ForStatement") {
        const parts2 = [];
        path11.each(({ isFirst }) => {
          if (isFirst) {
            parts2.push(print4());
          } else {
            parts2.push(",", indent([line, print4()]));
          }
        }, "expressions");
        return group(parts2);
      }
      return group(join([",", line], path11.map(print4, "expressions")));
    }
    case "ThisExpression":
      return "this";
    case "Super":
      return "super";
    case "Directive":
      return [print4("value"), semi];
    case "UnaryExpression":
      parts.push(node.operator);
      if (/[a-z]$/.test(node.operator)) {
        parts.push(" ");
      }
      if (hasComment(node.argument)) {
        parts.push(
          group(["(", indent([softline, print4("argument")]), softline, ")"])
        );
      } else {
        parts.push(print4("argument"));
      }
      return parts;
    case "UpdateExpression":
      parts.push(print4("argument"), node.operator);
      if (node.prefix) {
        parts.reverse();
      }
      return parts;
    case "ConditionalExpression":
      return printTernary(path11, options9, print4);
    case "VariableDeclaration": {
      const printed = path11.map(print4, "declarations");
      const parentNode = path11.parent;
      const isParentForLoop = parentNode.type === "ForStatement" || parentNode.type === "ForInStatement" || parentNode.type === "ForOfStatement";
      const hasValue = node.declarations.some((decl) => decl.init);
      let firstVariable;
      if (printed.length === 1 && !hasComment(node.declarations[0])) {
        firstVariable = printed[0];
      } else if (printed.length > 0) {
        firstVariable = indent(printed[0]);
      }
      parts = [
        printDeclareToken(path11),
        node.kind,
        firstVariable ? [" ", firstVariable] : "",
        indent(
          printed.slice(1).map((p) => [
            ",",
            hasValue && !isParentForLoop ? hardline : line,
            p
          ])
        )
      ];
      if (!(isParentForLoop && parentNode.body !== node)) {
        parts.push(semi);
      }
      return group(parts);
    }
    case "WithStatement":
      return group([
        "with (",
        print4("object"),
        ")",
        adjustClause(node.body, print4("body"))
      ]);
    case "IfStatement": {
      const con = adjustClause(node.consequent, print4("consequent"));
      const opening = group([
        "if (",
        group([indent([softline, print4("test")]), softline]),
        ")",
        con
      ]);
      parts.push(opening);
      if (node.alternate) {
        const commentOnOwnLine = hasComment(
          node.consequent,
          CommentCheckFlags.Trailing | CommentCheckFlags.Line
        ) || needsHardlineAfterDanglingComment(node);
        const elseOnSameLine = node.consequent.type === "BlockStatement" && !commentOnOwnLine;
        parts.push(elseOnSameLine ? " " : hardline);
        if (hasComment(node, CommentCheckFlags.Dangling)) {
          parts.push(
            printDanglingComments(path11, options9),
            commentOnOwnLine ? hardline : " "
          );
        }
        parts.push(
          "else",
          group(
            adjustClause(
              node.alternate,
              print4("alternate"),
              node.alternate.type === "IfStatement"
            )
          )
        );
      }
      return parts;
    }
    case "ForStatement": {
      const body = adjustClause(node.body, print4("body"));
      const dangling = printDanglingComments(path11, options9);
      const printedComments = dangling ? [dangling, softline] : "";
      if (!node.init && !node.test && !node.update) {
        return [printedComments, group(["for (;;)", body])];
      }
      return [
        printedComments,
        group([
          "for (",
          group([
            indent([
              softline,
              print4("init"),
              ";",
              line,
              print4("test"),
              ";",
              line,
              print4("update")
            ]),
            softline
          ]),
          ")",
          body
        ])
      ];
    }
    case "WhileStatement":
      return group([
        "while (",
        group([indent([softline, print4("test")]), softline]),
        ")",
        adjustClause(node.body, print4("body"))
      ]);
    case "ForInStatement":
      return group([
        "for (",
        print4("left"),
        " in ",
        print4("right"),
        ")",
        adjustClause(node.body, print4("body"))
      ]);
    case "ForOfStatement":
      return group([
        "for",
        node.await ? " await" : "",
        " (",
        print4("left"),
        " of ",
        print4("right"),
        ")",
        adjustClause(node.body, print4("body"))
      ]);
    case "DoWhileStatement": {
      const clause = adjustClause(node.body, print4("body"));
      const doBody = group(["do", clause]);
      parts = [doBody];
      if (node.body.type === "BlockStatement") {
        parts.push(" ");
      } else {
        parts.push(hardline);
      }
      parts.push(
        "while (",
        group([indent([softline, print4("test")]), softline]),
        ")",
        semi
      );
      return parts;
    }
    case "DoExpression":
      return [node.async ? "async " : "", "do ", print4("body")];
    case "BreakStatement":
    case "ContinueStatement":
      parts.push(node.type === "BreakStatement" ? "break" : "continue");
      if (node.label) {
        parts.push(" ", print4("label"));
      }
      parts.push(semi);
      return parts;
    case "LabeledStatement":
      if (node.body.type === "EmptyStatement") {
        return [print4("label"), ":;"];
      }
      return [print4("label"), ": ", print4("body")];
    case "TryStatement":
      return [
        "try ",
        print4("block"),
        node.handler ? [" ", print4("handler")] : "",
        node.finalizer ? [" finally ", print4("finalizer")] : ""
      ];
    case "CatchClause":
      if (node.param) {
        const parameterHasComments = hasComment(
          node.param,
          (comment) => !is_block_comment_default(comment) || comment.leading && has_newline_default(options9.originalText, locEnd(comment)) || comment.trailing && has_newline_default(options9.originalText, locStart(comment), {
            backwards: true
          })
        );
        const param = print4("param");
        return [
          "catch ",
          parameterHasComments ? ["(", indent([softline, param]), softline, ") "] : ["(", param, ") "],
          print4("body")
        ];
      }
      return ["catch ", print4("body")];
    case "SwitchStatement":
      return [
        group([
          "switch (",
          indent([softline, print4("discriminant")]),
          softline,
          ")"
        ]),
        " {",
        node.cases.length > 0 ? indent([
          hardline,
          join(
            hardline,
            path11.map(
              ({ node: node2, isLast }) => [
                print4(),
                !isLast && isNextLineEmpty2(node2, options9) ? hardline : ""
              ],
              "cases"
            )
          )
        ]) : "",
        hardline,
        "}"
      ];
    case "SwitchCase": {
      if (node.test) {
        parts.push("case ", print4("test"), ":");
      } else {
        parts.push("default:");
      }
      if (hasComment(node, CommentCheckFlags.Dangling)) {
        parts.push(" ", printDanglingComments(path11, options9));
      }
      const consequent = node.consequent.filter(
        (node2) => node2.type !== "EmptyStatement"
      );
      if (consequent.length > 0) {
        const cons = printStatementSequence(path11, options9, print4, "consequent");
        parts.push(
          consequent.length === 1 && consequent[0].type === "BlockStatement" ? [" ", cons] : indent([hardline, cons])
        );
      }
      return parts;
    }
    case "DebuggerStatement":
      return ["debugger", semi];
    case "ClassDeclaration":
    case "ClassExpression":
      return printClass(path11, options9, print4);
    case "ClassMethod":
    case "ClassPrivateMethod":
    case "MethodDefinition":
      return printClassMethod(path11, options9, print4);
    case "ClassProperty":
    case "PropertyDefinition":
    case "ClassPrivateProperty":
    case "ClassAccessorProperty":
    case "AccessorProperty":
      return printClassProperty(path11, options9, print4);
    case "TemplateElement":
      return replaceEndOfLine(node.value.raw);
    case "TemplateLiteral":
      return printTemplateLiteral(path11, print4, options9);
    case "TaggedTemplateExpression":
      return printTaggedTemplateLiteral(print4);
    case "PrivateIdentifier":
      return ["#", node.name];
    case "PrivateName":
      return ["#", print4("id")];
    case "TopicReference":
      return "%";
    case "ArgumentPlaceholder":
      return "?";
    case "ModuleExpression": {
      parts.push("module {");
      const printed = print4("body");
      if (printed) {
        parts.push(indent([hardline, printed]), hardline);
      }
      parts.push("}");
      return parts;
    }
    case "InterpreterDirective":
    default:
      throw new unexpected_node_error_default(node, "ESTree");
  }
}
var printer2 = {
  print: genericPrint,
  embed: embed_default,
  insertPragma,
  massageAstNode: clean_default,
  getVisitorKeys: get_visitor_keys_default,
  ...printer_methods_exports
};
var printer_estree_default = printer2;

// src/language-js/languages.evaluate.js
var languages_evaluate_default = [
  {
    "linguistLanguageId": 183,
    "name": "JavaScript",
    "type": "programming",
    "tmScope": "source.js",
    "aceMode": "javascript",
    "codemirrorMode": "javascript",
    "codemirrorMimeType": "text/javascript",
    "color": "#f1e05a",
    "aliases": [
      "js",
      "node"
    ],
    "extensions": [
      ".js",
      "._js",
      ".bones",
      ".cjs",
      ".es",
      ".es6",
      ".frag",
      ".gs",
      ".jake",
      ".javascript",
      ".jsb",
      ".jscad",
      ".jsfl",
      ".jslib",
      ".jsm",
      ".jspre",
      ".jss",
      ".mjs",
      ".njs",
      ".pac",
      ".sjs",
      ".ssjs",
      ".xsjs",
      ".xsjslib",
      ".wxs"
    ],
    "filenames": [
      "Jakefile"
    ],
    "interpreters": [
      "chakra",
      "d8",
      "gjs",
      "js",
      "node",
      "nodejs",
      "qjs",
      "rhino",
      "v8",
      "v8-shell",
      "zx"
    ],
    "parsers": [
      "babel",
      "acorn",
      "espree",
      "meriyah",
      "babel-flow",
      "babel-ts",
      "flow",
      "typescript"
    ],
    "vscodeLanguageIds": [
      "javascript",
      "mongo"
    ]
  },
  {
    "linguistLanguageId": 183,
    "name": "Flow",
    "type": "programming",
    "tmScope": "source.js",
    "aceMode": "javascript",
    "codemirrorMode": "javascript",
    "codemirrorMimeType": "text/javascript",
    "color": "#f1e05a",
    "aliases": [],
    "extensions": [
      ".js.flow"
    ],
    "filenames": [],
    "interpreters": [
      "chakra",
      "d8",
      "gjs",
      "js",
      "node",
      "nodejs",
      "qjs",
      "rhino",
      "v8",
      "v8-shell"
    ],
    "parsers": [
      "flow",
      "babel-flow"
    ],
    "vscodeLanguageIds": [
      "javascript"
    ]
  },
  {
    "linguistLanguageId": 183,
    "name": "JSX",
    "type": "programming",
    "tmScope": "source.js.jsx",
    "aceMode": "javascript",
    "codemirrorMode": "jsx",
    "codemirrorMimeType": "text/jsx",
    "color": void 0,
    "aliases": void 0,
    "extensions": [
      ".jsx"
    ],
    "filenames": void 0,
    "interpreters": void 0,
    "parsers": [
      "babel",
      "babel-flow",
      "babel-ts",
      "flow",
      "typescript",
      "espree",
      "meriyah"
    ],
    "vscodeLanguageIds": [
      "javascriptreact"
    ],
    "group": "JavaScript"
  },
  {
    "linguistLanguageId": 378,
    "name": "TypeScript",
    "type": "programming",
    "color": "#3178c6",
    "aliases": [
      "ts"
    ],
    "interpreters": [
      "deno",
      "ts-node"
    ],
    "extensions": [
      ".ts",
      ".cts",
      ".mts"
    ],
    "tmScope": "source.ts",
    "aceMode": "typescript",
    "codemirrorMode": "javascript",
    "codemirrorMimeType": "application/typescript",
    "parsers": [
      "typescript",
      "babel-ts"
    ],
    "vscodeLanguageIds": [
      "typescript"
    ]
  },
  {
    "linguistLanguageId": 94901924,
    "name": "TSX",
    "type": "programming",
    "color": "#3178c6",
    "group": "TypeScript",
    "extensions": [
      ".tsx"
    ],
    "tmScope": "source.tsx",
    "aceMode": "javascript",
    "codemirrorMode": "jsx",
    "codemirrorMimeType": "text/jsx",
    "parsers": [
      "typescript",
      "babel-ts"
    ],
    "vscodeLanguageIds": [
      "typescriptreact"
    ]
  }
];

// src/common/common-options.js
var CATEGORY_COMMON = "Common";
var options2 = {
  bracketSpacing: {
    category: CATEGORY_COMMON,
    type: "boolean",
    default: true,
    description: "Print spaces between brackets.",
    oppositeDescription: "Do not print spaces between brackets."
  },
  singleQuote: {
    category: CATEGORY_COMMON,
    type: "boolean",
    default: false,
    description: "Use single quotes instead of double quotes."
  },
  proseWrap: {
    category: CATEGORY_COMMON,
    type: "choice",
    default: "preserve",
    description: "How to wrap prose.",
    choices: [
      {
        value: "always",
        description: "Wrap prose if it exceeds the print width."
      },
      {
        value: "never",
        description: "Do not wrap prose."
      },
      {
        value: "preserve",
        description: "Wrap prose as-is."
      }
    ]
  },
  bracketSameLine: {
    category: CATEGORY_COMMON,
    type: "boolean",
    default: false,
    description: "Put > of opening tags on the last line instead of on a new line."
  },
  singleAttributePerLine: {
    category: CATEGORY_COMMON,
    type: "boolean",
    default: false,
    description: "Enforce single attribute per line in HTML, Vue and JSX."
  }
};
var common_options_default = options2;

// src/language-js/options.js
var CATEGORY_JAVASCRIPT = "JavaScript";
var options3 = {
  arrowParens: {
    category: CATEGORY_JAVASCRIPT,
    type: "choice",
    default: "always",
    description: "Include parentheses around a sole arrow function parameter.",
    choices: [
      {
        value: "always",
        description: "Always include parens. Example: `(x) => x`"
      },
      {
        value: "avoid",
        description: "Omit parens when possible. Example: `x => x`"
      }
    ]
  },
  bracketSameLine: common_options_default.bracketSameLine,
  bracketSpacing: common_options_default.bracketSpacing,
  jsxBracketSameLine: {
    category: CATEGORY_JAVASCRIPT,
    type: "boolean",
    description: "Put > on the last line instead of at a new line.",
    deprecated: "2.4.0"
  },
  semi: {
    category: CATEGORY_JAVASCRIPT,
    type: "boolean",
    default: true,
    description: "Print semicolons.",
    oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them."
  },
  singleQuote: common_options_default.singleQuote,
  jsxSingleQuote: {
    category: CATEGORY_JAVASCRIPT,
    type: "boolean",
    default: false,
    description: "Use single quotes in JSX."
  },
  quoteProps: {
    category: CATEGORY_JAVASCRIPT,
    type: "choice",
    default: "as-needed",
    description: "Change when properties in objects are quoted.",
    choices: [
      {
        value: "as-needed",
        description: "Only add quotes around object properties where required."
      },
      {
        value: "consistent",
        description: "If at least one property in an object requires quotes, quote all properties."
      },
      {
        value: "preserve",
        description: "Respect the input use of quotes in object properties."
      }
    ]
  },
  trailingComma: {
    category: CATEGORY_JAVASCRIPT,
    type: "choice",
    default: "all",
    description: "Print trailing commas wherever possible when multi-line.",
    choices: [
      {
        value: "all",
        description: "Trailing commas wherever possible (including function arguments)."
      },
      {
        value: "es5",
        description: "Trailing commas where valid in ES5 (objects, arrays, etc.)"
      },
      { value: "none", description: "No trailing commas." }
    ]
  },
  singleAttributePerLine: common_options_default.singleAttributePerLine
};
var options_default = options3;

// src/language-js/index.js
var printers = {
  estree: printer_estree_default
};
var parsers2 = create_parsers_default(parsers_default);

// src/language-css/index.js
var language_css_exports = {};
__export(language_css_exports, {
  languages: () => languages_evaluate_default2,
  options: () => options_default2,
  parsers: () => parsers4,
  printers: () => printers2
});

// src/language-css/parsers.js
var parsers3 = [
  {
    importPlugin: () => import("./plugins/postcss.mjs"),
    parserNames: ["css", "less", "scss"]
  }
];
var parsers_default2 = parsers3;

// src/utils/front-matter/is-front-matter.js
function isFrontMatter(node) {
  return (node == null ? void 0 : node.type) === "front-matter";
}
var is_front_matter_default = isFrontMatter;

// src/language-css/clean.js
var ignoredProperties2 = /* @__PURE__ */ new Set([
  "raw",
  // front-matter
  "raws",
  "sourceIndex",
  "source",
  "before",
  "after",
  "trailingComma",
  "spaces"
]);
function clean2(ast, newObj, parent) {
  if (is_front_matter_default(ast) && ast.lang === "yaml") {
    delete newObj.value;
  }
  if (ast.type === "css-comment" && parent.type === "css-root" && parent.nodes.length > 0) {
    if (parent.nodes[0] === ast || is_front_matter_default(parent.nodes[0]) && parent.nodes[1] === ast) {
      delete newObj.text;
      if (/^\*\s*@(?:format|prettier)\s*$/.test(ast.text)) {
        return null;
      }
    }
    if (parent.type === "css-root" && at_default(
      /* isOptionalObject*/
      false,
      parent.nodes,
      -1
    ) === ast) {
      return null;
    }
  }
  if (ast.type === "value-root") {
    delete newObj.text;
  }
  if (ast.type === "media-query" || ast.type === "media-query-list" || ast.type === "media-feature-expression") {
    delete newObj.value;
  }
  if (ast.type === "css-rule") {
    delete newObj.params;
  }
  if (ast.type === "selector-combinator") {
    newObj.value = string_replace_all_default(
      /* isOptionalObject*/
      false,
      newObj.value,
      /\s+/g,
      " "
    );
  }
  if (ast.type === "media-feature") {
    newObj.value = string_replace_all_default(
      /* isOptionalObject*/
      false,
      newObj.value,
      " ",
      ""
    );
  }
  if (ast.type === "value-word" && (ast.isColor && ast.isHex || ["initial", "inherit", "unset", "revert"].includes(newObj.value.toLowerCase())) || ast.type === "media-feature" || ast.type === "selector-root-invalid" || ast.type === "selector-pseudo") {
    newObj.value = newObj.value.toLowerCase();
  }
  if (ast.type === "css-decl") {
    newObj.prop = newObj.prop.toLowerCase();
  }
  if (ast.type === "css-atrule" || ast.type === "css-import") {
    newObj.name = newObj.name.toLowerCase();
  }
  if (ast.type === "value-number") {
    newObj.unit = newObj.unit.toLowerCase();
  }
  if (ast.type === "value-unknown") {
    newObj.value = string_replace_all_default(
      /* isOptionalObject*/
      false,
      newObj.value,
      /;$/g,
      ""
    );
  }
  if ((ast.type === "media-feature" || ast.type === "media-keyword" || ast.type === "media-type" || ast.type === "media-unknown" || ast.type === "media-url" || ast.type === "media-value" || ast.type === "selector-attribute" || ast.type === "selector-string" || ast.type === "selector-class" || ast.type === "selector-combinator" || ast.type === "value-string") && newObj.value) {
    newObj.value = cleanCSSStrings(newObj.value);
  }
  if (ast.type === "selector-attribute") {
    newObj.attribute = newObj.attribute.trim();
    if (newObj.namespace && typeof newObj.namespace === "string") {
      newObj.namespace = newObj.namespace.trim();
      if (newObj.namespace.length === 0) {
        newObj.namespace = true;
      }
    }
    if (newObj.value) {
      newObj.value = string_replace_all_default(
        /* isOptionalObject*/
        false,
        newObj.value.trim(),
        /^["']|["']$/g,
        ""
      );
      delete newObj.quoted;
    }
  }
  if ((ast.type === "media-value" || ast.type === "media-type" || ast.type === "value-number" || ast.type === "selector-root-invalid" || ast.type === "selector-class" || ast.type === "selector-combinator" || ast.type === "selector-tag") && newObj.value) {
    newObj.value = string_replace_all_default(
      /* isOptionalObject*/
      false,
      newObj.value,
      /([\d+.Ee-]+)([A-Za-z]*)/g,
      (match, numStr, unit) => {
        const num = Number(numStr);
        return Number.isNaN(num) ? match : num + unit.toLowerCase();
      }
    );
  }
  if (ast.type === "selector-tag") {
    const lowercasedValue = ast.value.toLowerCase();
    if (["from", "to"].includes(lowercasedValue)) {
      newObj.value = lowercasedValue;
    }
  }
  if (ast.type === "css-atrule" && ast.name.toLowerCase() === "supports") {
    delete newObj.value;
  }
  if (ast.type === "selector-unknown") {
    delete newObj.value;
  }
  if (ast.type === "value-comma_group") {
    const index = ast.groups.findIndex((node) => node.type === "value-number" && node.unit === "...");
    if (index !== -1) {
      newObj.groups[index].unit = "";
      newObj.groups.splice(index + 1, 0, {
        type: "value-word",
        value: "...",
        isColor: false,
        isHex: false
      });
    }
  }
  if (ast.type === "value-comma_group" && ast.groups.some((node) => node.type === "value-atword" && node.value.endsWith("[") || node.type === "value-word" && node.value.startsWith("]"))) {
    return {
      type: "value-atword",
      value: ast.groups.map((node) => node.value).join(""),
      group: {
        open: null,
        close: null,
        groups: [],
        type: "value-paren_group"
      }
    };
  }
}
clean2.ignoredProperties = ignoredProperties2;
function cleanCSSStrings(value) {
  return string_replace_all_default(
    /* isOptionalObject*/
    false,
    string_replace_all_default(
      /* isOptionalObject*/
      false,
      value,
      "'",
      '"'
    ),
    /\\([^\dA-Fa-f])/g,
    "$1"
  );
}
var clean_default2 = clean2;

// src/utils/front-matter/print.js
async function print2(node, textToDoc2) {
  if (node.lang === "yaml") {
    const value = node.value.trim();
    const doc2 = value ? await textToDoc2(value, { parser: "yaml" }) : "";
    return markAsRoot([
      node.startDelimiter,
      hardline,
      doc2,
      doc2 ? hardline : "",
      node.endDelimiter
    ]);
  }
}
var print_default = print2;

// src/language-css/embed.js
function embed2(path11) {
  const { node } = path11;
  if (node.type === "front-matter") {
    return async (textToDoc2) => {
      const doc2 = await print_default(node, textToDoc2);
      return doc2 ? [doc2, hardline] : void 0;
    };
  }
}
embed2.getVisitorKeys = (node) => node.type === "css-root" ? ["frontMatter"] : [];
var embed_default2 = embed2;

// src/utils/front-matter/parse.js
var frontMatterRegex = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
function parse3(text) {
  const match = text.match(frontMatterRegex);
  if (!match) {
    return {
      content: text
    };
  }
  const {
    startDelimiter,
    language,
    value = "",
    endDelimiter
  } = match.groups;
  let lang = language.trim() || "yaml";
  if (startDelimiter === "+++") {
    lang = "toml";
  }
  if (lang !== "yaml" && startDelimiter !== endDelimiter) {
    return {
      content: text
    };
  }
  const [raw] = match;
  const frontMatter = {
    type: "front-matter",
    lang,
    value,
    startDelimiter,
    endDelimiter,
    raw: raw.replace(/\n$/, "")
  };
  return {
    frontMatter,
    content: string_replace_all_default(
      /* isOptionalObject*/
      false,
      raw,
      /[^\n]/g,
      " "
    ) + text.slice(raw.length)
  };
}
var parse_default = parse3;

// src/language-css/pragma.js
function insertPragma2(text) {
  const { frontMatter, content } = parse_default(text);
  return (frontMatter ? frontMatter.raw + "\n\n" : "") + insertPragma(content);
}

// src/language-css/visitor-keys.js
var visitorKeys = {
  "front-matter": [],
  "css-root": ["frontMatter", "nodes"],
  "css-comment": [],
  "css-rule": ["selector", "nodes"],
  "css-decl": ["value", "selector", "nodes"],
  "css-atrule": ["selector", "params", "value", "nodes"],
  "media-query-list": ["nodes"],
  "media-query": ["nodes"],
  "media-type": [],
  "media-feature-expression": ["nodes"],
  "media-feature": [],
  "media-colon": [],
  "media-value": [],
  "media-keyword": [],
  "media-url": [],
  "media-unknown": [],
  "selector-root": ["nodes"],
  "selector-selector": ["nodes"],
  "selector-comment": [],
  "selector-string": [],
  "selector-tag": [],
  "selector-id": [],
  "selector-class": [],
  "selector-attribute": [],
  "selector-combinator": ["nodes"],
  "selector-universal": [],
  "selector-pseudo": ["nodes"],
  "selector-nesting": [],
  "selector-unknown": [],
  "value-value": ["group"],
  "value-root": ["group"],
  "value-comment": [],
  "value-comma_group": ["groups"],
  "value-paren_group": ["open", "groups", "close"],
  "value-func": ["group"],
  "value-paren": [],
  "value-number": [],
  "value-operator": [],
  "value-word": [],
  "value-colon": [],
  "value-comma": [],
  "value-string": [],
  "value-atword": [],
  "value-unicode-range": [],
  "value-unknown": []
};
var visitor_keys_default = visitorKeys;

// src/language-css/get-visitor-keys.js
var getVisitorKeys2 = create_get_visitor_keys_default(visitor_keys_default);
var get_visitor_keys_default2 = getVisitorKeys2;

// src/language-css/utils/index.js
var colorAdjusterFunctions = /* @__PURE__ */ new Set([
  "red",
  "green",
  "blue",
  "alpha",
  "a",
  "rgb",
  "hue",
  "h",
  "saturation",
  "s",
  "lightness",
  "l",
  "whiteness",
  "w",
  "blackness",
  "b",
  "tint",
  "shade",
  "blend",
  "blenda",
  "contrast",
  "hsl",
  "hsla",
  "hwb",
  "hwba"
]);
function getPropOfDeclNode(path11) {
  var _a, _b;
  return (_b = (_a = path11.findAncestor((node) => node.type === "css-decl")) == null ? void 0 : _a.prop) == null ? void 0 : _b.toLowerCase();
}
var wideKeywords = /* @__PURE__ */ new Set(["initial", "inherit", "unset", "revert"]);
function isWideKeywords(value) {
  return wideKeywords.has(value.toLowerCase());
}
function isKeyframeAtRuleKeywords(path11, value) {
  var _a;
  const atRuleAncestorNode = path11.findAncestor(
    (node) => node.type === "css-atrule"
  );
  return ((_a = atRuleAncestorNode == null ? void 0 : atRuleAncestorNode.name) == null ? void 0 : _a.toLowerCase().endsWith("keyframes")) && ["from", "to"].includes(value.toLowerCase());
}
function maybeToLowerCase(value) {
  return value.includes("$") || value.includes("@") || value.includes("#") || value.startsWith("%") || value.startsWith("--") || value.startsWith(":--") || value.includes("(") && value.includes(")") ? value : value.toLowerCase();
}
function insideValueFunctionNode(path11, functionName) {
  var _a;
  const funcAncestorNode = path11.findAncestor(
    (node) => node.type === "value-func"
  );
  return ((_a = funcAncestorNode == null ? void 0 : funcAncestorNode.value) == null ? void 0 : _a.toLowerCase()) === functionName;
}
function insideICSSRuleNode(path11) {
  var _a;
  const ruleAncestorNode = path11.findAncestor(
    (node) => node.type === "css-rule"
  );
  const selector = (_a = ruleAncestorNode == null ? void 0 : ruleAncestorNode.raws) == null ? void 0 : _a.selector;
  return selector && (selector.startsWith(":import") || selector.startsWith(":export"));
}
function insideAtRuleNode(path11, atRuleNameOrAtRuleNames) {
  const atRuleNames = Array.isArray(atRuleNameOrAtRuleNames) ? atRuleNameOrAtRuleNames : [atRuleNameOrAtRuleNames];
  const atRuleAncestorNode = path11.findAncestor(
    (node) => node.type === "css-atrule"
  );
  return atRuleAncestorNode && atRuleNames.includes(atRuleAncestorNode.name.toLowerCase());
}
function insideURLFunctionInImportAtRuleNode(path11) {
  var _a;
  const { node } = path11;
  return node.groups[0].value === "url" && node.groups.length === 2 && ((_a = path11.findAncestor((node2) => node2.type === "css-atrule")) == null ? void 0 : _a.name) === "import";
}
function isURLFunctionNode(node) {
  return node.type === "value-func" && node.value.toLowerCase() === "url";
}
function isVarFunctionNode(node) {
  return node.type === "value-func" && node.value.toLowerCase() === "var";
}
function isLastNode(path11, node) {
  var _a;
  const nodes = (_a = path11.parent) == null ? void 0 : _a.nodes;
  return nodes && nodes.indexOf(node) === nodes.length - 1;
}
function isDetachedRulesetDeclarationNode(node) {
  const { selector } = node;
  if (!selector) {
    return false;
  }
  return typeof selector === "string" && /^@.+:.*$/.test(selector) || selector.value && /^@.+:.*$/.test(selector.value);
}
function isForKeywordNode(node) {
  return node.type === "value-word" && ["from", "through", "end"].includes(node.value);
}
function isIfElseKeywordNode(node) {
  return node.type === "value-word" && ["and", "or", "not"].includes(node.value);
}
function isEachKeywordNode(node) {
  return node.type === "value-word" && node.value === "in";
}
function isMultiplicationNode(node) {
  return node.type === "value-operator" && node.value === "*";
}
function isDivisionNode(node) {
  return node.type === "value-operator" && node.value === "/";
}
function isAdditionNode(node) {
  return node.type === "value-operator" && node.value === "+";
}
function isSubtractionNode(node) {
  return node.type === "value-operator" && node.value === "-";
}
function isModuloNode(node) {
  return node.type === "value-operator" && node.value === "%";
}
function isMathOperatorNode(node) {
  return isMultiplicationNode(node) || isDivisionNode(node) || isAdditionNode(node) || isSubtractionNode(node) || isModuloNode(node);
}
function isEqualityOperatorNode(node) {
  return node.type === "value-word" && ["==", "!="].includes(node.value);
}
function isRelationalOperatorNode(node) {
  return node.type === "value-word" && ["<", ">", "<=", ">="].includes(node.value);
}
function isSCSSControlDirectiveNode(node, options9) {
  return options9.parser === "scss" && node.type === "css-atrule" && ["if", "else", "for", "each", "while"].includes(node.name);
}
function isDetachedRulesetCallNode(node) {
  var _a;
  return ((_a = node.raws) == null ? void 0 : _a.params) && /^\(\s*\)$/.test(node.raws.params);
}
function isTemplatePlaceholderNode(node) {
  return node.name.startsWith("prettier-placeholder");
}
function isTemplatePropNode(node) {
  return node.prop.startsWith("@prettier-placeholder");
}
function isPostcssSimpleVarNode(currentNode, nextNode) {
  return currentNode.value === "$$" && currentNode.type === "value-func" && (nextNode == null ? void 0 : nextNode.type) === "value-word" && !nextNode.raws.before;
}
function hasComposesNode(node) {
  var _a, _b;
  return ((_a = node.value) == null ? void 0 : _a.type) === "value-root" && ((_b = node.value.group) == null ? void 0 : _b.type) === "value-value" && node.prop.toLowerCase() === "composes";
}
function hasParensAroundNode(node) {
  var _a, _b, _c;
  return ((_c = (_b = (_a = node.value) == null ? void 0 : _a.group) == null ? void 0 : _b.group) == null ? void 0 : _c.type) === "value-paren_group" && node.value.group.group.open !== null && node.value.group.group.close !== null;
}
function hasEmptyRawBefore(node) {
  var _a;
  return ((_a = node.raws) == null ? void 0 : _a.before) === "";
}
function isKeyValuePairNode(node) {
  var _a, _b;
  return node.type === "value-comma_group" && ((_b = (_a = node.groups) == null ? void 0 : _a[1]) == null ? void 0 : _b.type) === "value-colon";
}
function isKeyValuePairInParenGroupNode(node) {
  var _a;
  return node.type === "value-paren_group" && ((_a = node.groups) == null ? void 0 : _a[0]) && isKeyValuePairNode(node.groups[0]);
}
function isSCSSMapItemNode(path11, options9) {
  var _a;
  if (options9.parser !== "scss") {
    return false;
  }
  const { node } = path11;
  if (node.groups.length === 0) {
    return false;
  }
  const parentParentNode = path11.grandparent;
  if (!isKeyValuePairInParenGroupNode(node) && !(parentParentNode && isKeyValuePairInParenGroupNode(parentParentNode))) {
    return false;
  }
  const declNode = path11.findAncestor((node2) => node2.type === "css-decl");
  if ((_a = declNode == null ? void 0 : declNode.prop) == null ? void 0 : _a.startsWith("$")) {
    return true;
  }
  if (isKeyValuePairInParenGroupNode(parentParentNode)) {
    return true;
  }
  if (parentParentNode.type === "value-func") {
    return true;
  }
  return false;
}
function isInlineValueCommentNode(node) {
  return node.type === "value-comment" && node.inline;
}
function isHashNode(node) {
  return node.type === "value-word" && node.value === "#";
}
function isLeftCurlyBraceNode(node) {
  return node.type === "value-word" && node.value === "{";
}
function isRightCurlyBraceNode(node) {
  return node.type === "value-word" && node.value === "}";
}
function isWordNode(node) {
  return ["value-word", "value-atword"].includes(node.type);
}
function isColonNode(node) {
  return (node == null ? void 0 : node.type) === "value-colon";
}
function isKeyInValuePairNode(node, parentNode) {
  if (!isKeyValuePairNode(parentNode)) {
    return false;
  }
  const { groups } = parentNode;
  const index = groups.indexOf(node);
  if (index === -1) {
    return false;
  }
  return isColonNode(groups[index + 1]);
}
function isMediaAndSupportsKeywords(node) {
  return node.value && ["not", "and", "or"].includes(node.value.toLowerCase());
}
function isColorAdjusterFuncNode(node) {
  if (node.type !== "value-func") {
    return false;
  }
  return colorAdjusterFunctions.has(node.value.toLowerCase());
}
function lastLineHasInlineComment(text) {
  return /\/\//.test(text.split(/[\n\r]/).pop());
}
function isAtWordPlaceholderNode(node) {
  return (node == null ? void 0 : node.type) === "value-atword" && node.value.startsWith("prettier-placeholder-");
}
function isConfigurationNode(node, parentNode) {
  var _a, _b;
  if (((_a = node.open) == null ? void 0 : _a.value) !== "(" || ((_b = node.close) == null ? void 0 : _b.value) !== ")" || node.groups.some((group2) => group2.type !== "value-comma_group")) {
    return false;
  }
  if (parentNode.type === "value-comma_group") {
    const prevIdx = parentNode.groups.indexOf(node) - 1;
    const maybeWithNode = parentNode.groups[prevIdx];
    if ((maybeWithNode == null ? void 0 : maybeWithNode.type) === "value-word" && maybeWithNode.value === "with") {
      return true;
    }
  }
  return false;
}
function isParenGroupNode(node) {
  var _a, _b;
  return node.type === "value-paren_group" && ((_a = node.open) == null ? void 0 : _a.value) === "(" && ((_b = node.close) == null ? void 0 : _b.value) === ")";
}

// src/language-css/loc.js
function locStart2(node) {
  return node.source.startOffset;
}
function locEnd2(node) {
  return node.source.endOffset;
}

// src/language-css/utils/css-units.evaluate.js
var css_units_evaluate_default = /* @__PURE__ */ new Map([
  [
    "em",
    "em"
  ],
  [
    "rem",
    "rem"
  ],
  [
    "ex",
    "ex"
  ],
  [
    "rex",
    "rex"
  ],
  [
    "cap",
    "cap"
  ],
  [
    "rcap",
    "rcap"
  ],
  [
    "ch",
    "ch"
  ],
  [
    "rch",
    "rch"
  ],
  [
    "ic",
    "ic"
  ],
  [
    "ric",
    "ric"
  ],
  [
    "lh",
    "lh"
  ],
  [
    "rlh",
    "rlh"
  ],
  [
    "vw",
    "vw"
  ],
  [
    "svw",
    "svw"
  ],
  [
    "lvw",
    "lvw"
  ],
  [
    "dvw",
    "dvw"
  ],
  [
    "vh",
    "vh"
  ],
  [
    "svh",
    "svh"
  ],
  [
    "lvh",
    "lvh"
  ],
  [
    "dvh",
    "dvh"
  ],
  [
    "vi",
    "vi"
  ],
  [
    "svi",
    "svi"
  ],
  [
    "lvi",
    "lvi"
  ],
  [
    "dvi",
    "dvi"
  ],
  [
    "vb",
    "vb"
  ],
  [
    "svb",
    "svb"
  ],
  [
    "lvb",
    "lvb"
  ],
  [
    "dvb",
    "dvb"
  ],
  [
    "vmin",
    "vmin"
  ],
  [
    "svmin",
    "svmin"
  ],
  [
    "lvmin",
    "lvmin"
  ],
  [
    "dvmin",
    "dvmin"
  ],
  [
    "vmax",
    "vmax"
  ],
  [
    "svmax",
    "svmax"
  ],
  [
    "lvmax",
    "lvmax"
  ],
  [
    "dvmax",
    "dvmax"
  ],
  [
    "cm",
    "cm"
  ],
  [
    "mm",
    "mm"
  ],
  [
    "q",
    "Q"
  ],
  [
    "in",
    "in"
  ],
  [
    "pt",
    "pt"
  ],
  [
    "pc",
    "pc"
  ],
  [
    "px",
    "px"
  ],
  [
    "deg",
    "deg"
  ],
  [
    "grad",
    "grad"
  ],
  [
    "rad",
    "rad"
  ],
  [
    "turn",
    "turn"
  ],
  [
    "s",
    "s"
  ],
  [
    "ms",
    "ms"
  ],
  [
    "hz",
    "Hz"
  ],
  [
    "khz",
    "kHz"
  ],
  [
    "dpi",
    "dpi"
  ],
  [
    "dpcm",
    "dpcm"
  ],
  [
    "dppx",
    "dppx"
  ],
  [
    "x",
    "x"
  ],
  [
    "cqw",
    "cqw"
  ],
  [
    "cqh",
    "cqh"
  ],
  [
    "cqi",
    "cqi"
  ],
  [
    "cqb",
    "cqb"
  ],
  [
    "cqmin",
    "cqmin"
  ],
  [
    "cqmax",
    "cqmax"
  ]
]);

// src/language-css/utils/print-unit.js
function printUnit(unit) {
  const lowercased = unit.toLowerCase();
  return css_units_evaluate_default.has(lowercased) ? css_units_evaluate_default.get(lowercased) : unit;
}
var print_unit_default = printUnit;

// src/language-css/printer-postcss.js
function shouldPrintComma2(options9) {
  return options9.trailingComma === "es5" || options9.trailingComma === "all";
}
function genericPrint2(path11, options9, print4) {
  var _a, _b, _c, _d, _e;
  const {
    node
  } = path11;
  switch (node.type) {
    case "front-matter":
      return [node.raw, hardline];
    case "css-root": {
      const nodes = printNodeSequence(path11, options9, print4);
      let after = node.raws.after.trim();
      if (after.startsWith(";")) {
        after = after.slice(1).trim();
      }
      return [node.frontMatter ? [print4("frontMatter"), hardline] : "", nodes, after ? ` ${after}` : "", node.nodes.length > 0 ? hardline : ""];
    }
    case "css-comment": {
      const isInlineComment = node.inline || node.raws.inline;
      const text = options9.originalText.slice(locStart2(node), locEnd2(node));
      return isInlineComment ? text.trimEnd() : text;
    }
    case "css-rule":
      return [print4("selector"), node.important ? " !important" : "", node.nodes ? [((_a = node.selector) == null ? void 0 : _a.type) === "selector-unknown" && lastLineHasInlineComment(node.selector.value) ? line : node.selector ? " " : "", "{", node.nodes.length > 0 ? indent([hardline, printNodeSequence(path11, options9, print4)]) : "", hardline, "}", isDetachedRulesetDeclarationNode(node) ? ";" : ""] : ";"];
    case "css-decl": {
      const parentNode = path11.parent;
      const {
        between: rawBetween
      } = node.raws;
      const trimmedBetween = rawBetween.trim();
      const isColon = trimmedBetween === ":";
      const isValueAllSpace = typeof node.value === "string" && /^ *$/.test(node.value);
      let value = typeof node.value === "string" ? node.value : print4("value");
      value = hasComposesNode(node) ? removeLines(value) : value;
      if (!isColon && lastLineHasInlineComment(trimmedBetween)) {
        value = indent([hardline, dedent(value)]);
      }
      return [
        string_replace_all_default(
          /* isOptionalObject*/
          false,
          node.raws.before,
          /[\s;]/g,
          ""
        ),
        // Less variable
        parentNode.type === "css-atrule" && parentNode.variable || insideICSSRuleNode(path11) ? node.prop : maybeToLowerCase(node.prop),
        trimmedBetween.startsWith("//") ? " " : "",
        trimmedBetween,
        node.extend || isValueAllSpace ? "" : " ",
        options9.parser === "less" && node.extend && node.selector ? ["extend(", print4("selector"), ")"] : "",
        value,
        node.raws.important ? node.raws.important.replace(/\s*!\s*important/i, " !important") : node.important ? " !important" : "",
        node.raws.scssDefault ? node.raws.scssDefault.replace(/\s*!default/i, " !default") : node.scssDefault ? " !default" : "",
        node.raws.scssGlobal ? node.raws.scssGlobal.replace(/\s*!global/i, " !global") : node.scssGlobal ? " !global" : "",
        node.nodes ? [" {", indent([softline, printNodeSequence(path11, options9, print4)]), softline, "}"] : isTemplatePropNode(node) && !parentNode.raws.semicolon && options9.originalText[locEnd2(node) - 1] !== ";" ? "" : options9.__isHTMLStyleAttribute && isLastNode(path11, node) ? ifBreak(";") : ";"
      ];
    }
    case "css-atrule": {
      const parentNode = path11.parent;
      const isTemplatePlaceholderNodeWithoutSemiColon = isTemplatePlaceholderNode(node) && !parentNode.raws.semicolon && options9.originalText[locEnd2(node) - 1] !== ";";
      if (options9.parser === "less") {
        if (node.mixin) {
          return [print4("selector"), node.important ? " !important" : "", isTemplatePlaceholderNodeWithoutSemiColon ? "" : ";"];
        }
        if (node.function) {
          return [node.name, typeof node.params === "string" ? node.params : print4("params"), isTemplatePlaceholderNodeWithoutSemiColon ? "" : ";"];
        }
        if (node.variable) {
          return ["@", node.name, ": ", node.value ? print4("value") : "", node.raws.between.trim() ? node.raws.between.trim() + " " : "", node.nodes ? ["{", indent([node.nodes.length > 0 ? softline : "", printNodeSequence(path11, options9, print4)]), softline, "}"] : "", isTemplatePlaceholderNodeWithoutSemiColon ? "" : ";"];
        }
      }
      const isImportUnknownValueEndsWithSemiColon = node.name === "import" && ((_b = node.params) == null ? void 0 : _b.type) === "value-unknown" && node.params.value.endsWith(";");
      return [
        "@",
        // If a Less file ends up being parsed with the SCSS parser, Less
        // variable declarations will be parsed as at-rules with names ending
        // with a colon, so keep the original case then.
        isDetachedRulesetCallNode(node) || node.name.endsWith(":") ? node.name : maybeToLowerCase(node.name),
        node.params ? [isDetachedRulesetCallNode(node) ? "" : isTemplatePlaceholderNode(node) ? node.raws.afterName === "" ? "" : node.name.endsWith(":") ? " " : /^\s*\n\s*\n/.test(node.raws.afterName) ? [hardline, hardline] : /^\s*\n/.test(node.raws.afterName) ? hardline : " " : " ", typeof node.params === "string" ? node.params : print4("params")] : "",
        node.selector ? indent([" ", print4("selector")]) : "",
        node.value ? group([" ", print4("value"), isSCSSControlDirectiveNode(node, options9) ? hasParensAroundNode(node) ? " " : line : ""]) : node.name === "else" ? " " : "",
        node.nodes ? [isSCSSControlDirectiveNode(node, options9) ? "" : node.selector && !node.selector.nodes && typeof node.selector.value === "string" && lastLineHasInlineComment(node.selector.value) || !node.selector && typeof node.params === "string" && lastLineHasInlineComment(node.params) ? line : " ", "{", indent([node.nodes.length > 0 ? softline : "", printNodeSequence(path11, options9, print4)]), softline, "}"] : isTemplatePlaceholderNodeWithoutSemiColon || isImportUnknownValueEndsWithSemiColon ? "" : ";"
      ];
    }
    case "media-query-list": {
      const parts = [];
      path11.each(({
        node: node2
      }) => {
        if (node2.type === "media-query" && node2.value === "") {
          return;
        }
        parts.push(print4());
      }, "nodes");
      return group(indent(join(line, parts)));
    }
    case "media-query":
      return [join(" ", path11.map(print4, "nodes")), isLastNode(path11, node) ? "" : ","];
    case "media-type":
      return adjustNumbers(adjustStrings(node.value, options9));
    case "media-feature-expression":
      if (!node.nodes) {
        return node.value;
      }
      return ["(", ...path11.map(print4, "nodes"), ")"];
    case "media-feature":
      return maybeToLowerCase(adjustStrings(string_replace_all_default(
        /* isOptionalObject*/
        false,
        node.value,
        / +/g,
        " "
      ), options9));
    case "media-colon":
      return [node.value, " "];
    case "media-value":
      return adjustNumbers(adjustStrings(node.value, options9));
    case "media-keyword":
      return adjustStrings(node.value, options9);
    case "media-url":
      return adjustStrings(string_replace_all_default(
        /* isOptionalObject*/
        false,
        string_replace_all_default(
          /* isOptionalObject*/
          false,
          node.value,
          /^url\(\s+/gi,
          "url("
        ),
        /\s+\)$/g,
        ")"
      ), options9);
    case "media-unknown":
      return node.value;
    case "selector-root":
      return group([insideAtRuleNode(path11, "custom-selector") ? [path11.findAncestor((node2) => node2.type === "css-atrule").customSelector, line] : "", join([",", insideAtRuleNode(path11, ["extend", "custom-selector", "nest"]) ? line : hardline], path11.map(print4, "nodes"))]);
    case "selector-selector":
      return group(indent(path11.map(print4, "nodes")));
    case "selector-comment":
      return node.value;
    case "selector-string":
      return adjustStrings(node.value, options9);
    case "selector-tag":
      return [node.namespace ? [node.namespace === true ? "" : node.namespace.trim(), "|"] : "", ((_c = path11.previous) == null ? void 0 : _c.type) === "selector-nesting" ? node.value : adjustNumbers(isKeyframeAtRuleKeywords(path11, node.value) ? node.value.toLowerCase() : node.value)];
    case "selector-id":
      return ["#", node.value];
    case "selector-class":
      return [".", adjustNumbers(adjustStrings(node.value, options9))];
    case "selector-attribute":
      return ["[", node.namespace ? [node.namespace === true ? "" : node.namespace.trim(), "|"] : "", node.attribute.trim(), node.operator ?? "", node.value ? quoteAttributeValue(adjustStrings(node.value.trim(), options9), options9) : "", node.insensitive ? " i" : "", "]"];
    case "selector-combinator": {
      if (node.value === "+" || node.value === ">" || node.value === "~" || node.value === ">>>") {
        const parentNode = path11.parent;
        const leading2 = parentNode.type === "selector-selector" && parentNode.nodes[0] === node ? "" : line;
        return [leading2, node.value, isLastNode(path11, node) ? "" : " "];
      }
      const leading = node.value.trim().startsWith("(") ? line : "";
      const value = adjustNumbers(adjustStrings(node.value.trim(), options9)) || line;
      return [leading, value];
    }
    case "selector-universal":
      return [node.namespace ? [node.namespace === true ? "" : node.namespace.trim(), "|"] : "", node.value];
    case "selector-pseudo":
      return [maybeToLowerCase(node.value), is_non_empty_array_default(node.nodes) ? group(["(", indent([softline, join([",", line], path11.map(print4, "nodes"))]), softline, ")"]) : ""];
    case "selector-nesting":
      return node.value;
    case "selector-unknown": {
      const ruleAncestorNode = path11.findAncestor((node2) => node2.type === "css-rule");
      if (ruleAncestorNode == null ? void 0 : ruleAncestorNode.isSCSSNesterProperty) {
        return adjustNumbers(adjustStrings(maybeToLowerCase(node.value), options9));
      }
      const parentNode = path11.parent;
      if ((_d = parentNode.raws) == null ? void 0 : _d.selector) {
        const start = locStart2(parentNode);
        const end = start + parentNode.raws.selector.length;
        return options9.originalText.slice(start, end).trim();
      }
      const grandParent = path11.grandparent;
      if (parentNode.type === "value-paren_group" && (grandParent == null ? void 0 : grandParent.type) === "value-func" && grandParent.value === "selector") {
        const start = locEnd2(parentNode.open) + 1;
        const end = locStart2(parentNode.close);
        const selector = options9.originalText.slice(start, end).trim();
        return lastLineHasInlineComment(selector) ? [breakParent, selector] : selector;
      }
      return node.value;
    }
    case "value-value":
    case "value-root":
      return print4("group");
    case "value-comment":
      return options9.originalText.slice(locStart2(node), locEnd2(node));
    case "value-comma_group": {
      const parentNode = path11.parent;
      const parentParentNode = path11.grandparent;
      const declAncestorProp = getPropOfDeclNode(path11);
      const isGridValue = declAncestorProp && parentNode.type === "value-value" && (declAncestorProp === "grid" || declAncestorProp.startsWith("grid-template"));
      const atRuleAncestorNode = path11.findAncestor((node2) => node2.type === "css-atrule");
      const isControlDirective = atRuleAncestorNode && isSCSSControlDirectiveNode(atRuleAncestorNode, options9);
      const hasInlineComment = node.groups.some((node2) => isInlineValueCommentNode(node2));
      const printed = path11.map(print4, "groups");
      const parts = [];
      const insideURLFunction = insideValueFunctionNode(path11, "url");
      let insideSCSSInterpolationInString = false;
      let didBreak = false;
      for (let i = 0; i < node.groups.length; ++i) {
        parts.push(printed[i]);
        const iPrevNode = node.groups[i - 1];
        const iNode = node.groups[i];
        const iNextNode = node.groups[i + 1];
        const iNextNextNode = node.groups[i + 2];
        if (insideURLFunction) {
          if (iNextNode && isAdditionNode(iNextNode) || isAdditionNode(iNode)) {
            parts.push(" ");
          }
          continue;
        }
        if (insideAtRuleNode(path11, "forward") && iNode.type === "value-word" && iNode.value && iPrevNode !== void 0 && iPrevNode.type === "value-word" && iPrevNode.value === "as" && iNextNode.type === "value-operator" && iNextNode.value === "*") {
          continue;
        }
        if (!iNextNode) {
          continue;
        }
        if (iNode.type === "value-word" && iNode.value.endsWith("-") && isAtWordPlaceholderNode(iNextNode)) {
          continue;
        }
        if (iNode.type === "value-string" && iNode.quoted) {
          const positionOfOpeningInterpolation = iNode.value.lastIndexOf("#{");
          const positionOfClosingInterpolation = iNode.value.lastIndexOf("}");
          if (positionOfOpeningInterpolation !== -1 && positionOfClosingInterpolation !== -1) {
            insideSCSSInterpolationInString = positionOfOpeningInterpolation > positionOfClosingInterpolation;
          } else if (positionOfOpeningInterpolation !== -1) {
            insideSCSSInterpolationInString = true;
          } else if (positionOfClosingInterpolation !== -1) {
            insideSCSSInterpolationInString = false;
          }
        }
        if (insideSCSSInterpolationInString) {
          continue;
        }
        if (isColonNode(iNode) || isColonNode(iNextNode)) {
          continue;
        }
        if (iNode.type === "value-atword" && (iNode.value === "" || /*
        @var[ @notVarNested ][notVar]
        ^^^^^
        */
        iNode.value.endsWith("["))) {
          continue;
        }
        if (iNextNode.type === "value-word" && iNextNode.value.startsWith("]")) {
          continue;
        }
        if (iNode.value === "~") {
          continue;
        }
        if (iNode.type !== "value-string" && iNode.value && iNode.value.includes("\\") && iNextNode && iNextNode.type !== "value-comment") {
          continue;
        }
        if ((iPrevNode == null ? void 0 : iPrevNode.value) && iPrevNode.value.indexOf("\\") === iPrevNode.value.length - 1 && iNode.type === "value-operator" && iNode.value === "/") {
          continue;
        }
        if (iNode.value === "\\") {
          continue;
        }
        if (isPostcssSimpleVarNode(iNode, iNextNode)) {
          continue;
        }
        if (isHashNode(iNode) || isLeftCurlyBraceNode(iNode) || isRightCurlyBraceNode(iNextNode) || isLeftCurlyBraceNode(iNextNode) && hasEmptyRawBefore(iNextNode) || isRightCurlyBraceNode(iNode) && hasEmptyRawBefore(iNextNode)) {
          continue;
        }
        if (iNode.value === "--" && isHashNode(iNextNode)) {
          continue;
        }
        const isMathOperator = isMathOperatorNode(iNode);
        const isNextMathOperator = isMathOperatorNode(iNextNode);
        if ((isMathOperator && isHashNode(iNextNode) || isNextMathOperator && isRightCurlyBraceNode(iNode)) && hasEmptyRawBefore(iNextNode)) {
          continue;
        }
        if (!iPrevNode && isDivisionNode(iNode)) {
          continue;
        }
        if (insideValueFunctionNode(path11, "calc") && (isAdditionNode(iNode) || isAdditionNode(iNextNode) || isSubtractionNode(iNode) || isSubtractionNode(iNextNode)) && hasEmptyRawBefore(iNextNode)) {
          continue;
        }
        const isColorAdjusterNode = (isAdditionNode(iNode) || isSubtractionNode(iNode)) && i === 0 && (iNextNode.type === "value-number" || iNextNode.isHex) && parentParentNode && isColorAdjusterFuncNode(parentParentNode) && !hasEmptyRawBefore(iNextNode);
        const requireSpaceBeforeOperator = (iNextNextNode == null ? void 0 : iNextNextNode.type) === "value-func" || iNextNextNode && isWordNode(iNextNextNode) || iNode.type === "value-func" || isWordNode(iNode);
        const requireSpaceAfterOperator = iNextNode.type === "value-func" || isWordNode(iNextNode) || (iPrevNode == null ? void 0 : iPrevNode.type) === "value-func" || iPrevNode && isWordNode(iPrevNode);
        if (!(isMultiplicationNode(iNextNode) || isMultiplicationNode(iNode)) && !insideValueFunctionNode(path11, "calc") && !isColorAdjusterNode && (isDivisionNode(iNextNode) && !requireSpaceBeforeOperator || isDivisionNode(iNode) && !requireSpaceAfterOperator || isAdditionNode(iNextNode) && !requireSpaceBeforeOperator || isAdditionNode(iNode) && !requireSpaceAfterOperator || isSubtractionNode(iNextNode) || isSubtractionNode(iNode)) && (hasEmptyRawBefore(iNextNode) || isMathOperator && (!iPrevNode || iPrevNode && isMathOperatorNode(iPrevNode)))) {
          continue;
        }
        if ((options9.parser === "scss" || options9.parser === "less") && isMathOperator && iNode.value === "-" && isParenGroupNode(iNextNode) && locEnd2(iNode) === locStart2(iNextNode.open) && iNextNode.open.value === "(") {
          continue;
        }
        if (isInlineValueCommentNode(iNode)) {
          if (parentNode.type === "value-paren_group") {
            parts.push(dedent(hardline));
            continue;
          }
          parts.push(hardline);
          continue;
        }
        if (isControlDirective && (isEqualityOperatorNode(iNextNode) || isRelationalOperatorNode(iNextNode) || isIfElseKeywordNode(iNextNode) || isEachKeywordNode(iNode) || isForKeywordNode(iNode))) {
          parts.push(" ");
          continue;
        }
        if (atRuleAncestorNode && atRuleAncestorNode.name.toLowerCase() === "namespace") {
          parts.push(" ");
          continue;
        }
        if (isGridValue) {
          if (iNode.source && iNextNode.source && iNode.source.start.line !== iNextNode.source.start.line) {
            parts.push(hardline);
            didBreak = true;
          } else {
            parts.push(" ");
          }
          continue;
        }
        if (isNextMathOperator) {
          parts.push(" ");
          continue;
        }
        if ((iNextNode == null ? void 0 : iNextNode.value) === "...") {
          continue;
        }
        if (isAtWordPlaceholderNode(iNode) && isAtWordPlaceholderNode(iNextNode) && locEnd2(iNode) === locStart2(iNextNode)) {
          continue;
        }
        if (isAtWordPlaceholderNode(iNode) && isParenGroupNode(iNextNode) && locEnd2(iNode) === locStart2(iNextNode.open)) {
          parts.push(softline);
          continue;
        }
        if (iNode.value === "with" && isParenGroupNode(iNextNode)) {
          parts.push(" ");
          continue;
        }
        if (((_e = iNode.value) == null ? void 0 : _e.endsWith("#")) && iNextNode.value === "{" && isParenGroupNode(iNextNode.group)) {
          continue;
        }
        parts.push(line);
      }
      if (hasInlineComment) {
        parts.push(breakParent);
      }
      if (didBreak) {
        parts.unshift(hardline);
      }
      if (isControlDirective) {
        return group(indent(parts));
      }
      if (insideURLFunctionInImportAtRuleNode(path11)) {
        return group(fill(parts));
      }
      return group(indent(fill(parts)));
    }
    case "value-paren_group": {
      const parentNode = path11.parent;
      const printedGroups = path11.map(() => {
        const child = path11.node;
        return typeof child === "string" ? child : print4();
      }, "groups");
      if (parentNode && isURLFunctionNode(parentNode) && (node.groups.length === 1 || node.groups.length > 0 && node.groups[0].type === "value-comma_group" && node.groups[0].groups.length > 0 && node.groups[0].groups[0].type === "value-word" && node.groups[0].groups[0].value.startsWith("data:"))) {
        return [node.open ? print4("open") : "", join(",", printedGroups), node.close ? print4("close") : ""];
      }
      if (!node.open) {
        return group(indent(fill(join([",", line], printedGroups))));
      }
      const isSCSSMapItem = isSCSSMapItemNode(path11, options9);
      const lastItem = at_default(
        /* isOptionalObject*/
        false,
        node.groups,
        -1
      );
      const isLastItemComment = (lastItem == null ? void 0 : lastItem.type) === "value-comment";
      const isKey = isKeyInValuePairNode(node, parentNode);
      const isConfiguration = isConfigurationNode(node, parentNode);
      const isVarFunction = isVarFunctionNode(parentNode);
      const shouldBreak = isConfiguration || isSCSSMapItem && !isKey;
      const shouldDedent = isConfiguration || isKey;
      const printed = group([node.open ? print4("open") : "", indent([softline, join([line], path11.map(({
        node: child,
        isLast,
        index
      }) => {
        var _a2;
        const hasComma = () => Boolean(child.source && options9.originalText.slice(locStart2(child), locStart2(node.close)).trimEnd().endsWith(","));
        const shouldPrintComma3 = !isLast || isVarFunction && hasComma();
        let printed2 = [printedGroups[index], shouldPrintComma3 ? "," : ""];
        if (isKeyValuePairNode(child) && child.type === "value-comma_group" && child.groups && child.groups[0].type !== "value-paren_group" && ((_a2 = child.groups[2]) == null ? void 0 : _a2.type) === "value-paren_group") {
          const parts = getDocParts(printed2[0].contents.contents);
          parts[1] = group(parts[1]);
          printed2 = [group(dedent(printed2))];
        }
        if (!isLast && child.type === "value-comma_group" && is_non_empty_array_default(child.groups)) {
          let last = at_default(
            /* isOptionalObject*/
            false,
            child.groups,
            -1
          );
          if (!last.source && last.close) {
            last = last.close;
          }
          if (last.source && is_next_line_empty_default(options9.originalText, locEnd2(last))) {
            printed2.push(hardline);
          }
        }
        return printed2;
      }, "groups"))]), ifBreak(!isLastItemComment && options9.parser === "scss" && isSCSSMapItem && shouldPrintComma2(options9) ? "," : ""), softline, node.close ? print4("close") : ""], {
        shouldBreak
      });
      return shouldDedent ? dedent(printed) : printed;
    }
    case "value-func":
      return [node.value, insideAtRuleNode(path11, "supports") && isMediaAndSupportsKeywords(node) ? " " : "", print4("group")];
    case "value-paren":
      return node.value;
    case "value-number":
      return [printCssNumber(node.value), print_unit_default(node.unit)];
    case "value-operator":
      return node.value;
    case "value-word":
      if (node.isColor && node.isHex || isWideKeywords(node.value)) {
        return node.value.toLowerCase();
      }
      return node.value;
    case "value-colon": {
      const {
        previous
      } = path11;
      return [
        node.value,
        // Don't add spaces on escaped colon `:`, e.g: grid-template-rows: [row-1-00\:00] auto;
        typeof (previous == null ? void 0 : previous.value) === "string" && previous.value.endsWith("\\") || // Don't add spaces on `:` in `url` function (i.e. `url(fbglyph: cross-outline, fig-white)`)
        insideValueFunctionNode(path11, "url") ? "" : line
      ];
    }
    case "value-string":
      return print_string_default(node.raws.quote + node.value + node.raws.quote, options9);
    case "value-atword":
      return ["@", node.value];
    case "value-unicode-range":
      return node.value;
    case "value-unknown":
      return node.value;
    case "value-comma":
    default:
      throw new unexpected_node_error_default(node, "PostCSS");
  }
}
function printNodeSequence(path11, options9, print4) {
  const parts = [];
  path11.each(() => {
    const {
      node,
      previous
    } = path11;
    if ((previous == null ? void 0 : previous.type) === "css-comment" && previous.text.trim() === "prettier-ignore") {
      parts.push(options9.originalText.slice(locStart2(node), locEnd2(node)));
    } else {
      parts.push(print4());
    }
    if (path11.isLast) {
      return;
    }
    const {
      next
    } = path11;
    if (next.type === "css-comment" && !has_newline_default(options9.originalText, locStart2(next), {
      backwards: true
    }) && !is_front_matter_default(node) || next.type === "css-atrule" && next.name === "else" && node.type !== "css-comment") {
      parts.push(" ");
    } else {
      parts.push(options9.__isHTMLStyleAttribute ? line : hardline);
      if (is_next_line_empty_default(options9.originalText, locEnd2(node)) && !is_front_matter_default(node)) {
        parts.push(hardline);
      }
    }
  }, "nodes");
  return parts;
}
var STRING_REGEX = /(["'])(?:(?!\1)[^\\]|\\.)*\1/gs;
var NUMBER_REGEX = /(?:\d*\.\d+|\d+\.?)(?:[Ee][+-]?\d+)?/g;
var STANDARD_UNIT_REGEX = /[A-Za-z]+/g;
var WORD_PART_REGEX = /[$@]?[A-Z_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/g;
var ADJUST_NUMBERS_REGEX = new RegExp(STRING_REGEX.source + `|(${WORD_PART_REGEX.source})?(${NUMBER_REGEX.source})(${STANDARD_UNIT_REGEX.source})?`, "g");
function adjustStrings(value, options9) {
  return string_replace_all_default(
    /* isOptionalObject*/
    false,
    value,
    STRING_REGEX,
    (match) => print_string_default(match, options9)
  );
}
function quoteAttributeValue(value, options9) {
  const quote = options9.singleQuote ? "'" : '"';
  return value.includes('"') || value.includes("'") ? value : quote + value + quote;
}
function adjustNumbers(value) {
  return value.replace(ADJUST_NUMBERS_REGEX, (match, quote, wordPart, number, unit) => !wordPart && number ? printCssNumber(number) + maybeToLowerCase(unit || "") : match);
}
function printCssNumber(rawNumber) {
  return print_number_default(rawNumber).replace(/\.0(?=$|e)/, "");
}
var printer3 = {
  print: genericPrint2,
  embed: embed_default2,
  insertPragma: insertPragma2,
  massageAstNode: clean_default2,
  getVisitorKeys: get_visitor_keys_default2
};
var printer_postcss_default = printer3;

// src/language-css/languages.evaluate.js
var languages_evaluate_default2 = [
  {
    "linguistLanguageId": 50,
    "name": "CSS",
    "type": "markup",
    "tmScope": "source.css",
    "aceMode": "css",
    "codemirrorMode": "css",
    "codemirrorMimeType": "text/css",
    "color": "#563d7c",
    "extensions": [
      ".css",
      ".wxss"
    ],
    "parsers": [
      "css"
    ],
    "vscodeLanguageIds": [
      "css"
    ]
  },
  {
    "linguistLanguageId": 262764437,
    "name": "PostCSS",
    "type": "markup",
    "color": "#dc3a0c",
    "tmScope": "source.postcss",
    "group": "CSS",
    "extensions": [
      ".pcss",
      ".postcss"
    ],
    "aceMode": "text",
    "parsers": [
      "css"
    ],
    "vscodeLanguageIds": [
      "postcss"
    ]
  },
  {
    "linguistLanguageId": 198,
    "name": "Less",
    "type": "markup",
    "color": "#1d365d",
    "aliases": [
      "less-css"
    ],
    "extensions": [
      ".less"
    ],
    "tmScope": "source.css.less",
    "aceMode": "less",
    "codemirrorMode": "css",
    "codemirrorMimeType": "text/css",
    "parsers": [
      "less"
    ],
    "vscodeLanguageIds": [
      "less"
    ]
  },
  {
    "linguistLanguageId": 329,
    "name": "SCSS",
    "type": "markup",
    "color": "#c6538c",
    "tmScope": "source.css.scss",
    "aceMode": "scss",
    "codemirrorMode": "css",
    "codemirrorMimeType": "text/x-scss",
    "extensions": [
      ".scss"
    ],
    "parsers": [
      "scss"
    ],
    "vscodeLanguageIds": [
      "scss"
    ]
  }
];

// src/language-css/options.js
var options4 = {
  singleQuote: common_options_default.singleQuote
};
var options_default2 = options4;

// src/language-css/index.js
var printers2 = {
  postcss: printer_postcss_default
};
var parsers4 = create_parsers_default(parsers_default2);

// src/language-handlebars/index.js
var language_handlebars_exports = {};
__export(language_handlebars_exports, {
  languages: () => languages_evaluate_default3,
  parsers: () => parsers6,
  printers: () => printers3
});

// src/language-handlebars/parsers.js
var parsers5 = [
  {
    importPlugin: () => import("./plugins/glimmer.mjs"),
    parserNames: ["glimmer"]
  }
];
var parsers_default3 = parsers5;

// src/utils/html-whitespace-utils.js
var HTML_WHITESPACE_CHARACTERS = ["	", "\n", "\f", "\r", " "];
var htmlWhitespaceUtils = new whitespace_utils_default(HTML_WHITESPACE_CHARACTERS);
var html_whitespace_utils_default = htmlWhitespaceUtils;

// src/language-handlebars/loc.js
function locStart3(node) {
  return node.loc.start.offset;
}
function locEnd3(node) {
  return node.loc.end.offset;
}

// src/language-handlebars/clean.js
function clean3(ast, newNode) {
  if (ast.type === "TextNode") {
    const trimmed = ast.chars.trim();
    if (!trimmed) {
      return null;
    }
    newNode.chars = html_whitespace_utils_default.split(trimmed).join(" ");
  }
  if (ast.type === "AttrNode" && ast.name.toLowerCase() === "class") {
    delete newNode.value;
  }
}
clean3.ignoredProperties = /* @__PURE__ */ new Set(["loc", "selfClosing"]);
var clean_default3 = clean3;

// src/language-handlebars/html-void-elements.evaluate.js
var html_void_elements_evaluate_default = [
  "area",
  "base",
  "br",
  "col",
  "command",
  "embed",
  "hr",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
];

// src/language-handlebars/utils.js
function isUppercase(string) {
  return string.toUpperCase() === string;
}
function isGlimmerComponent(node) {
  return node.type === "ElementNode" && typeof node.tag === "string" && !node.tag.startsWith(":") && (isUppercase(node.tag[0]) || node.tag.includes("."));
}
var voidTags = new Set(html_void_elements_evaluate_default);
function isVoidTag(tag) {
  return voidTags.has(tag.toLowerCase()) && !isUppercase(tag[0]);
}
function isVoidElement(node) {
  return node.selfClosing === true || isVoidTag(node.tag) || isGlimmerComponent(node) && node.children.every((node2) => isWhitespaceNode(node2));
}
function isWhitespaceNode(node) {
  return node.type === "TextNode" && !/\S/.test(node.chars);
}
function isPrettierIgnoreNode(node) {
  return (node == null ? void 0 : node.type) === "MustacheCommentStatement" && typeof node.value === "string" && node.value.trim() === "prettier-ignore";
}
function hasPrettierIgnore2(path11) {
  return isPrettierIgnoreNode(path11.node) || path11.isInArray && (path11.key === "children" || path11.key === "body" || path11.key === "parts") && isPrettierIgnoreNode(path11.siblings[path11.index - 2]);
}

// src/language-handlebars/visitor-keys.evaluate.js
var visitor_keys_evaluate_default2 = {
  "Program": [
    "body"
  ],
  "Template": [
    "body"
  ],
  "Block": [
    "body"
  ],
  "MustacheStatement": [
    "path",
    "params",
    "hash"
  ],
  "BlockStatement": [
    "path",
    "params",
    "hash",
    "program",
    "inverse"
  ],
  "ElementModifierStatement": [
    "path",
    "params",
    "hash"
  ],
  "PartialStatement": [
    "name",
    "params",
    "hash"
  ],
  "CommentStatement": [],
  "MustacheCommentStatement": [],
  "ElementNode": [
    "attributes",
    "modifiers",
    "children",
    "comments"
  ],
  "AttrNode": [
    "value"
  ],
  "TextNode": [],
  "ConcatStatement": [
    "parts"
  ],
  "SubExpression": [
    "path",
    "params",
    "hash"
  ],
  "PathExpression": [],
  "PathHead": [],
  "StringLiteral": [],
  "BooleanLiteral": [],
  "NumberLiteral": [],
  "NullLiteral": [],
  "UndefinedLiteral": [],
  "Hash": [
    "pairs"
  ],
  "HashPair": [
    "value"
  ],
  "NamedBlock": [
    "attributes",
    "modifiers",
    "children",
    "comments"
  ],
  "SimpleElement": [
    "attributes",
    "modifiers",
    "children",
    "comments"
  ],
  "Component": [
    "head",
    "attributes",
    "modifiers",
    "children",
    "comments"
  ]
};

// src/language-handlebars/get-visitor-keys.js
var getVisitorKeys3 = create_get_visitor_keys_default(visitor_keys_evaluate_default2);
var get_visitor_keys_default3 = getVisitorKeys3;

// src/language-handlebars/printer-glimmer.js
var NEWLINES_TO_PRESERVE_MAX = 2;
function print3(path11, options9, print4) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i;
  const {
    node
  } = path11;
  const favoriteQuote = options9.singleQuote ? "'" : '"';
  switch (node.type) {
    case "Block":
    case "Program":
    case "Template":
      return group(path11.map(print4, "body"));
    case "ElementNode": {
      const startingTag = group(printStartingTag(path11, print4));
      const escapeNextElementNode = options9.htmlWhitespaceSensitivity === "ignore" && ((_a = path11.next) == null ? void 0 : _a.type) === "ElementNode" ? softline : "";
      if (isVoidElement(node)) {
        return [startingTag, escapeNextElementNode];
      }
      const endingTag = ["</", node.tag, ">"];
      if (node.children.length === 0) {
        return [startingTag, indent(endingTag), escapeNextElementNode];
      }
      if (options9.htmlWhitespaceSensitivity === "ignore") {
        return [startingTag, indent(printChildren(path11, options9, print4)), hardline, indent(endingTag), escapeNextElementNode];
      }
      return [startingTag, indent(group(printChildren(path11, options9, print4))), indent(endingTag), escapeNextElementNode];
    }
    case "BlockStatement":
      if (isElseIfLike(path11)) {
        return [printElseIfLikeBlock(path11, print4), printProgram(path11, print4, options9), printInverse(path11, print4, options9)];
      }
      return [printOpenBlock(path11, print4), group([printProgram(path11, print4, options9), printInverse(path11, print4, options9), printCloseBlock(path11, print4, options9)])];
    case "ElementModifierStatement":
      return group(["{{", printPathAndParams(path11, print4), "}}"]);
    case "MustacheStatement":
      return group([printOpeningMustache(node), printPathAndParams(path11, print4), printClosingMustache(node)]);
    case "SubExpression":
      return group(["(", printSubExpressionPathAndParams(path11, print4), softline, ")"]);
    case "AttrNode": {
      const {
        name,
        value
      } = node;
      const isText = value.type === "TextNode";
      const isEmptyText = isText && value.chars === "";
      if (isEmptyText && locStart3(value) === locEnd3(value)) {
        return name;
      }
      const quote = isText ? get_preferred_quote_default(value.chars, favoriteQuote).quote : value.type === "ConcatStatement" ? get_preferred_quote_default(value.parts.filter((part) => part.type === "TextNode").map((part) => part.chars).join(""), favoriteQuote).quote : "";
      const valueDoc = print4("value");
      return [name, "=", quote, name === "class" && quote ? group(indent(valueDoc)) : valueDoc, quote];
    }
    case "ConcatStatement":
      return path11.map(print4, "parts");
    case "Hash":
      return join(line, path11.map(print4, "pairs"));
    case "HashPair":
      return [node.key, "=", print4("value")];
    case "TextNode": {
      let text = string_replace_all_default(
        /* isOptionalObject*/
        false,
        node.chars,
        "{{",
        "\\{{"
      );
      const attrName = getCurrentAttributeName(path11);
      if (attrName) {
        if (attrName === "class") {
          const formattedClasses = text.trim().split(/\s+/).join(" ");
          let leadingSpace2 = false;
          let trailingSpace2 = false;
          if (path11.parent.type === "ConcatStatement") {
            if (((_b = path11.previous) == null ? void 0 : _b.type) === "MustacheStatement" && /^\s/.test(text)) {
              leadingSpace2 = true;
            }
            if (((_c = path11.next) == null ? void 0 : _c.type) === "MustacheStatement" && /\s$/.test(text) && formattedClasses !== "") {
              trailingSpace2 = true;
            }
          }
          return [leadingSpace2 ? line : "", formattedClasses, trailingSpace2 ? line : ""];
        }
        return replaceEndOfLine(text);
      }
      const isWhitespaceOnly = html_whitespace_utils_default.isWhitespaceOnly(text);
      const {
        isFirst,
        isLast
      } = path11;
      if (options9.htmlWhitespaceSensitivity !== "ignore") {
        const shouldTrimTrailingNewlines = isLast && path11.parent.type === "Template";
        const shouldTrimLeadingNewlines = isFirst && path11.parent.type === "Template";
        if (isWhitespaceOnly) {
          if (shouldTrimLeadingNewlines || shouldTrimTrailingNewlines) {
            return "";
          }
          let breaks = [line];
          const newlines = countNewLines(text);
          if (newlines) {
            breaks = generateHardlines(newlines);
          }
          if (isLast) {
            breaks = breaks.map((newline) => dedent(newline));
          }
          return breaks;
        }
        const leadingWhitespace = html_whitespace_utils_default.getLeadingWhitespace(text);
        let leadBreaks = [];
        if (leadingWhitespace) {
          leadBreaks = [line];
          const leadingNewlines = countNewLines(leadingWhitespace);
          if (leadingNewlines) {
            leadBreaks = generateHardlines(leadingNewlines);
          }
          text = text.slice(leadingWhitespace.length);
        }
        const tailingWhitespace = html_whitespace_utils_default.getTrailingWhitespace(text);
        let trailBreaks = [];
        if (tailingWhitespace) {
          if (!shouldTrimTrailingNewlines) {
            trailBreaks = [line];
            const trailingNewlines = countNewLines(tailingWhitespace);
            if (trailingNewlines) {
              trailBreaks = generateHardlines(trailingNewlines);
            }
            if (isLast) {
              trailBreaks = trailBreaks.map((hardline2) => dedent(hardline2));
            }
          }
          text = text.slice(0, -tailingWhitespace.length);
        }
        return [...leadBreaks, fill(getTextValueParts(text)), ...trailBreaks];
      }
      const lineBreaksCount = countNewLines(text);
      let leadingLineBreaksCount = countLeadingNewLines(text);
      let trailingLineBreaksCount = countTrailingNewLines(text);
      if ((isFirst || isLast) && isWhitespaceOnly && (path11.parent.type === "Block" || path11.parent.type === "ElementNode" || path11.parent.type === "Template")) {
        return "";
      }
      if (isWhitespaceOnly && lineBreaksCount) {
        leadingLineBreaksCount = Math.min(lineBreaksCount, NEWLINES_TO_PRESERVE_MAX);
        trailingLineBreaksCount = 0;
      } else {
        if (((_d = path11.next) == null ? void 0 : _d.type) === "BlockStatement" || ((_e = path11.next) == null ? void 0 : _e.type) === "ElementNode") {
          trailingLineBreaksCount = Math.max(trailingLineBreaksCount, 1);
        }
        if (((_f = path11.previous) == null ? void 0 : _f.type) === "BlockStatement" || ((_g = path11.previous) == null ? void 0 : _g.type) === "ElementNode") {
          leadingLineBreaksCount = Math.max(leadingLineBreaksCount, 1);
        }
      }
      let leadingSpace = "";
      let trailingSpace = "";
      if (trailingLineBreaksCount === 0 && ((_h = path11.next) == null ? void 0 : _h.type) === "MustacheStatement") {
        trailingSpace = " ";
      }
      if (leadingLineBreaksCount === 0 && ((_i = path11.previous) == null ? void 0 : _i.type) === "MustacheStatement") {
        leadingSpace = " ";
      }
      if (isFirst) {
        leadingLineBreaksCount = 0;
        leadingSpace = "";
      }
      if (isLast) {
        trailingLineBreaksCount = 0;
        trailingSpace = "";
      }
      if (html_whitespace_utils_default.hasLeadingWhitespace(text)) {
        text = leadingSpace + html_whitespace_utils_default.trimStart(text);
      }
      if (html_whitespace_utils_default.hasTrailingWhitespace(text)) {
        text = html_whitespace_utils_default.trimEnd(text) + trailingSpace;
      }
      return [...generateHardlines(leadingLineBreaksCount), fill(getTextValueParts(text)), ...generateHardlines(trailingLineBreaksCount)];
    }
    case "MustacheCommentStatement": {
      const start = locStart3(node);
      const end = locEnd3(node);
      const isLeftWhiteSpaceSensitive = options9.originalText.charAt(start + 2) === "~";
      const isRightWhitespaceSensitive = options9.originalText.charAt(end - 3) === "~";
      const dashes = node.value.includes("}}") ? "--" : "";
      return ["{{", isLeftWhiteSpaceSensitive ? "~" : "", "!", dashes, node.value, dashes, isRightWhitespaceSensitive ? "~" : "", "}}"];
    }
    case "PathExpression":
      return node.original;
    case "BooleanLiteral":
      return String(node.value);
    case "CommentStatement":
      return ["<!--", node.value, "-->"];
    case "StringLiteral":
      if (needsOppositeQuote(path11)) {
        const printFavoriteQuote = !options9.singleQuote ? "'" : '"';
        return printStringLiteral(node.value, printFavoriteQuote);
      }
      return printStringLiteral(node.value, favoriteQuote);
    case "NumberLiteral":
      return String(node.value);
    case "UndefinedLiteral":
      return "undefined";
    case "NullLiteral":
      return "null";
    default:
      throw new unexpected_node_error_default(node, "Handlebars");
  }
}
function sortByLoc(a, b) {
  return locStart3(a) - locStart3(b);
}
function printStartingTag(path11, print4) {
  const {
    node
  } = path11;
  const types = ["attributes", "modifiers", "comments"].filter((property) => is_non_empty_array_default(node[property]));
  const attributes = types.flatMap((type) => node[type]).sort(sortByLoc);
  for (const attributeType of types) {
    path11.each(({
      node: node2
    }) => {
      const index = attributes.indexOf(node2);
      attributes.splice(index, 1, [line, print4()]);
    }, attributeType);
  }
  if (is_non_empty_array_default(node.blockParams)) {
    attributes.push(line, printBlockParams(node));
  }
  return ["<", node.tag, indent(attributes), printStartingTagEndMarker(node)];
}
function printChildren(path11, options9, print4) {
  const {
    node
  } = path11;
  const isEmpty = node.children.every((node2) => isWhitespaceNode(node2));
  if (options9.htmlWhitespaceSensitivity === "ignore" && isEmpty) {
    return "";
  }
  return path11.map(({
    isFirst
  }) => {
    const printedChild = print4();
    if (isFirst && options9.htmlWhitespaceSensitivity === "ignore") {
      return [softline, printedChild];
    }
    return printedChild;
  }, "children");
}
function printStartingTagEndMarker(node) {
  if (isVoidElement(node)) {
    return ifBreak([softline, "/>"], [" />", softline]);
  }
  return ifBreak([softline, ">"], ">");
}
function printOpeningMustache(node) {
  var _a;
  const mustache = node.escaped === false ? "{{{" : "{{";
  const strip2 = ((_a = node.strip) == null ? void 0 : _a.open) ? "~" : "";
  return [mustache, strip2];
}
function printClosingMustache(node) {
  var _a;
  const mustache = node.escaped === false ? "}}}" : "}}";
  const strip2 = ((_a = node.strip) == null ? void 0 : _a.close) ? "~" : "";
  return [strip2, mustache];
}
function printOpeningBlockOpeningMustache(node) {
  const opening = printOpeningMustache(node);
  const strip2 = node.openStrip.open ? "~" : "";
  return [opening, strip2, "#"];
}
function printOpeningBlockClosingMustache(node) {
  const closing = printClosingMustache(node);
  const strip2 = node.openStrip.close ? "~" : "";
  return [strip2, closing];
}
function printClosingBlockOpeningMustache(node) {
  const opening = printOpeningMustache(node);
  const strip2 = node.closeStrip.open ? "~" : "";
  return [opening, strip2, "/"];
}
function printClosingBlockClosingMustache(node) {
  const closing = printClosingMustache(node);
  const strip2 = node.closeStrip.close ? "~" : "";
  return [strip2, closing];
}
function printInverseBlockOpeningMustache(node) {
  const opening = printOpeningMustache(node);
  const strip2 = node.inverseStrip.open ? "~" : "";
  return [opening, strip2];
}
function printInverseBlockClosingMustache(node) {
  const closing = printClosingMustache(node);
  const strip2 = node.inverseStrip.close ? "~" : "";
  return [strip2, closing];
}
function printOpenBlock(path11, print4) {
  const {
    node
  } = path11;
  const parts = [];
  const paramsDoc = printParams(path11, print4);
  if (paramsDoc) {
    parts.push(group(paramsDoc));
  }
  if (is_non_empty_array_default(node.program.blockParams)) {
    parts.push(printBlockParams(node.program));
  }
  return group([printOpeningBlockOpeningMustache(node), printPath(path11, print4), parts.length > 0 ? indent([line, join(line, parts)]) : "", softline, printOpeningBlockClosingMustache(node)]);
}
function printElseBlock(node, options9) {
  return [options9.htmlWhitespaceSensitivity === "ignore" ? hardline : "", printInverseBlockOpeningMustache(node), "else", printInverseBlockClosingMustache(node)];
}
function isElseIfLike(path11) {
  var _a;
  const {
    grandparent,
    node
  } = path11;
  return ((_a = grandparent == null ? void 0 : grandparent.inverse) == null ? void 0 : _a.body.length) === 1 && grandparent.inverse.body[0] === node && grandparent.inverse.body[0].path.parts[0] === grandparent.path.parts[0];
}
function printElseIfLikeBlock(path11, print4) {
  const {
    node,
    grandparent
  } = path11;
  return group([printInverseBlockOpeningMustache(grandparent), ["else", " ", grandparent.inverse.body[0].path.parts[0]], indent([line, group(printParams(path11, print4)), ...is_non_empty_array_default(node.program.blockParams) ? [line, printBlockParams(node.program)] : []]), softline, printInverseBlockClosingMustache(grandparent)]);
}
function printCloseBlock(path11, print4, options9) {
  const {
    node
  } = path11;
  if (options9.htmlWhitespaceSensitivity === "ignore") {
    const escape = blockStatementHasOnlyWhitespaceInProgram(node) ? softline : hardline;
    return [escape, printClosingBlockOpeningMustache(node), print4("path"), printClosingBlockClosingMustache(node)];
  }
  return [printClosingBlockOpeningMustache(node), print4("path"), printClosingBlockClosingMustache(node)];
}
function blockStatementHasOnlyWhitespaceInProgram(node) {
  return node.type === "BlockStatement" && node.program.body.every((node2) => isWhitespaceNode(node2));
}
function blockStatementHasElseIfLike(node) {
  return blockStatementHasElse(node) && node.inverse.body.length === 1 && node.inverse.body[0].type === "BlockStatement" && node.inverse.body[0].path.parts[0] === node.path.parts[0];
}
function blockStatementHasElse(node) {
  return node.type === "BlockStatement" && node.inverse;
}
function printProgram(path11, print4, options9) {
  const {
    node
  } = path11;
  if (blockStatementHasOnlyWhitespaceInProgram(node)) {
    return "";
  }
  const program = print4("program");
  if (options9.htmlWhitespaceSensitivity === "ignore") {
    return indent([hardline, program]);
  }
  return indent(program);
}
function printInverse(path11, print4, options9) {
  const {
    node
  } = path11;
  const inverse = print4("inverse");
  const printed = options9.htmlWhitespaceSensitivity === "ignore" ? [hardline, inverse] : inverse;
  if (blockStatementHasElseIfLike(node)) {
    return printed;
  }
  if (blockStatementHasElse(node)) {
    return [printElseBlock(node, options9), indent(printed)];
  }
  return "";
}
function getTextValueParts(value) {
  return join(line, html_whitespace_utils_default.split(value));
}
function getCurrentAttributeName(path11) {
  for (let depth = 0; depth < 2; depth++) {
    const parentNode = path11.getParentNode(depth);
    if ((parentNode == null ? void 0 : parentNode.type) === "AttrNode") {
      return parentNode.name.toLowerCase();
    }
  }
}
function countNewLines(string) {
  string = typeof string === "string" ? string : "";
  return string.split("\n").length - 1;
}
function countLeadingNewLines(string) {
  string = typeof string === "string" ? string : "";
  const newLines = (string.match(/^([^\S\n\r]*[\n\r])+/g) || [])[0] || "";
  return countNewLines(newLines);
}
function countTrailingNewLines(string) {
  string = typeof string === "string" ? string : "";
  const newLines = (string.match(/([\n\r][^\S\n\r]*)+$/g) || [])[0] || "";
  return countNewLines(newLines);
}
function generateHardlines(number = 0) {
  return Array.from({
    length: Math.min(number, NEWLINES_TO_PRESERVE_MAX)
  }).fill(hardline);
}
function printStringLiteral(stringLiteral, favoriteQuote) {
  const {
    quote,
    regex
  } = get_preferred_quote_default(stringLiteral, favoriteQuote);
  return [quote, stringLiteral.replace(regex, `\\${quote}`), quote];
}
function needsOppositeQuote(path11) {
  const {
    ancestors
  } = path11;
  const level = ancestors.findIndex((node) => node.type !== "SubExpression");
  return level !== -1 && ancestors[level + 1].type === "ConcatStatement" && ancestors[level + 2].type === "AttrNode";
}
function printSubExpressionPathAndParams(path11, print4) {
  const printed = printPath(path11, print4);
  const params = printParams(path11, print4);
  if (!params) {
    return printed;
  }
  return indent([printed, line, group(params)]);
}
function printPathAndParams(path11, print4) {
  const pathDoc = printPath(path11, print4);
  const paramsDoc = printParams(path11, print4);
  if (!paramsDoc) {
    return pathDoc;
  }
  return [indent([pathDoc, line, paramsDoc]), softline];
}
function printPath(path11, print4) {
  return print4("path");
}
function printParams(path11, print4) {
  var _a;
  const {
    node
  } = path11;
  const parts = [];
  if (node.params.length > 0) {
    parts.push(...path11.map(print4, "params"));
  }
  if (((_a = node.hash) == null ? void 0 : _a.pairs.length) > 0) {
    parts.push(print4("hash"));
  }
  if (parts.length === 0) {
    return "";
  }
  return join(line, parts);
}
function printBlockParams(node) {
  return ["as |", node.blockParams.join(" "), "|"];
}
var printer4 = {
  print: print3,
  massageAstNode: clean_default3,
  hasPrettierIgnore: hasPrettierIgnore2,
  getVisitorKeys: get_visitor_keys_default3
};
var printer_glimmer_default = printer4;

// src/language-handlebars/languages.evaluate.js
var languages_evaluate_default3 = [
  {
    "linguistLanguageId": 155,
    "name": "Handlebars",
    "type": "markup",
    "color": "#f7931e",
    "aliases": [
      "hbs",
      "htmlbars"
    ],
    "extensions": [
      ".handlebars",
      ".hbs"
    ],
    "tmScope": "text.html.handlebars",
    "aceMode": "handlebars",
    "parsers": [
      "glimmer"
    ],
    "vscodeLanguageIds": [
      "handlebars"
    ]
  }
];

// src/language-handlebars/index.js
var printers3 = {
  glimmer: printer_glimmer_default
};
var parsers6 = create_parsers_default(parsers_default3);

// src/language-graphql/index.js
var language_graphql_exports = {};
__export(language_graphql_exports, {
  languages: () => languages_evaluate_default4,
  options: () => options_default3,
  parsers: () => parsers8,
  printers: () => printers4
});

// src/language-graphql/parsers.js
var parsers7 = [
  {
    importPlugin: () => import("./plugins/graphql.mjs"),
    parserNames: ["graphql"]
  }
];
var parsers_default4 = parsers7;

// src/language-graphql/pragma.js
function insertPragma3(text) {
  return "# @format\n\n" + text;
}

// src/language-graphql/loc.js
function locStart4(nodeOrToken) {
  return nodeOrToken.kind === "Comment" ? nodeOrToken.start : nodeOrToken.loc.start;
}
function locEnd4(nodeOrToken) {
  return nodeOrToken.kind === "Comment" ? nodeOrToken.end : nodeOrToken.loc.end;
}

// src/language-graphql/visitor-keys.evaluate.js
var visitor_keys_evaluate_default3 = {
  "Name": [],
  "Document": [
    "definitions"
  ],
  "OperationDefinition": [
    "name",
    "variableDefinitions",
    "directives",
    "selectionSet"
  ],
  "VariableDefinition": [
    "variable",
    "type",
    "defaultValue",
    "directives"
  ],
  "Variable": [
    "name"
  ],
  "SelectionSet": [
    "selections"
  ],
  "Field": [
    "alias",
    "name",
    "arguments",
    "directives",
    "selectionSet"
  ],
  "Argument": [
    "name",
    "value"
  ],
  "FragmentSpread": [
    "name",
    "directives"
  ],
  "InlineFragment": [
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  "FragmentDefinition": [
    "name",
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  "IntValue": [],
  "FloatValue": [],
  "StringValue": [],
  "BooleanValue": [],
  "NullValue": [],
  "EnumValue": [],
  "ListValue": [
    "values"
  ],
  "ObjectValue": [
    "fields"
  ],
  "ObjectField": [
    "name",
    "value"
  ],
  "Directive": [
    "name",
    "arguments"
  ],
  "NamedType": [
    "name"
  ],
  "ListType": [
    "type"
  ],
  "NonNullType": [
    "type"
  ],
  "SchemaDefinition": [
    "description",
    "directives",
    "operationTypes"
  ],
  "OperationTypeDefinition": [
    "type"
  ],
  "ScalarTypeDefinition": [
    "description",
    "name",
    "directives"
  ],
  "ObjectTypeDefinition": [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  "FieldDefinition": [
    "description",
    "name",
    "arguments",
    "type",
    "directives"
  ],
  "InputValueDefinition": [
    "description",
    "name",
    "type",
    "defaultValue",
    "directives"
  ],
  "InterfaceTypeDefinition": [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  "UnionTypeDefinition": [
    "description",
    "name",
    "directives",
    "types"
  ],
  "EnumTypeDefinition": [
    "description",
    "name",
    "directives",
    "values"
  ],
  "EnumValueDefinition": [
    "description",
    "name",
    "directives"
  ],
  "InputObjectTypeDefinition": [
    "description",
    "name",
    "directives",
    "fields"
  ],
  "DirectiveDefinition": [
    "description",
    "name",
    "arguments",
    "locations"
  ],
  "SchemaExtension": [
    "directives",
    "operationTypes"
  ],
  "ScalarTypeExtension": [
    "name",
    "directives"
  ],
  "ObjectTypeExtension": [
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  "InterfaceTypeExtension": [
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  "UnionTypeExtension": [
    "name",
    "directives",
    "types"
  ],
  "EnumTypeExtension": [
    "name",
    "directives",
    "values"
  ],
  "InputObjectTypeExtension": [
    "name",
    "directives",
    "fields"
  ]
};

// src/language-graphql/get-visitor-keys.js
var getVisitorKeys4 = create_get_visitor_keys_default(visitor_keys_evaluate_default3, "kind");
var get_visitor_keys_default4 = getVisitorKeys4;

// src/language-graphql/print/description.js
function printDescription(path11, options9, print4) {
  const { node } = path11;
  if (!node.description) {
    return "";
  }
  const parts = [print4("description")];
  if (node.kind === "InputValueDefinition" && !node.description.block) {
    parts.push(line);
  } else {
    parts.push(hardline);
  }
  return parts;
}
var description_default = printDescription;

// src/language-graphql/printer-graphql.js
function genericPrint3(path11, options9, print4) {
  const {
    node
  } = path11;
  switch (node.kind) {
    case "Document":
      return [...join(hardline, printSequence(path11, options9, print4, "definitions")), hardline];
    case "OperationDefinition": {
      const hasOperation = options9.originalText[locStart4(node)] !== "{";
      const hasName = Boolean(node.name);
      return [hasOperation ? node.operation : "", hasOperation && hasName ? [" ", print4("name")] : "", hasOperation && !hasName && is_non_empty_array_default(node.variableDefinitions) ? " " : "", printVariableDefinitions(path11, print4), printDirectives(path11, print4, node), !hasOperation && !hasName ? "" : " ", print4("selectionSet")];
    }
    case "FragmentDefinition":
      return ["fragment ", print4("name"), printVariableDefinitions(path11, print4), " on ", print4("typeCondition"), printDirectives(path11, print4, node), " ", print4("selectionSet")];
    case "SelectionSet":
      return ["{", indent([hardline, join(hardline, printSequence(path11, options9, print4, "selections"))]), hardline, "}"];
    case "Field":
      return group([node.alias ? [print4("alias"), ": "] : "", print4("name"), node.arguments.length > 0 ? group(["(", indent([softline, join([ifBreak("", ", "), softline], printSequence(path11, options9, print4, "arguments"))]), softline, ")"]) : "", printDirectives(path11, print4, node), node.selectionSet ? " " : "", print4("selectionSet")]);
    case "Name":
      return node.value;
    case "StringValue":
      if (node.block) {
        const lines = string_replace_all_default(
          /* isOptionalObject*/
          false,
          node.value,
          '"""',
          '\\"""'
        ).split("\n");
        if (lines.length === 1) {
          lines[0] = lines[0].trim();
        }
        if (lines.every((line2) => line2 === "")) {
          lines.length = 0;
        }
        return join(hardline, ['"""', ...lines, '"""']);
      }
      return ['"', string_replace_all_default(
        /* isOptionalObject*/
        false,
        string_replace_all_default(
          /* isOptionalObject*/
          false,
          node.value,
          /["\\]/g,
          "\\$&"
        ),
        "\n",
        "\\n"
      ), '"'];
    case "IntValue":
    case "FloatValue":
    case "EnumValue":
      return node.value;
    case "BooleanValue":
      return node.value ? "true" : "false";
    case "NullValue":
      return "null";
    case "Variable":
      return ["$", print4("name")];
    case "ListValue":
      return group(["[", indent([softline, join([ifBreak("", ", "), softline], path11.map(print4, "values"))]), softline, "]"]);
    case "ObjectValue": {
      const bracketSpace = options9.bracketSpacing && node.fields.length > 0 ? " " : "";
      return group(["{", bracketSpace, indent([softline, join([ifBreak("", ", "), softline], path11.map(print4, "fields"))]), softline, ifBreak("", bracketSpace), "}"]);
    }
    case "ObjectField":
    case "Argument":
      return [print4("name"), ": ", print4("value")];
    case "Directive":
      return ["@", print4("name"), node.arguments.length > 0 ? group(["(", indent([softline, join([ifBreak("", ", "), softline], printSequence(path11, options9, print4, "arguments"))]), softline, ")"]) : ""];
    case "NamedType":
      return print4("name");
    case "VariableDefinition":
      return [print4("variable"), ": ", print4("type"), node.defaultValue ? [" = ", print4("defaultValue")] : "", printDirectives(path11, print4, node)];
    case "ObjectTypeExtension":
    case "ObjectTypeDefinition":
    case "InputObjectTypeExtension":
    case "InputObjectTypeDefinition":
    case "InterfaceTypeExtension":
    case "InterfaceTypeDefinition": {
      const {
        kind
      } = node;
      const parts = [];
      if (kind.endsWith("TypeDefinition")) {
        parts.push(description_default(path11, options9, print4));
      } else {
        parts.push("extend ");
      }
      if (kind.startsWith("ObjectType")) {
        parts.push("type");
      } else if (kind.startsWith("InputObjectType")) {
        parts.push("input");
      } else {
        parts.push("interface");
      }
      parts.push(" ", print4("name"));
      if (!kind.startsWith("InputObjectType") && node.interfaces.length > 0) {
        parts.push(" implements ", ...printInterfaces(path11, options9, print4));
      }
      parts.push(printDirectives(path11, print4, node));
      if (node.fields.length > 0) {
        parts.push([" {", indent([hardline, join(hardline, printSequence(path11, options9, print4, "fields"))]), hardline, "}"]);
      }
      return parts;
    }
    case "FieldDefinition":
      return [description_default(path11, options9, print4), print4("name"), node.arguments.length > 0 ? group(["(", indent([softline, join([ifBreak("", ", "), softline], printSequence(path11, options9, print4, "arguments"))]), softline, ")"]) : "", ": ", print4("type"), printDirectives(path11, print4, node)];
    case "DirectiveDefinition":
      return [description_default(path11, options9, print4), "directive ", "@", print4("name"), node.arguments.length > 0 ? group(["(", indent([softline, join([ifBreak("", ", "), softline], printSequence(path11, options9, print4, "arguments"))]), softline, ")"]) : "", node.repeatable ? " repeatable" : "", " on ", ...join(" | ", path11.map(print4, "locations"))];
    case "EnumTypeExtension":
    case "EnumTypeDefinition":
      return [description_default(path11, options9, print4), node.kind === "EnumTypeExtension" ? "extend " : "", "enum ", print4("name"), printDirectives(path11, print4, node), node.values.length > 0 ? [" {", indent([hardline, join(hardline, printSequence(path11, options9, print4, "values"))]), hardline, "}"] : ""];
    case "EnumValueDefinition":
      return [description_default(path11, options9, print4), print4("name"), printDirectives(path11, print4, node)];
    case "InputValueDefinition":
      return [description_default(path11, options9, print4), print4("name"), ": ", print4("type"), node.defaultValue ? [" = ", print4("defaultValue")] : "", printDirectives(path11, print4, node)];
    case "SchemaExtension":
      return ["extend schema", printDirectives(path11, print4, node), ...node.operationTypes.length > 0 ? [" {", indent([hardline, join(hardline, printSequence(path11, options9, print4, "operationTypes"))]), hardline, "}"] : []];
    case "SchemaDefinition":
      return [description_default(path11, options9, print4), "schema", printDirectives(path11, print4, node), " {", node.operationTypes.length > 0 ? indent([hardline, join(hardline, printSequence(path11, options9, print4, "operationTypes"))]) : "", hardline, "}"];
    case "OperationTypeDefinition":
      return [node.operation, ": ", print4("type")];
    case "FragmentSpread":
      return ["...", print4("name"), printDirectives(path11, print4, node)];
    case "InlineFragment":
      return ["...", node.typeCondition ? [" on ", print4("typeCondition")] : "", printDirectives(path11, print4, node), " ", print4("selectionSet")];
    case "UnionTypeExtension":
    case "UnionTypeDefinition":
      return group([description_default(path11, options9, print4), group([node.kind === "UnionTypeExtension" ? "extend " : "", "union ", print4("name"), printDirectives(path11, print4, node), node.types.length > 0 ? [" =", ifBreak("", " "), indent([ifBreak([line, "  "]), join([line, "| "], path11.map(print4, "types"))])] : ""])]);
    case "ScalarTypeExtension":
    case "ScalarTypeDefinition":
      return [description_default(path11, options9, print4), node.kind === "ScalarTypeExtension" ? "extend " : "", "scalar ", print4("name"), printDirectives(path11, print4, node)];
    case "NonNullType":
      return [print4("type"), "!"];
    case "ListType":
      return ["[", print4("type"), "]"];
    default:
      throw new unexpected_node_error_default(node, "Graphql", "kind");
  }
}
function printDirectives(path11, print4, node) {
  if (node.directives.length === 0) {
    return "";
  }
  const printed = join(line, path11.map(print4, "directives"));
  if (node.kind === "FragmentDefinition" || node.kind === "OperationDefinition") {
    return group([line, printed]);
  }
  return [" ", group(indent([softline, printed]))];
}
function printSequence(path11, options9, print4, property) {
  return path11.map(({
    isLast,
    node
  }) => {
    const printed = print4();
    if (!isLast && is_next_line_empty_default(options9.originalText, locEnd4(node))) {
      return [printed, hardline];
    }
    return printed;
  }, property);
}
function canAttachComment2(node) {
  return node.kind !== "Comment";
}
function printComment3(commentPath) {
  const comment = commentPath.node;
  if (comment.kind === "Comment") {
    return "#" + comment.value.trimEnd();
  }
  throw new Error("Not a comment: " + JSON.stringify(comment));
}
function printInterfaces(path11, options9, print4) {
  const {
    node
  } = path11;
  const parts = [];
  const {
    interfaces
  } = node;
  const printed = path11.map(print4, "interfaces");
  for (let index = 0; index < interfaces.length; index++) {
    const interfaceNode = interfaces[index];
    parts.push(printed[index]);
    const nextInterfaceNode = interfaces[index + 1];
    if (nextInterfaceNode) {
      const textBetween = options9.originalText.slice(interfaceNode.loc.end, nextInterfaceNode.loc.start);
      const hasComment2 = textBetween.includes("#");
      parts.push(" &", hasComment2 ? line : " ");
    }
  }
  return parts;
}
function printVariableDefinitions(path11, print4) {
  const {
    node
  } = path11;
  if (!is_non_empty_array_default(node.variableDefinitions)) {
    return "";
  }
  return group(["(", indent([softline, join([ifBreak("", ", "), softline], path11.map(print4, "variableDefinitions"))]), softline, ")"]);
}
function clean4(node, newNode) {
  if (node.kind === "StringValue" && node.block && !node.value.includes("\n")) {
    newNode.value = newNode.value.trim();
  }
}
clean4.ignoredProperties = /* @__PURE__ */ new Set(["loc", "comments"]);
function hasPrettierIgnore3(path11) {
  var _a;
  const {
    node
  } = path11;
  return (_a = node == null ? void 0 : node.comments) == null ? void 0 : _a.some((comment) => comment.value.trim() === "prettier-ignore");
}
var printer5 = {
  print: genericPrint3,
  massageAstNode: clean4,
  hasPrettierIgnore: hasPrettierIgnore3,
  insertPragma: insertPragma3,
  printComment: printComment3,
  canAttachComment: canAttachComment2,
  getVisitorKeys: get_visitor_keys_default4
};
var printer_graphql_default = printer5;

// src/language-graphql/languages.evaluate.js
var languages_evaluate_default4 = [
  {
    "linguistLanguageId": 139,
    "name": "GraphQL",
    "type": "data",
    "color": "#e10098",
    "extensions": [
      ".graphql",
      ".gql",
      ".graphqls"
    ],
    "tmScope": "source.graphql",
    "aceMode": "text",
    "parsers": [
      "graphql"
    ],
    "vscodeLanguageIds": [
      "graphql"
    ]
  }
];

// src/language-graphql/options.js
var options5 = {
  bracketSpacing: common_options_default.bracketSpacing
};
var options_default3 = options5;

// src/language-graphql/index.js
var printers4 = {
  graphql: printer_graphql_default
};
var parsers8 = create_parsers_default(parsers_default4);

// src/language-markdown/index.js
var language_markdown_exports = {};
__export(language_markdown_exports, {
  languages: () => languages_evaluate_default5,
  options: () => options_default4,
  parsers: () => parsers10,
  printers: () => printers5
});

// src/language-markdown/parsers.js
var parsers9 = [
  {
    importPlugin: () => import("./plugins/markdown.mjs"),
    parserNames: ["remark", "markdown", "mdx"]
  }
];
var parsers_default5 = parsers9;

// src/language-markdown/printer-markdown.js
var import_collapse_white_space2 = __toESM(require_collapse_white_space(), 1);

// src/utils/get-min-not-present-continuous-count.js
function getMinNotPresentContinuousCount(text, searchString) {
  const matches = text.match(
    new RegExp(`(${escapeStringRegexp(searchString)})+`, "g")
  );
  if (matches === null) {
    return 0;
  }
  const countPresent = /* @__PURE__ */ new Map();
  let max = 0;
  for (const match of matches) {
    const count = match.length / searchString.length;
    countPresent.set(count, true);
    if (count > max) {
      max = count;
    }
  }
  for (let i = 1; i < max; i++) {
    if (!countPresent.get(i)) {
      return i;
    }
  }
  return max + 1;
}
var get_min_not_present_continuous_count_default = getMinNotPresentContinuousCount;

// src/utils/get-max-continuous-count.js
function getMaxContinuousCount(text, searchString) {
  const results = text.match(
    new RegExp(`(${escapeStringRegexp(searchString)})+`, "g")
  );
  if (results === null) {
    return 0;
  }
  return results.reduce(
    (maxCount, result) => Math.max(maxCount, result.length / searchString.length),
    0
  );
}
var get_max_continuous_count_default = getMaxContinuousCount;

// src/utils/infer-parser-by-language.js
function inferParserByLanguage(language, options9) {
  const { languages } = getSupportInfo({ plugins: options9.plugins });
  const matched = languages.find(({ name }) => name.toLowerCase() === language) ?? languages.find(({ aliases }) => aliases == null ? void 0 : aliases.includes(language)) ?? languages.find(({ extensions }) => extensions == null ? void 0 : extensions.includes(`.${language}`));
  return matched == null ? void 0 : matched.parsers[0];
}
var infer_parser_by_language_default = inferParserByLanguage;

// src/language-markdown/loc.js
function locStart5(node) {
  return node.position.start.offset;
}
function locEnd5(node) {
  return node.position.end.offset;
}

// src/language-markdown/constants.evaluate.js
var cjkPattern = "(?:[\\u02ea-\\u02eb\\u1100-\\u11ff\\u2e80-\\u2e99\\u2e9b-\\u2ef3\\u2f00-\\u2fd5\\u2ff0-\\u303f\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u3190-\\u3191\\u3196-\\u31ba\\u31c0-\\u31e3\\u31f0-\\u321e\\u322a-\\u3247\\u3260-\\u327e\\u328a-\\u32b0\\u32c0-\\u32cb\\u32d0-\\u3370\\u337b-\\u337f\\u33e0-\\u33fe\\u3400-\\u4db5\\u4e00-\\u9fef\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufe10-\\ufe1f\\ufe30-\\ufe6f\\uff00-\\uffef]|[\\ud840-\\ud868\\ud86a-\\ud86c\\ud86f-\\ud872\\ud874-\\ud879][\\udc00-\\udfff]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67]|\\ud83c[\\ude00\\ude50-\\ude51]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d])(?:[\\ufe00-\\ufe0f]|\\udb40[\\udd00-\\uddef])?";
var kRegex = new RegExp("[\\u1100-\\u11ff\\u3001-\\u3003\\u3008-\\u3011\\u3013-\\u301f\\u302e-\\u3030\\u3037\\u30fb\\u3131-\\u318e\\u3200-\\u321e\\u3260-\\u327e\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\ufe45-\\ufe46\\uff61-\\uff65\\uffa0-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]", "");
var punctuationPattern = "[\\u0021-\\u002f\\u003a-\\u0040\\u005b-\\u0060\\u007b-\\u007e\\u00a1\\u00a7\\u00ab\\u00b6-\\u00b7\\u00bb\\u00bf\\u037e\\u0387\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0830-\\u083e\\u085e\\u0964-\\u0965\\u0970\\u09fd\\u0a76\\u0af0\\u0c77\\u0c84\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f14\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u0fd9-\\u0fda\\u104a-\\u104f\\u10fb\\u1360-\\u1368\\u1400\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u1a1e-\\u1a1f\\u1aa0-\\u1aa6\\u1aa8-\\u1aad\\u1b5a-\\u1b60\\u1bfc-\\u1bff\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u1cc0-\\u1cc7\\u1cd3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205e\\u207d-\\u207e\\u208d-\\u208e\\u2308-\\u230b\\u2329-\\u232a\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2d70\\u2e00-\\u2e2e\\u2e30-\\u2e4f\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301f\\u3030\\u303d\\u30a0\\u30fb\\ua4fe-\\ua4ff\\ua60d-\\ua60f\\ua673\\ua67e\\ua6f2-\\ua6f7\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua8f8-\\ua8fa\\ua8fc\\ua92e-\\ua92f\\ua95f\\ua9c1-\\ua9cd\\ua9de-\\ua9df\\uaa5c-\\uaa5f\\uaade-\\uaadf\\uaaf0-\\uaaf1\\uabeb\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\\ud800[\\udd00-\\udd02\\udf9f\\udfd0]|\\ud801[\\udd6f]|\\ud802[\\udc57\\udd1f\\udd3f\\ude50-\\ude58\\ude7f\\udef0-\\udef6\\udf39-\\udf3f\\udf99-\\udf9c]|\\ud803[\\udf55-\\udf59]|\\ud804[\\udc47-\\udc4d\\udcbb-\\udcbc\\udcbe-\\udcc1\\udd40-\\udd43\\udd74-\\udd75\\uddc5-\\uddc8\\uddcd\\udddb\\udddd-\\udddf\\ude38-\\ude3d\\udea9]|\\ud805[\\udc4b-\\udc4f\\udc5b\\udc5d\\udcc6\\uddc1-\\uddd7\\ude41-\\ude43\\ude60-\\ude6c\\udf3c-\\udf3e]|\\ud806[\\udc3b\\udde2\\ude3f-\\ude46\\ude9a-\\ude9c\\ude9e-\\udea2]|\\ud807[\\udc41-\\udc45\\udc70-\\udc71\\udef7-\\udef8\\udfff]|\\ud809[\\udc70-\\udc74]|\\ud81a[\\ude6e-\\ude6f\\udef5\\udf37-\\udf3b\\udf44]|\\ud81b[\\ude97-\\ude9a\\udfe2]|\\ud82f[\\udc9f]|\\ud836[\\ude87-\\ude8b]|\\ud83a[\\udd5e-\\udd5f]";

// src/language-markdown/utils.js
var INLINE_NODE_TYPES = /* @__PURE__ */ new Set(["liquidNode", "inlineCode", "emphasis", "esComment", "strong", "delete", "wikiLink", "link", "linkReference", "image", "imageReference", "footnote", "footnoteReference", "sentence", "whitespace", "word", "break", "inlineMath"]);
var INLINE_NODE_WRAPPER_TYPES = /* @__PURE__ */ new Set([...INLINE_NODE_TYPES, "tableCell", "paragraph", "heading"]);
var punctuationRegex = new RegExp(punctuationPattern);
var KIND_NON_CJK = "non-cjk";
var KIND_CJ_LETTER = "cj-letter";
var KIND_K_LETTER = "k-letter";
var KIND_CJK_PUNCTUATION = "cjk-punctuation";
function splitText(text) {
  const nodes = [];
  const tokens = text.split(/([\t\n ]+)/);
  for (const [index, token] of tokens.entries()) {
    if (index % 2 === 1) {
      nodes.push({
        type: "whitespace",
        value: /\n/.test(token) ? "\n" : " "
      });
      continue;
    }
    if ((index === 0 || index === tokens.length - 1) && token === "") {
      continue;
    }
    const innerTokens = token.split(new RegExp(`(${cjkPattern})`));
    for (const [innerIndex, innerToken] of innerTokens.entries()) {
      if ((innerIndex === 0 || innerIndex === innerTokens.length - 1) && innerToken === "") {
        continue;
      }
      if (innerIndex % 2 === 0) {
        if (innerToken !== "") {
          appendNode({
            type: "word",
            value: innerToken,
            kind: KIND_NON_CJK,
            hasLeadingPunctuation: punctuationRegex.test(innerToken[0]),
            hasTrailingPunctuation: punctuationRegex.test(at_default(
              /* isOptionalObject*/
              false,
              innerToken,
              -1
            ))
          });
        }
        continue;
      }
      appendNode(punctuationRegex.test(innerToken) ? {
        type: "word",
        value: innerToken,
        kind: KIND_CJK_PUNCTUATION,
        hasLeadingPunctuation: true,
        hasTrailingPunctuation: true
      } : {
        type: "word",
        value: innerToken,
        // Korean uses space to divide words, but Chinese & Japanese do not
        kind: kRegex.test(innerToken) ? KIND_K_LETTER : KIND_CJ_LETTER,
        hasLeadingPunctuation: false,
        hasTrailingPunctuation: false
      });
    }
  }
  if (false) {
    for (let i = 1; i < nodes.length; i++) {
      assert(!(nodes[i - 1].type === "whitespace" && nodes[i].type === "whitespace"), "splitText should not create consecutive whitespace nodes");
    }
  }
  return nodes;
  function appendNode(node) {
    const lastNode = at_default(
      /* isOptionalObject*/
      false,
      nodes,
      -1
    );
    if ((lastNode == null ? void 0 : lastNode.type) === "word" && !isBetween(KIND_NON_CJK, KIND_CJK_PUNCTUATION) && // disallow leading/trailing full-width whitespace
    ![lastNode.value, node.value].some((value) => /\u3000/.test(value))) {
      nodes.push({
        type: "whitespace",
        value: ""
      });
    }
    nodes.push(node);
    function isBetween(kind1, kind2) {
      return lastNode.kind === kind1 && node.kind === kind2 || lastNode.kind === kind2 && node.kind === kind1;
    }
  }
}
function getOrderedListItemInfo(orderListItem, originalText) {
  const [, numberText, marker, leadingSpaces] = originalText.slice(orderListItem.position.start.offset, orderListItem.position.end.offset).match(/^\s*(\d+)(\.|\))(\s*)/);
  return {
    numberText,
    marker,
    leadingSpaces
  };
}
function hasGitDiffFriendlyOrderedList(node, options9) {
  if (!node.ordered) {
    return false;
  }
  if (node.children.length < 2) {
    return false;
  }
  const firstNumber = Number(getOrderedListItemInfo(node.children[0], options9.originalText).numberText);
  const secondNumber = Number(getOrderedListItemInfo(node.children[1], options9.originalText).numberText);
  if (firstNumber === 0 && node.children.length > 2) {
    const thirdNumber = Number(getOrderedListItemInfo(node.children[2], options9.originalText).numberText);
    return secondNumber === 1 && thirdNumber === 1;
  }
  return secondNumber === 1;
}
function getFencedCodeBlockValue(node, originalText) {
  const {
    value
  } = node;
  if (node.position.end.offset === originalText.length && value.endsWith("\n") && // Code block has no end mark
  originalText.endsWith("\n")) {
    return value.slice(0, -1);
  }
  return value;
}
function mapAst(ast, handler) {
  return function preorder(node, index, parentStack) {
    const newNode = {
      ...handler(node, index, parentStack)
    };
    if (newNode.children) {
      newNode.children = newNode.children.map((child, index2) => preorder(child, index2, [newNode, ...parentStack]));
    }
    return newNode;
  }(ast, null, []);
}
function isAutolink(node) {
  if ((node == null ? void 0 : node.type) !== "link" || node.children.length !== 1) {
    return false;
  }
  const [child] = node.children;
  return locStart5(node) === locStart5(child) && locEnd5(node) === locEnd5(child);
}

// src/language-markdown/embed.js
function embed3(path11, options9) {
  const { node } = path11;
  if (node.type === "code" && node.lang !== null) {
    const parser = infer_parser_by_language_default(node.lang, options9);
    if (parser) {
      return async (textToDoc2) => {
        const styleUnit = options9.__inJsTemplate ? "~" : "`";
        const style = styleUnit.repeat(
          Math.max(3, get_max_continuous_count_default(node.value, styleUnit) + 1)
        );
        const newOptions = { parser };
        if (node.lang === "tsx") {
          newOptions.filepath = "dummy.tsx";
        }
        const doc2 = await textToDoc2(
          getFencedCodeBlockValue(node, options9.originalText),
          newOptions
        );
        return markAsRoot([
          style,
          node.lang,
          node.meta ? " " + node.meta : "",
          hardline,
          replaceEndOfLine(doc2),
          hardline,
          style
        ]);
      };
    }
  }
  switch (node.type) {
    case "front-matter":
      return (textToDoc2) => print_default(node, textToDoc2);
    case "import":
    case "export":
      return (textToDoc2) => textToDoc2(node.value, { parser: "babel" });
    case "jsx":
      return (textToDoc2) => textToDoc2(`<$>${node.value}</$>`, {
        parser: "__js_expression",
        rootMarker: "mdx"
      });
  }
  return null;
}
var embed_default3 = embed3;

// src/language-markdown/pragma.js
var pragmas = ["format", "prettier"];
function startWithPragma(text) {
  const pragma = `@(${pragmas.join("|")})`;
  const regex = new RegExp(
    [
      `<!--\\s*${pragma}\\s*-->`,
      `{\\s*\\/\\*\\s*${pragma}\\s*\\*\\/\\s*}`,
      `<!--.*\r?
[\\s\\S]*(^|
)[^\\S
]*${pragma}[^\\S
]*($|
)[\\s\\S]*
.*-->`
    ].join("|"),
    "m"
  );
  const matched = text.match(regex);
  return (matched == null ? void 0 : matched.index) === 0;
}
var insertPragma4 = (text) => {
  const extracted = parse_default(text);
  const pragma = `<!-- @${pragmas[0]} -->`;
  return extracted.frontMatter ? `${extracted.frontMatter.raw}

${pragma}

${extracted.content}` : `${pragma}

${extracted.content}`;
};

// src/language-markdown/print-preprocess.js
var isSingleCharRegex = /^.$/su;
function preprocess(ast, options9) {
  ast = restoreUnescapedCharacter(ast, options9);
  ast = mergeContinuousTexts(ast);
  ast = transformIndentedCodeblockAndMarkItsParentList(ast, options9);
  ast = markAlignedList(ast, options9);
  ast = splitTextIntoSentences(ast);
  return ast;
}
function restoreUnescapedCharacter(ast, options9) {
  return mapAst(ast, (node) => node.type !== "text" || node.value === "*" || node.value === "_" || // handle these cases in printer
  !isSingleCharRegex.test(node.value) || node.position.end.offset - node.position.start.offset === node.value.length ? node : {
    ...node,
    value: options9.originalText.slice(node.position.start.offset, node.position.end.offset)
  });
}
function mergeChildren(ast, shouldMerge, mergeNode) {
  return mapAst(ast, (node) => {
    if (!node.children) {
      return node;
    }
    const children = node.children.reduce((current, child) => {
      const lastChild = at_default(
        /* isOptionalObject*/
        false,
        current,
        -1
      );
      if (lastChild && shouldMerge(lastChild, child)) {
        current.splice(-1, 1, mergeNode(lastChild, child));
      } else {
        current.push(child);
      }
      return current;
    }, []);
    return {
      ...node,
      children
    };
  });
}
function mergeContinuousTexts(ast) {
  return mergeChildren(ast, (prevNode, node) => prevNode.type === "text" && node.type === "text", (prevNode, node) => ({
    type: "text",
    value: prevNode.value + node.value,
    position: {
      start: prevNode.position.start,
      end: node.position.end
    }
  }));
}
function splitTextIntoSentences(ast) {
  return mapAst(ast, (node, index, [parentNode]) => {
    if (node.type !== "text") {
      return node;
    }
    let {
      value
    } = node;
    if (parentNode.type === "paragraph") {
      if (index === 0) {
        value = value.trimStart();
      }
      if (index === parentNode.children.length - 1) {
        value = value.trimEnd();
      }
    }
    return {
      type: "sentence",
      position: node.position,
      children: splitText(value)
    };
  });
}
function transformIndentedCodeblockAndMarkItsParentList(ast, options9) {
  return mapAst(ast, (node, index, parentStack) => {
    if (node.type === "code") {
      const isIndented = /^\n?(?: {4,}|\t)/.test(options9.originalText.slice(node.position.start.offset, node.position.end.offset));
      node.isIndented = isIndented;
      if (isIndented) {
        for (let i = 0; i < parentStack.length; i++) {
          const parent = parentStack[i];
          if (parent.hasIndentedCodeblock) {
            break;
          }
          if (parent.type === "list") {
            parent.hasIndentedCodeblock = true;
          }
        }
      }
    }
    return node;
  });
}
function markAlignedList(ast, options9) {
  return mapAst(ast, (node, index, parentStack) => {
    if (node.type === "list" && node.children.length > 0) {
      for (let i = 0; i < parentStack.length; i++) {
        const parent = parentStack[i];
        if (parent.type === "list" && !parent.isAligned) {
          node.isAligned = false;
          return node;
        }
      }
      node.isAligned = isAligned(node);
    }
    return node;
  });
  function getListItemStart(listItem) {
    return listItem.children.length === 0 ? -1 : listItem.children[0].position.start.column - 1;
  }
  function isAligned(list) {
    if (!list.ordered) {
      return true;
    }
    const [firstItem, secondItem] = list.children;
    const firstInfo = getOrderedListItemInfo(firstItem, options9.originalText);
    if (firstInfo.leadingSpaces.length > 1) {
      return true;
    }
    const firstStart = getListItemStart(firstItem);
    if (firstStart === -1) {
      return false;
    }
    if (list.children.length === 1) {
      return firstStart % options9.tabWidth === 0;
    }
    const secondStart = getListItemStart(secondItem);
    if (firstStart !== secondStart) {
      return false;
    }
    if (firstStart % options9.tabWidth === 0) {
      return true;
    }
    const secondInfo = getOrderedListItemInfo(secondItem, options9.originalText);
    return secondInfo.leadingSpaces.length > 1;
  }
}
var print_preprocess_default = preprocess;

// src/language-markdown/clean.js
var import_collapse_white_space = __toESM(require_collapse_white_space(), 1);
var ignoredProperties3 = /* @__PURE__ */ new Set([
  "position",
  "raw"
  // front-matter
]);
function clean5(ast, newObj, parent) {
  if (ast.type === "front-matter" || ast.type === "code" || ast.type === "yaml" || ast.type === "import" || ast.type === "export" || ast.type === "jsx") {
    delete newObj.value;
  }
  if (ast.type === "list") {
    delete newObj.isAligned;
  }
  if (ast.type === "list" || ast.type === "listItem") {
    delete newObj.spread;
  }
  if (ast.type === "text") {
    return null;
  }
  if (ast.type === "inlineCode") {
    newObj.value = string_replace_all_default(
      /* isOptionalObject*/
      false,
      ast.value,
      "\n",
      " "
    );
  }
  if (ast.type === "wikiLink") {
    newObj.value = string_replace_all_default(
      /* isOptionalObject*/
      false,
      ast.value.trim(),
      /[\t\n]+/g,
      " "
    );
  }
  if (ast.type === "definition" || ast.type === "linkReference" || ast.type === "imageReference") {
    newObj.label = (0, import_collapse_white_space.default)(ast.label);
  }
  if ((ast.type === "definition" || ast.type === "link" || ast.type === "image") && ast.title) {
    newObj.title = string_replace_all_default(
      /* isOptionalObject*/
      false,
      ast.title,
      /\\(?=["')])/g,
      ""
    );
  }
  if ((parent == null ? void 0 : parent.type) === "root" && parent.children.length > 0 && (parent.children[0] === ast || is_front_matter_default(parent.children[0]) && parent.children[1] === ast) && ast.type === "html" && startWithPragma(ast.value)) {
    return null;
  }
}
clean5.ignoredProperties = ignoredProperties3;
var clean_default4 = clean5;

// src/language-markdown/visitor-keys.js
var visitorKeys2 = {
  "front-matter": [],
  root: ["children"],
  paragraph: ["children"],
  sentence: ["children"],
  word: [],
  whitespace: [],
  emphasis: ["children"],
  strong: ["children"],
  delete: ["children"],
  inlineCode: [],
  wikiLink: [],
  link: ["children"],
  image: [],
  blockquote: ["children"],
  heading: ["children"],
  code: [],
  html: [],
  list: ["children"],
  thematicBreak: [],
  linkReference: ["children"],
  imageReference: [],
  definition: [],
  footnote: ["children"],
  footnoteReference: [],
  footnoteDefinition: ["children"],
  table: ["children"],
  tableCell: ["children"],
  break: [],
  liquidNode: [],
  import: [],
  export: [],
  esComment: [],
  jsx: [],
  math: [],
  inlineMath: [],
  tableRow: ["children"],
  listItem: ["children"],
  text: []
};
var visitor_keys_default2 = visitorKeys2;

// src/language-markdown/get-visitor-keys.js
var getVisitorKeys5 = create_get_visitor_keys_default(visitor_keys_default2);
var get_visitor_keys_default5 = getVisitorKeys5;

// src/language-markdown/print-whitespace.js
var SINGLE_LINE_NODE_TYPES = /* @__PURE__ */ new Set(["heading", "tableCell", "link", "wikiLink"]);
var noBreakAfter = new Set(`$(\xA3\xA5\xB7'"\u3008\u300A\u300C\u300E\u3010\u3014\u3016\u301D\uFE59\uFE5B\uFF04\uFF08\uFF3B\uFF5B\uFFE1\uFFE5[{\u2035\uFE34\uFE35\uFE37\uFE39\uFE3B\uFE3D\uFE3F\uFE41\uFE43\uFE4F\u3018\uFF5F\xAB`);
var noBreakBefore = new Set(`!%),.:;?]}\xA2\xB0\xB7'"\u2020\u2021\u203A\u2103\u2236\u3001\u3002\u3003\u3006\u3015\u3017\u301E\uFE5A\uFE5C\uFF01\uFF02\uFF05\uFF07\uFF09\uFF0C\uFF0E\uFF1A\uFF1B\uFF1F\uFF3D\uFF5D\uFF5E\u2013\u2014\u2022\u3009\u300B\u300D\uFE30\uFE31\uFE32\uFE33\uFE50\uFE51\uFE52\uFE53\uFE54\uFE55\uFE56\uFE58\uFE36\uFE38\uFE3A\uFE3C\uFE3E\uFE40\uFE42\uFE57\uFF5C\uFF64\u300F\u3011\u3019\u301F\uFF60\xBB\u30FD\u30FE\u30FC\u30A1\u30A3\u30A5\u30A7\u30A9\u30C3\u30E3\u30E5\u30E7\u30EE\u30F5\u30F6\u3041\u3043\u3045\u3047\u3049\u3063\u3083\u3085\u3087\u308E\u3095\u3096\u31F0\u31F1\u31F2\u31F3\u31F4\u31F5\u31F6\u31F7\u31F8\u31F9\u31FA\u31FB\u31FC\u31FD\u31FE\u31FF\u3005\u303B\u2010\u30A0\u301C\uFF5E\u203C\u2047\u2048\u2049\u30FB`);
var lineBreakBetweenTheseAndCJConvertsToSpace = new Set("!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~");
function isInSentenceWithCJSpaces({
  parent: sentenceNode
}) {
  if (sentenceNode.usesCJSpaces === void 0) {
    const stats = {
      " ": 0,
      "": 0
    };
    const {
      children
    } = sentenceNode;
    for (let i = 1; i < children.length - 1; ++i) {
      const node = children[i];
      if (node.type === "whitespace" && (node.value === " " || node.value === "")) {
        const previousKind = children[i - 1].kind;
        const nextKind = children[i + 1].kind;
        if (previousKind === KIND_CJ_LETTER && nextKind === KIND_NON_CJK || previousKind === KIND_NON_CJK && nextKind === KIND_CJ_LETTER) {
          ++stats[node.value];
        }
      }
    }
    sentenceNode.usesCJSpaces = stats[" "] > stats[""];
  }
  return sentenceNode.usesCJSpaces;
}
function lineBreakCanBeConvertedToSpace(path11, isLink) {
  if (isLink) {
    return true;
  }
  const {
    previous,
    next
  } = path11;
  if (!previous || !next) {
    return true;
  }
  const previousKind = previous.kind;
  const nextKind = next.kind;
  if (
    // "\n" between non-CJK or Korean characters always can be converted to a
    // space. Korean Hangul simulates Latin words. See
    // https://github.com/prettier/prettier/issues/6516
    isNonCJKOrKoreanLetter(previousKind) && isNonCJKOrKoreanLetter(nextKind) || // Han & Hangul: same way preferred
    previousKind === KIND_K_LETTER && nextKind === KIND_CJ_LETTER || nextKind === KIND_K_LETTER && previousKind === KIND_CJ_LETTER
  ) {
    return true;
  }
  if (
    // around CJK punctuation
    previousKind === KIND_CJK_PUNCTUATION || nextKind === KIND_CJK_PUNCTUATION || // between CJ
    previousKind === KIND_CJ_LETTER && nextKind === KIND_CJ_LETTER
  ) {
    return false;
  }
  if (lineBreakBetweenTheseAndCJConvertsToSpace.has(next.value[0]) || lineBreakBetweenTheseAndCJConvertsToSpace.has(at_default(
    /* isOptionalObject*/
    false,
    previous.value,
    -1
  ))) {
    return true;
  }
  if (previous.hasTrailingPunctuation || next.hasLeadingPunctuation) {
    return false;
  }
  return isInSentenceWithCJSpaces(path11);
}
function isLetter(kind) {
  return kind === KIND_NON_CJK || kind === KIND_CJ_LETTER || kind === KIND_K_LETTER;
}
function isNonCJKOrKoreanLetter(kind) {
  return kind === KIND_NON_CJK || kind === KIND_K_LETTER;
}
function isBreakable(path11, value, proseWrap, isLink, canBeSpace) {
  if (proseWrap !== "always" || path11.hasAncestor((node) => SINGLE_LINE_NODE_TYPES.has(node.type))) {
    return false;
  }
  if (isLink) {
    return value !== "";
  }
  if (value === " ") {
    return true;
  }
  const {
    previous,
    next
  } = path11;
  if (value === "" && ((previous == null ? void 0 : previous.kind) === KIND_K_LETTER && isLetter(next == null ? void 0 : next.kind) || (next == null ? void 0 : next.kind) === KIND_K_LETTER && isLetter(previous == null ? void 0 : previous.kind))) {
    return false;
  }
  const violatesCJKLineBreakingRules = !canBeSpace && (next && noBreakBefore.has(next.value[0]) || previous && noBreakAfter.has(at_default(
    /* isOptionalObject*/
    false,
    previous.value,
    -1
  )));
  if (violatesCJKLineBreakingRules) {
    return false;
  }
  return true;
}
function printWhitespace(path11, value, proseWrap, isLink) {
  if (proseWrap === "preserve" && value === "\n") {
    return hardline;
  }
  const canBeSpace = value === " " || value === "\n" && lineBreakCanBeConvertedToSpace(path11, isLink);
  if (isBreakable(path11, value, proseWrap, isLink, canBeSpace)) {
    return canBeSpace ? line : softline;
  }
  return canBeSpace ? " " : "";
}

// src/language-markdown/printer-markdown.js
var SIBLING_NODE_TYPES = /* @__PURE__ */ new Set(["listItem", "definition", "footnoteDefinition"]);
function genericPrint4(path11, options9, print4) {
  var _a, _b, _c;
  const {
    node
  } = path11;
  if (shouldRemainTheSameContent(path11)) {
    return splitText(options9.originalText.slice(node.position.start.offset, node.position.end.offset)).map((node2) => node2.type === "word" ? node2.value : printWhitespace(path11, node2.value, options9.proseWrap, true));
  }
  switch (node.type) {
    case "front-matter":
      return options9.originalText.slice(node.position.start.offset, node.position.end.offset);
    case "root":
      if (node.children.length === 0) {
        return "";
      }
      return [normalizeDoc(printRoot(path11, options9, print4)), hardline];
    case "paragraph":
      return printChildren2(path11, options9, print4, {
        postprocessor: fill
      });
    case "sentence":
      return printChildren2(path11, options9, print4);
    case "word": {
      let escapedValue = string_replace_all_default(
        /* isOptionalObject*/
        false,
        string_replace_all_default(
          /* isOptionalObject*/
          false,
          node.value,
          "*",
          "\\*"
        ),
        new RegExp([`(^|${punctuationPattern})(_+)`, `(_+)(${punctuationPattern}|$)`].join("|"), "g"),
        (_, text1, underscore1, underscore2, text2) => string_replace_all_default(
          /* isOptionalObject*/
          false,
          underscore1 ? `${text1}${underscore1}` : `${underscore2}${text2}`,
          "_",
          "\\_"
        )
      );
      const isFirstSentence = (node2, name, index) => node2.type === "sentence" && index === 0;
      const isLastChildAutolink = (node2, name, index) => isAutolink(node2.children[index - 1]);
      if (escapedValue !== node.value && (path11.match(void 0, isFirstSentence, isLastChildAutolink) || path11.match(void 0, isFirstSentence, (node2, name, index) => node2.type === "emphasis" && index === 0, isLastChildAutolink))) {
        escapedValue = escapedValue.replace(/^(\\?[*_])+/, (prefix) => string_replace_all_default(
          /* isOptionalObject*/
          false,
          prefix,
          "\\",
          ""
        ));
      }
      return escapedValue;
    }
    case "whitespace": {
      const {
        next
      } = path11;
      const proseWrap = (
        // leading char that may cause different syntax
        next && /^>|^(?:[*+-]|#{1,6}|\d+[).])$/.test(next.value) ? "never" : options9.proseWrap
      );
      return printWhitespace(path11, node.value, proseWrap);
    }
    case "emphasis": {
      let style;
      if (isAutolink(node.children[0])) {
        style = options9.originalText[node.position.start.offset];
      } else {
        const {
          previous,
          next
        } = path11;
        const hasPrevOrNextWord = (
          // `1*2*3` is considered emphasis but `1_2_3` is not
          (previous == null ? void 0 : previous.type) === "sentence" && ((_a = at_default(
            /* isOptionalObject*/
            false,
            previous.children,
            -1
          )) == null ? void 0 : _a.type) === "word" && !at_default(
            /* isOptionalObject*/
            false,
            previous.children,
            -1
          ).hasTrailingPunctuation || (next == null ? void 0 : next.type) === "sentence" && ((_b = next.children[0]) == null ? void 0 : _b.type) === "word" && !next.children[0].hasLeadingPunctuation
        );
        style = hasPrevOrNextWord || path11.hasAncestor((node2) => node2.type === "emphasis") ? "*" : "_";
      }
      return [style, printChildren2(path11, options9, print4), style];
    }
    case "strong":
      return ["**", printChildren2(path11, options9, print4), "**"];
    case "delete":
      return ["~~", printChildren2(path11, options9, print4), "~~"];
    case "inlineCode": {
      const code = options9.proseWrap === "preserve" ? node.value : string_replace_all_default(
        /* isOptionalObject*/
        false,
        node.value,
        "\n",
        " "
      );
      const backtickCount = get_min_not_present_continuous_count_default(code, "`");
      const backtickString = "`".repeat(backtickCount || 1);
      const padding = code.startsWith("`") || code.endsWith("`") || /^[\n ]/.test(code) && /[\n ]$/.test(code) && /[^\n ]/.test(code) ? " " : "";
      return [backtickString, padding, code, padding, backtickString];
    }
    case "wikiLink": {
      let contents = "";
      if (options9.proseWrap === "preserve") {
        contents = node.value;
      } else {
        contents = string_replace_all_default(
          /* isOptionalObject*/
          false,
          node.value,
          /[\t\n]+/g,
          " "
        );
      }
      return ["[[", contents, "]]"];
    }
    case "link":
      switch (options9.originalText[node.position.start.offset]) {
        case "<": {
          const mailto = "mailto:";
          const url = (
            // <hello@example.com> is parsed as { url: "mailto:hello@example.com" }
            node.url.startsWith(mailto) && options9.originalText.slice(node.position.start.offset + 1, node.position.start.offset + 1 + mailto.length) !== mailto ? node.url.slice(mailto.length) : node.url
          );
          return ["<", url, ">"];
        }
        case "[":
          return ["[", printChildren2(path11, options9, print4), "](", printUrl(node.url, ")"), printTitle(node.title, options9), ")"];
        default:
          return options9.originalText.slice(node.position.start.offset, node.position.end.offset);
      }
    case "image":
      return ["![", node.alt || "", "](", printUrl(node.url, ")"), printTitle(node.title, options9), ")"];
    case "blockquote":
      return ["> ", align("> ", printChildren2(path11, options9, print4))];
    case "heading":
      return ["#".repeat(node.depth) + " ", printChildren2(path11, options9, print4)];
    case "code": {
      if (node.isIndented) {
        const alignment = " ".repeat(4);
        return align(alignment, [alignment, replaceEndOfLine(node.value, hardline)]);
      }
      const styleUnit = options9.__inJsTemplate ? "~" : "`";
      const style = styleUnit.repeat(Math.max(3, get_max_continuous_count_default(node.value, styleUnit) + 1));
      return [style, node.lang || "", node.meta ? " " + node.meta : "", hardline, replaceEndOfLine(getFencedCodeBlockValue(node, options9.originalText), hardline), hardline, style];
    }
    case "html": {
      const {
        parent,
        isLast
      } = path11;
      const value = parent.type === "root" && isLast ? node.value.trimEnd() : node.value;
      const isHtmlComment = /^<!--.*-->$/s.test(value);
      return replaceEndOfLine(
        value,
        // @ts-expect-error
        isHtmlComment ? hardline : markAsRoot(literalline)
      );
    }
    case "list": {
      const nthSiblingIndex = getNthListSiblingIndex(node, path11.parent);
      const isGitDiffFriendlyOrderedList = hasGitDiffFriendlyOrderedList(node, options9);
      return printChildren2(path11, options9, print4, {
        processor(childPath) {
          const prefix = getPrefix();
          const childNode = childPath.node;
          if (childNode.children.length === 2 && childNode.children[1].type === "html" && childNode.children[0].position.start.column !== childNode.children[1].position.start.column) {
            return [prefix, printListItem(childPath, options9, print4, prefix)];
          }
          return [prefix, align(" ".repeat(prefix.length), printListItem(childPath, options9, print4, prefix))];
          function getPrefix() {
            const rawPrefix = node.ordered ? (childPath.isFirst ? node.start : isGitDiffFriendlyOrderedList ? 1 : node.start + childPath.index) + (nthSiblingIndex % 2 === 0 ? ". " : ") ") : nthSiblingIndex % 2 === 0 ? "- " : "* ";
            return node.isAligned || /* workaround for https://github.com/remarkjs/remark/issues/315 */
            node.hasIndentedCodeblock ? alignListPrefix(rawPrefix, options9) : rawPrefix;
          }
        }
      });
    }
    case "thematicBreak": {
      const {
        ancestors
      } = path11;
      const counter = ancestors.findIndex((node2) => node2.type === "list");
      if (counter === -1) {
        return "---";
      }
      const nthSiblingIndex = getNthListSiblingIndex(ancestors[counter], ancestors[counter + 1]);
      return nthSiblingIndex % 2 === 0 ? "***" : "---";
    }
    case "linkReference":
      return ["[", printChildren2(path11, options9, print4), "]", node.referenceType === "full" ? printLinkReference(node) : node.referenceType === "collapsed" ? "[]" : ""];
    case "imageReference":
      switch (node.referenceType) {
        case "full":
          return ["![", node.alt || "", "]", printLinkReference(node)];
        default:
          return ["![", node.alt, "]", node.referenceType === "collapsed" ? "[]" : ""];
      }
    case "definition": {
      const lineOrSpace = options9.proseWrap === "always" ? line : " ";
      return group([printLinkReference(node), ":", indent([lineOrSpace, printUrl(node.url), node.title === null ? "" : [lineOrSpace, printTitle(node.title, options9, false)]])]);
    }
    case "footnote":
      return ["[^", printChildren2(path11, options9, print4), "]"];
    case "footnoteReference":
      return printFootnoteReference(node);
    case "footnoteDefinition": {
      const shouldInlineFootnote = node.children.length === 1 && node.children[0].type === "paragraph" && (options9.proseWrap === "never" || options9.proseWrap === "preserve" && node.children[0].position.start.line === node.children[0].position.end.line);
      return [printFootnoteReference(node), ": ", shouldInlineFootnote ? printChildren2(path11, options9, print4) : group([align(" ".repeat(4), printChildren2(path11, options9, print4, {
        processor: ({
          isFirst
        }) => isFirst ? group([softline, print4()]) : print4()
      })), ((_c = path11.next) == null ? void 0 : _c.type) === "footnoteDefinition" ? softline : ""])];
    }
    case "table":
      return printTable(path11, options9, print4);
    case "tableCell":
      return printChildren2(path11, options9, print4);
    case "break":
      return /\s/.test(options9.originalText[node.position.start.offset]) ? ["  ", markAsRoot(literalline)] : ["\\", hardline];
    case "liquidNode":
      return replaceEndOfLine(node.value, hardline);
    case "import":
    case "export":
    case "jsx":
      return node.value;
    case "esComment":
      return ["{/* ", node.value, " */}"];
    case "math":
      return ["$$", hardline, node.value ? [replaceEndOfLine(node.value, hardline), hardline] : "", "$$"];
    case "inlineMath":
      return options9.originalText.slice(locStart5(node), locEnd5(node));
    case "tableRow":
    case "listItem":
    case "text":
    default:
      throw new unexpected_node_error_default(node, "Markdown");
  }
}
function printListItem(path11, options9, print4, listPrefix) {
  const {
    node
  } = path11;
  const prefix = node.checked === null ? "" : node.checked ? "[x] " : "[ ] ";
  return [prefix, printChildren2(path11, options9, print4, {
    processor({
      node: node2,
      isFirst
    }) {
      if (isFirst && node2.type !== "list") {
        return align(" ".repeat(prefix.length), print4());
      }
      const alignment = " ".repeat(
        clamp(options9.tabWidth - listPrefix.length, 0, 3)
        // 4+ will cause indented code block
      );
      return [alignment, align(alignment, print4())];
    }
  })];
}
function alignListPrefix(prefix, options9) {
  const additionalSpaces = getAdditionalSpaces();
  return prefix + " ".repeat(
    additionalSpaces >= 4 ? 0 : additionalSpaces
    // 4+ will cause indented code block
  );
  function getAdditionalSpaces() {
    const restSpaces = prefix.length % options9.tabWidth;
    return restSpaces === 0 ? 0 : options9.tabWidth - restSpaces;
  }
}
function getNthListSiblingIndex(node, parentNode) {
  return getNthSiblingIndex(node, parentNode, (siblingNode) => siblingNode.ordered === node.ordered);
}
function getNthSiblingIndex(node, parentNode, condition) {
  let index = -1;
  for (const childNode of parentNode.children) {
    if (childNode.type === node.type && condition(childNode)) {
      index++;
    } else {
      index = -1;
    }
    if (childNode === node) {
      return index;
    }
  }
}
function printTable(path11, options9, print4) {
  const {
    node
  } = path11;
  const columnMaxWidths = [];
  const contents = path11.map(() => path11.map(({
    index: columnIndex
  }) => {
    const text = printDocToString(print4(), options9).formatted;
    const width = get_string_width_default(text);
    columnMaxWidths[columnIndex] = Math.max(
      columnMaxWidths[columnIndex] || 3,
      // minimum width = 3 (---, :--, :-:, --:)
      width
    );
    return {
      text,
      width
    };
  }, "children"), "children");
  const alignedTable = printTableContents(
    /* isCompact */
    false
  );
  if (options9.proseWrap !== "never") {
    return [breakParent, alignedTable];
  }
  const compactTable = printTableContents(
    /* isCompact */
    true
  );
  return [breakParent, group(ifBreak(compactTable, alignedTable))];
  function printTableContents(isCompact) {
    const parts = [printRow(contents[0], isCompact), printAlign(isCompact)];
    if (contents.length > 1) {
      parts.push(join(hardlineWithoutBreakParent, contents.slice(1).map((rowContents) => printRow(rowContents, isCompact))));
    }
    return join(hardlineWithoutBreakParent, parts);
  }
  function printAlign(isCompact) {
    const align2 = columnMaxWidths.map((width, index) => {
      const align3 = node.align[index];
      const first = align3 === "center" || align3 === "left" ? ":" : "-";
      const last = align3 === "center" || align3 === "right" ? ":" : "-";
      const middle = isCompact ? "-" : "-".repeat(width - 2);
      return `${first}${middle}${last}`;
    });
    return `| ${align2.join(" | ")} |`;
  }
  function printRow(rowContents, isCompact) {
    const columns = rowContents.map(({
      text,
      width
    }, columnIndex) => {
      if (isCompact) {
        return text;
      }
      const spaces = columnMaxWidths[columnIndex] - width;
      const align2 = node.align[columnIndex];
      let before = 0;
      if (align2 === "right") {
        before = spaces;
      } else if (align2 === "center") {
        before = Math.floor(spaces / 2);
      }
      const after = spaces - before;
      return `${" ".repeat(before)}${text}${" ".repeat(after)}`;
    });
    return `| ${columns.join(" | ")} |`;
  }
}
function printRoot(path11, options9, print4) {
  const ignoreRanges = [];
  let ignoreStart = null;
  const {
    children
  } = path11.node;
  for (const [index, childNode] of children.entries()) {
    switch (isPrettierIgnore(childNode)) {
      case "start":
        if (ignoreStart === null) {
          ignoreStart = {
            index,
            offset: childNode.position.end.offset
          };
        }
        break;
      case "end":
        if (ignoreStart !== null) {
          ignoreRanges.push({
            start: ignoreStart,
            end: {
              index,
              offset: childNode.position.start.offset
            }
          });
          ignoreStart = null;
        }
        break;
      default:
        break;
    }
  }
  return printChildren2(path11, options9, print4, {
    processor({
      index
    }) {
      if (ignoreRanges.length > 0) {
        const ignoreRange = ignoreRanges[0];
        if (index === ignoreRange.start.index) {
          return [printIgnoreComment(children[ignoreRange.start.index]), options9.originalText.slice(ignoreRange.start.offset, ignoreRange.end.offset), printIgnoreComment(children[ignoreRange.end.index])];
        }
        if (ignoreRange.start.index < index && index < ignoreRange.end.index) {
          return false;
        }
        if (index === ignoreRange.end.index) {
          ignoreRanges.shift();
          return false;
        }
      }
      return print4();
    }
  });
}
function printChildren2(path11, options9, print4, events = {}) {
  const {
    postprocessor = (parts2) => parts2,
    processor = () => print4()
  } = events;
  const parts = [];
  path11.each(() => {
    const result = processor(path11);
    if (result !== false) {
      if (parts.length > 0 && shouldPrePrintHardline(path11)) {
        parts.push(hardline);
        if (shouldPrePrintDoubleHardline(path11, options9) || shouldPrePrintTripleHardline(path11)) {
          parts.push(hardline);
        }
        if (shouldPrePrintTripleHardline(path11)) {
          parts.push(hardline);
        }
      }
      parts.push(result);
    }
  }, "children");
  return postprocessor(parts);
}
function printIgnoreComment(node) {
  if (node.type === "html") {
    return node.value;
  }
  if (node.type === "paragraph" && Array.isArray(node.children) && node.children.length === 1 && node.children[0].type === "esComment") {
    return ["{/* ", node.children[0].value, " */}"];
  }
}
function isPrettierIgnore(node) {
  let match;
  if (node.type === "html") {
    match = node.value.match(/^<!--\s*prettier-ignore(?:-(start|end))?\s*-->$/);
  } else {
    let comment;
    if (node.type === "esComment") {
      comment = node;
    } else if (node.type === "paragraph" && node.children.length === 1 && node.children[0].type === "esComment") {
      comment = node.children[0];
    }
    if (comment) {
      match = comment.value.match(/^prettier-ignore(?:-(start|end))?$/);
    }
  }
  return match ? match[1] || "next" : false;
}
function shouldPrePrintHardline({
  node,
  parent
}) {
  const isInlineNode2 = INLINE_NODE_TYPES.has(node.type);
  const isInlineHTML = node.type === "html" && INLINE_NODE_WRAPPER_TYPES.has(parent.type);
  return !isInlineNode2 && !isInlineHTML;
}
function isLooseListItem(node, options9) {
  return node.type === "listItem" && (node.spread || // Check if `listItem` ends with `\n`
  // since it can't be empty, so we only need check the last character
  options9.originalText.charAt(node.position.end.offset - 1) === "\n");
}
function shouldPrePrintDoubleHardline({
  node,
  previous,
  parent
}, options9) {
  const isPrevNodeLooseListItem = isLooseListItem(previous, options9);
  if (isPrevNodeLooseListItem) {
    return true;
  }
  const isSequence = previous.type === node.type;
  const isSiblingNode = isSequence && SIBLING_NODE_TYPES.has(node.type);
  const isInTightListItem = parent.type === "listItem" && !isLooseListItem(parent, options9);
  const isPrevNodePrettierIgnore = isPrettierIgnore(previous) === "next";
  const isBlockHtmlWithoutBlankLineBetweenPrevHtml = node.type === "html" && previous.type === "html" && previous.position.end.line + 1 === node.position.start.line;
  const isHtmlDirectAfterListItem = node.type === "html" && parent.type === "listItem" && previous.type === "paragraph" && previous.position.end.line + 1 === node.position.start.line;
  return !(isSiblingNode || isInTightListItem || isPrevNodePrettierIgnore || isBlockHtmlWithoutBlankLineBetweenPrevHtml || isHtmlDirectAfterListItem);
}
function shouldPrePrintTripleHardline({
  node,
  previous
}) {
  const isPrevNodeList = previous.type === "list";
  const isIndentedCode = node.type === "code" && node.isIndented;
  return isPrevNodeList && isIndentedCode;
}
function shouldRemainTheSameContent(path11) {
  const node = path11.findAncestor((node2) => node2.type === "linkReference" || node2.type === "imageReference");
  return node && (node.type !== "linkReference" || node.referenceType !== "full");
}
function printUrl(url, dangerousCharOrChars = []) {
  const dangerousChars = [" ", ...Array.isArray(dangerousCharOrChars) ? dangerousCharOrChars : [dangerousCharOrChars]];
  return new RegExp(dangerousChars.map((x) => `\\${x}`).join("|")).test(url) ? `<${url}>` : url;
}
function printTitle(title, options9, printSpace = true) {
  if (!title) {
    return "";
  }
  if (printSpace) {
    return " " + printTitle(title, options9, false);
  }
  title = string_replace_all_default(
    /* isOptionalObject*/
    false,
    title,
    /\\(?=["')])/g,
    ""
  );
  if (title.includes('"') && title.includes("'") && !title.includes(")")) {
    return `(${title})`;
  }
  const singleCount = title.split("'").length - 1;
  const doubleCount = title.split('"').length - 1;
  const quote = singleCount > doubleCount ? '"' : doubleCount > singleCount ? "'" : options9.singleQuote ? "'" : '"';
  title = string_replace_all_default(
    /* isOptionalObject*/
    false,
    title,
    "\\",
    "\\\\"
  );
  title = string_replace_all_default(
    /* isOptionalObject*/
    false,
    title,
    new RegExp(`(${quote})`, "g"),
    "\\$1"
  );
  return `${quote}${title}${quote}`;
}
function clamp(value, min, max) {
  return value < min ? min : value > max ? max : value;
}
function hasPrettierIgnore4(path11) {
  return path11.index > 0 && isPrettierIgnore(path11.previous) === "next";
}
function printLinkReference(node) {
  return `[${(0, import_collapse_white_space2.default)(node.label)}]`;
}
function printFootnoteReference(node) {
  return `[^${node.label}]`;
}
var printer6 = {
  preprocess: print_preprocess_default,
  print: genericPrint4,
  embed: embed_default3,
  massageAstNode: clean_default4,
  hasPrettierIgnore: hasPrettierIgnore4,
  insertPragma: insertPragma4,
  getVisitorKeys: get_visitor_keys_default5
};
var printer_markdown_default = printer6;

// src/language-markdown/languages.evaluate.js
var languages_evaluate_default5 = [
  {
    "linguistLanguageId": 222,
    "name": "Markdown",
    "type": "prose",
    "color": "#083fa1",
    "aliases": [
      "pandoc"
    ],
    "aceMode": "markdown",
    "codemirrorMode": "gfm",
    "codemirrorMimeType": "text/x-gfm",
    "wrap": true,
    "extensions": [
      ".md",
      ".livemd",
      ".markdown",
      ".mdown",
      ".mdwn",
      ".mkd",
      ".mkdn",
      ".mkdown",
      ".ronn",
      ".scd",
      ".workbook"
    ],
    "filenames": [
      "contents.lr",
      "README"
    ],
    "tmScope": "source.gfm",
    "parsers": [
      "markdown"
    ],
    "vscodeLanguageIds": [
      "markdown"
    ]
  },
  {
    "linguistLanguageId": 222,
    "name": "MDX",
    "type": "prose",
    "color": "#083fa1",
    "aliases": [
      "pandoc"
    ],
    "aceMode": "markdown",
    "codemirrorMode": "gfm",
    "codemirrorMimeType": "text/x-gfm",
    "wrap": true,
    "extensions": [
      ".mdx"
    ],
    "filenames": [],
    "tmScope": "source.gfm",
    "parsers": [
      "mdx"
    ],
    "vscodeLanguageIds": [
      "mdx"
    ]
  }
];

// src/language-markdown/options.js
var options6 = {
  proseWrap: common_options_default.proseWrap,
  singleQuote: common_options_default.singleQuote
};
var options_default4 = options6;

// src/language-markdown/index.js
var printers5 = {
  mdast: printer_markdown_default
};
var parsers10 = create_parsers_default(parsers_default5);

// src/language-html/index.js
var language_html_exports = {};
__export(language_html_exports, {
  languages: () => languages_evaluate_default6,
  options: () => options_default5,
  parsers: () => parsers12,
  printers: () => printers6
});

// src/language-html/parsers.js
var parsers11 = [
  {
    importPlugin: () => import("./plugins/html.mjs"),
    parserNames: [
      // HTML
      "html",
      // Vue
      "vue",
      // Angular
      "angular",
      // Lightning Web Components
      "lwc"
    ]
  }
];
var parsers_default6 = parsers11;

// src/language-html/clean.js
var ignoredProperties4 = /* @__PURE__ */ new Set([
  "sourceSpan",
  "startSourceSpan",
  "endSourceSpan",
  "nameSpan",
  "valueSpan",
  "keySpan",
  "tagDefinition",
  "tokens",
  "valueTokens"
]);
function clean6(ast, newNode) {
  if (ast.type === "text" || ast.type === "comment") {
    return null;
  }
  if (is_front_matter_default(ast) || ast.type === "yaml" || ast.type === "toml") {
    return null;
  }
  if (ast.type === "attribute") {
    delete newNode.value;
  }
  if (ast.type === "docType") {
    delete newNode.value;
  }
}
clean6.ignoredProperties = ignoredProperties4;
var clean_default5 = clean6;

// src/language-html/constants.evaluate.js
var CSS_DISPLAY_DEFAULT = "inline";
var CSS_DISPLAY_TAGS = {
  "area": "none",
  "base": "none",
  "basefont": "none",
  "datalist": "none",
  "head": "none",
  "link": "none",
  "meta": "none",
  "noembed": "none",
  "noframes": "none",
  "param": "block",
  "rp": "none",
  "script": "block",
  "source": "block",
  "style": "none",
  "template": "inline",
  "track": "block",
  "title": "none",
  "html": "block",
  "body": "block",
  "address": "block",
  "blockquote": "block",
  "center": "block",
  "div": "block",
  "figure": "block",
  "figcaption": "block",
  "footer": "block",
  "form": "block",
  "header": "block",
  "hr": "block",
  "legend": "block",
  "listing": "block",
  "main": "block",
  "p": "block",
  "plaintext": "block",
  "pre": "block",
  "xmp": "block",
  "slot": "contents",
  "ruby": "ruby",
  "rt": "ruby-text",
  "article": "block",
  "aside": "block",
  "h1": "block",
  "h2": "block",
  "h3": "block",
  "h4": "block",
  "h5": "block",
  "h6": "block",
  "hgroup": "block",
  "nav": "block",
  "section": "block",
  "dir": "block",
  "dd": "block",
  "dl": "block",
  "dt": "block",
  "ol": "block",
  "ul": "block",
  "li": "list-item",
  "table": "table",
  "caption": "table-caption",
  "colgroup": "table-column-group",
  "col": "table-column",
  "thead": "table-header-group",
  "tbody": "table-row-group",
  "tfoot": "table-footer-group",
  "tr": "table-row",
  "td": "table-cell",
  "th": "table-cell",
  "fieldset": "block",
  "button": "inline-block",
  "details": "block",
  "summary": "block",
  "dialog": "block",
  "meter": "inline-block",
  "progress": "inline-block",
  "object": "inline-block",
  "video": "inline-block",
  "audio": "inline-block",
  "select": "inline-block",
  "option": "block",
  "optgroup": "block"
};
var CSS_WHITE_SPACE_DEFAULT = "normal";
var CSS_WHITE_SPACE_TAGS = {
  "listing": "pre",
  "plaintext": "pre",
  "pre": "pre",
  "xmp": "pre",
  "nobr": "nowrap",
  "table": "initial",
  "textarea": "pre-wrap"
};

// src/language-html/utils/is-unknown-namespace.js
function isUnknownNamespace(node) {
  return node.type === "element" && !node.hasExplicitNamespace && !["html", "svg"].includes(node.namespace);
}
var is_unknown_namespace_default = isUnknownNamespace;

// src/language-html/utils/index.js
var htmlTrimLeadingBlankLines = (string) => string_replace_all_default(
  /* isOptionalObject*/
  false,
  string,
  /^[\t\f\r ]*\n/g,
  ""
);
var htmlTrimPreserveIndentation = (string) => htmlTrimLeadingBlankLines(html_whitespace_utils_default.trimEnd(string));
var getLeadingAndTrailingHtmlWhitespace = (string) => {
  let text = string;
  const leadingWhitespace = html_whitespace_utils_default.getLeadingWhitespace(text);
  if (leadingWhitespace) {
    text = text.slice(leadingWhitespace.length);
  }
  const trailingWhitespace = html_whitespace_utils_default.getTrailingWhitespace(text);
  if (trailingWhitespace) {
    text = text.slice(0, -trailingWhitespace.length);
  }
  return {
    leadingWhitespace,
    trailingWhitespace,
    text
  };
};
function shouldPreserveContent(node, options9) {
  if (node.type === "ieConditionalComment" && node.lastChild && !node.lastChild.isSelfClosing && !node.lastChild.endSourceSpan) {
    return true;
  }
  if (node.type === "ieConditionalComment" && !node.complete) {
    return true;
  }
  if (isPreLikeNode(node) && node.children.some((child) => child.type !== "text" && child.type !== "interpolation")) {
    return true;
  }
  if (isVueNonHtmlBlock(node, options9) && !isScriptLikeTag(node) && node.type !== "interpolation") {
    return true;
  }
  return false;
}
function hasPrettierIgnore5(node) {
  if (node.type === "attribute") {
    return false;
  }
  if (!node.parent) {
    return false;
  }
  if (!node.prev) {
    return false;
  }
  return isPrettierIgnore2(node.prev);
}
function isPrettierIgnore2(node) {
  return node.type === "comment" && node.value.trim() === "prettier-ignore";
}
function isTextLikeNode(node) {
  return node.type === "text" || node.type === "comment";
}
function isScriptLikeTag(node) {
  return node.type === "element" && (node.fullName === "py-script" || node.fullName === "py-repl" || node.fullName === "py-config" || node.fullName === "script" || node.fullName === "style" || node.fullName === "svg:style" || is_unknown_namespace_default(node) && (node.name === "script" || node.name === "style"));
}
function canHaveInterpolation(node) {
  return node.children && !isScriptLikeTag(node);
}
function isWhitespaceSensitiveNode(node) {
  return isScriptLikeTag(node) || node.type === "interpolation" || isIndentationSensitiveNode(node);
}
function isIndentationSensitiveNode(node) {
  return getNodeCssStyleWhiteSpace(node).startsWith("pre");
}
function isLeadingSpaceSensitiveNode(node, options9) {
  var _a, _b;
  const isLeadingSpaceSensitive = _isLeadingSpaceSensitiveNode();
  if (isLeadingSpaceSensitive && !node.prev && ((_b = (_a = node.parent) == null ? void 0 : _a.tagDefinition) == null ? void 0 : _b.ignoreFirstLf)) {
    return node.type === "interpolation";
  }
  return isLeadingSpaceSensitive;
  function _isLeadingSpaceSensitiveNode() {
    if (is_front_matter_default(node)) {
      return false;
    }
    if ((node.type === "text" || node.type === "interpolation") && node.prev && (node.prev.type === "text" || node.prev.type === "interpolation")) {
      return true;
    }
    if (!node.parent || node.parent.cssDisplay === "none") {
      return false;
    }
    if (isPreLikeNode(node.parent)) {
      return true;
    }
    if (!node.prev && (node.parent.type === "root" || isPreLikeNode(node) && node.parent || isScriptLikeTag(node.parent) || isVueCustomBlock(node.parent, options9) || !isFirstChildLeadingSpaceSensitiveCssDisplay(node.parent.cssDisplay))) {
      return false;
    }
    if (node.prev && !isNextLeadingSpaceSensitiveCssDisplay(node.prev.cssDisplay)) {
      return false;
    }
    return true;
  }
}
function isTrailingSpaceSensitiveNode(node, options9) {
  if (is_front_matter_default(node)) {
    return false;
  }
  if ((node.type === "text" || node.type === "interpolation") && node.next && (node.next.type === "text" || node.next.type === "interpolation")) {
    return true;
  }
  if (!node.parent || node.parent.cssDisplay === "none") {
    return false;
  }
  if (isPreLikeNode(node.parent)) {
    return true;
  }
  if (!node.next && (node.parent.type === "root" || isPreLikeNode(node) && node.parent || isScriptLikeTag(node.parent) || isVueCustomBlock(node.parent, options9) || !isLastChildTrailingSpaceSensitiveCssDisplay(node.parent.cssDisplay))) {
    return false;
  }
  if (node.next && !isPrevTrailingSpaceSensitiveCssDisplay(node.next.cssDisplay)) {
    return false;
  }
  return true;
}
function isDanglingSpaceSensitiveNode(node) {
  return isDanglingSpaceSensitiveCssDisplay(node.cssDisplay) && !isScriptLikeTag(node);
}
function forceNextEmptyLine(node) {
  return is_front_matter_default(node) || node.next && node.sourceSpan.end && node.sourceSpan.end.line + 1 < node.next.sourceSpan.start.line;
}
function forceBreakContent(node) {
  return forceBreakChildren(node) || node.type === "element" && node.children.length > 0 && (["body", "script", "style"].includes(node.name) || node.children.some((child) => hasNonTextChild(child))) || node.firstChild && node.firstChild === node.lastChild && node.firstChild.type !== "text" && hasLeadingLineBreak(node.firstChild) && (!node.lastChild.isTrailingSpaceSensitive || hasTrailingLineBreak(node.lastChild));
}
function forceBreakChildren(node) {
  return node.type === "element" && node.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(node.name) || node.cssDisplay.startsWith("table") && node.cssDisplay !== "table-cell");
}
function preferHardlineAsLeadingSpaces(node) {
  return preferHardlineAsSurroundingSpaces(node) || node.prev && preferHardlineAsTrailingSpaces(node.prev) || hasSurroundingLineBreak(node);
}
function preferHardlineAsTrailingSpaces(node) {
  return preferHardlineAsSurroundingSpaces(node) || node.type === "element" && node.fullName === "br" || hasSurroundingLineBreak(node);
}
function hasSurroundingLineBreak(node) {
  return hasLeadingLineBreak(node) && hasTrailingLineBreak(node);
}
function hasLeadingLineBreak(node) {
  return node.hasLeadingSpaces && (node.prev ? node.prev.sourceSpan.end.line < node.sourceSpan.start.line : node.parent.type === "root" || node.parent.startSourceSpan.end.line < node.sourceSpan.start.line);
}
function hasTrailingLineBreak(node) {
  return node.hasTrailingSpaces && (node.next ? node.next.sourceSpan.start.line > node.sourceSpan.end.line : node.parent.type === "root" || node.parent.endSourceSpan && node.parent.endSourceSpan.start.line > node.sourceSpan.end.line);
}
function preferHardlineAsSurroundingSpaces(node) {
  switch (node.type) {
    case "ieConditionalComment":
    case "comment":
    case "directive":
      return true;
    case "element":
      return ["script", "select"].includes(node.name);
  }
  return false;
}
function getLastDescendant(node) {
  return node.lastChild ? getLastDescendant(node.lastChild) : node;
}
function hasNonTextChild(node) {
  var _a;
  return (_a = node.children) == null ? void 0 : _a.some((child) => child.type !== "text");
}
function _inferScriptParser(node) {
  const {
    type,
    lang
  } = node.attrMap;
  if (type === "module" || type === "text/javascript" || type === "text/babel" || type === "application/javascript" || lang === "jsx") {
    return "babel";
  }
  if (type === "application/x-typescript" || lang === "ts" || lang === "tsx") {
    return "typescript";
  }
  if (type === "text/markdown") {
    return "markdown";
  }
  if (type === "text/html") {
    return "html";
  }
  if (type && (type.endsWith("json") || type.endsWith("importmap")) || type === "speculationrules") {
    return "json";
  }
  if (type === "text/x-handlebars-template") {
    return "glimmer";
  }
}
function inferStyleParser(node, options9) {
  const {
    lang
  } = node.attrMap;
  if (!lang || lang === "postcss" || lang === "css") {
    return "css";
  }
  if (lang === "scss") {
    return "scss";
  }
  if (lang === "less") {
    return "less";
  }
  if (lang === "stylus") {
    return infer_parser_by_language_default("stylus", options9);
  }
}
function inferScriptParser(node, options9) {
  if (node.name === "script" && !node.attrMap.src) {
    if (!node.attrMap.lang && !node.attrMap.type) {
      return "babel";
    }
    return _inferScriptParser(node);
  }
  if (node.name === "style") {
    return inferStyleParser(node, options9);
  }
  if (options9 && isVueNonHtmlBlock(node, options9)) {
    return _inferScriptParser(node) || !("src" in node.attrMap) && infer_parser_by_language_default(node.attrMap.lang, options9);
  }
}
function isBlockLikeCssDisplay(cssDisplay) {
  return cssDisplay === "block" || cssDisplay === "list-item" || cssDisplay.startsWith("table");
}
function isFirstChildLeadingSpaceSensitiveCssDisplay(cssDisplay) {
  return !isBlockLikeCssDisplay(cssDisplay) && cssDisplay !== "inline-block";
}
function isLastChildTrailingSpaceSensitiveCssDisplay(cssDisplay) {
  return !isBlockLikeCssDisplay(cssDisplay) && cssDisplay !== "inline-block";
}
function isPrevTrailingSpaceSensitiveCssDisplay(cssDisplay) {
  return !isBlockLikeCssDisplay(cssDisplay);
}
function isNextLeadingSpaceSensitiveCssDisplay(cssDisplay) {
  return !isBlockLikeCssDisplay(cssDisplay);
}
function isDanglingSpaceSensitiveCssDisplay(cssDisplay) {
  return !isBlockLikeCssDisplay(cssDisplay) && cssDisplay !== "inline-block";
}
function isPreLikeNode(node) {
  return getNodeCssStyleWhiteSpace(node).startsWith("pre");
}
function hasParent(node, fn) {
  let current = node;
  while (current) {
    if (fn(current)) {
      return true;
    }
    current = current.parent;
  }
  return false;
}
function getNodeCssStyleDisplay(node, options9) {
  var _a, _b;
  if (((_a = node.prev) == null ? void 0 : _a.type) === "comment") {
    const match = node.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
    if (match) {
      return match[1];
    }
  }
  let isInSvgForeignObject = false;
  if (node.type === "element" && node.namespace === "svg") {
    if (hasParent(node, (parent) => parent.fullName === "svg:foreignObject")) {
      isInSvgForeignObject = true;
    } else {
      return node.name === "svg" ? "inline-block" : "block";
    }
  }
  switch (options9.htmlWhitespaceSensitivity) {
    case "strict":
      return "inline";
    case "ignore":
      return "block";
    default:
      if (options9.parser === "vue" && ((_b = node.parent) == null ? void 0 : _b.type) === "root") {
        return "block";
      }
      return node.type === "element" && (!node.namespace || isInSvgForeignObject || is_unknown_namespace_default(node)) && CSS_DISPLAY_TAGS[node.name] || CSS_DISPLAY_DEFAULT;
  }
}
function getNodeCssStyleWhiteSpace(node) {
  return node.type === "element" && (!node.namespace || is_unknown_namespace_default(node)) && CSS_WHITE_SPACE_TAGS[node.name] || CSS_WHITE_SPACE_DEFAULT;
}
function getMinIndentation(text) {
  let minIndentation = Number.POSITIVE_INFINITY;
  for (const lineText of text.split("\n")) {
    if (lineText.length === 0) {
      continue;
    }
    const indentation = html_whitespace_utils_default.getLeadingWhitespaceCount(lineText);
    if (indentation === 0) {
      return 0;
    }
    if (lineText.length === indentation) {
      continue;
    }
    if (indentation < minIndentation) {
      minIndentation = indentation;
    }
  }
  return minIndentation === Number.POSITIVE_INFINITY ? 0 : minIndentation;
}
function dedentString(text, minIndent = getMinIndentation(text)) {
  return minIndent === 0 ? text : text.split("\n").map((lineText) => lineText.slice(minIndent)).join("\n");
}
function countChars(text, char) {
  let counter = 0;
  for (let i = 0; i < text.length; i++) {
    if (text[i] === char) {
      counter++;
    }
  }
  return counter;
}
function unescapeQuoteEntities(text) {
  return string_replace_all_default(
    /* isOptionalObject*/
    false,
    string_replace_all_default(
      /* isOptionalObject*/
      false,
      text,
      "&apos;",
      "'"
    ),
    "&quot;",
    '"'
  );
}
var vueRootElementsSet = /* @__PURE__ */ new Set(["template", "style", "script"]);
function isVueCustomBlock(node, options9) {
  return isVueSfcBlock(node, options9) && !vueRootElementsSet.has(node.fullName);
}
function isVueSfcBlock(node, options9) {
  return options9.parser === "vue" && node.type === "element" && node.parent.type === "root" && node.fullName.toLowerCase() !== "html";
}
function isVueNonHtmlBlock(node, options9) {
  return isVueSfcBlock(node, options9) && (isVueCustomBlock(node, options9) || node.attrMap.lang && node.attrMap.lang !== "html");
}
function isVueSlotAttribute(attribute) {
  const attributeName = attribute.fullName;
  return attributeName.charAt(0) === "#" || attributeName === "slot-scope" || attributeName === "v-slot" || attributeName.startsWith("v-slot:");
}
function isVueSfcBindingsAttribute(attribute, options9) {
  const element = attribute.parent;
  if (!isVueSfcBlock(element, options9)) {
    return false;
  }
  const tagName = element.fullName;
  const attributeName = attribute.fullName;
  return (
    // https://github.com/vuejs/rfcs/blob/sfc-improvements/active-rfcs/0000-sfc-script-setup.md
    tagName === "script" && attributeName === "setup" || // https://github.com/vuejs/rfcs/blob/sfc-improvements/active-rfcs/0000-sfc-style-variables.md
    tagName === "style" && attributeName === "vars"
  );
}
function getTextValueParts2(node, value = node.value) {
  return node.parent.isWhitespaceSensitive ? node.parent.isIndentationSensitive ? replaceEndOfLine(value) : replaceEndOfLine(dedentString(htmlTrimPreserveIndentation(value)), hardline) : join(line, html_whitespace_utils_default.split(value));
}
function isVueScriptTag(node, options9) {
  return isVueSfcBlock(node, options9) && node.name === "script";
}

// node_modules/angular-html-parser/lib/compiler/src/parse_util.js
var ParseSourceSpan = class {
  /**
   * Create an object that holds information about spans of tokens/nodes captured during
   * lexing/parsing of text.
   *
   * @param start
   * The location of the start of the span (having skipped leading trivia).
   * Skipping leading trivia makes source-spans more "user friendly", since things like HTML
   * elements will appear to begin at the start of the opening tag, rather than at the start of any
   * leading trivia, which could include newlines.
   *
   * @param end
   * The location of the end of the span.
   *
   * @param fullStart
   * The start of the token without skipping the leading trivia.
   * This is used by tooling that splits tokens further, such as extracting Angular interpolations
   * from text tokens. Such tooling creates new source-spans relative to the original token's
   * source-span. If leading trivia characters have been skipped then the new source-spans may be
   * incorrectly offset.
   *
   * @param details
   * Additional information (such as identifier names) that should be associated with the span.
   */
  constructor(start, end, fullStart = start, details = null) {
    this.start = start;
    this.end = end;
    this.fullStart = fullStart;
    this.details = details;
  }
  toString() {
    return this.start.file.content.substring(this.start.offset, this.end.offset);
  }
};
var ParseErrorLevel;
(function(ParseErrorLevel2) {
  ParseErrorLevel2[ParseErrorLevel2["WARNING"] = 0] = "WARNING";
  ParseErrorLevel2[ParseErrorLevel2["ERROR"] = 1] = "ERROR";
})(ParseErrorLevel || (ParseErrorLevel = {}));

// src/language-html/print-preprocess.js
var PREPROCESS_PIPELINE = [
  removeIgnorableFirstLf,
  mergeIfConditionalStartEndCommentIntoElementOpeningTag,
  mergeCdataIntoText,
  extractInterpolation,
  extractWhitespaces,
  addCssDisplay,
  addIsSelfClosing,
  addHasHtmComponentClosingTag,
  addIsSpaceSensitive,
  mergeSimpleElementIntoText,
  markTsScript
];
function preprocess2(ast, options9) {
  for (const fn of PREPROCESS_PIPELINE) {
    fn(ast, options9);
  }
  return ast;
}
function removeIgnorableFirstLf(ast) {
  ast.walk((node) => {
    if (node.type === "element" && node.tagDefinition.ignoreFirstLf && node.children.length > 0 && node.children[0].type === "text" && node.children[0].value[0] === "\n") {
      const text = node.children[0];
      if (text.value.length === 1) {
        node.removeChild(text);
      } else {
        text.value = text.value.slice(1);
      }
    }
  });
}
function mergeIfConditionalStartEndCommentIntoElementOpeningTag(ast) {
  const isTarget = (node) => {
    var _a, _b;
    return node.type === "element" && ((_a = node.prev) == null ? void 0 : _a.type) === "ieConditionalStartComment" && node.prev.sourceSpan.end.offset === node.startSourceSpan.start.offset && ((_b = node.firstChild) == null ? void 0 : _b.type) === "ieConditionalEndComment" && node.firstChild.sourceSpan.start.offset === node.startSourceSpan.end.offset;
  };
  ast.walk((node) => {
    if (node.children) {
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        if (!isTarget(child)) {
          continue;
        }
        const ieConditionalStartComment = child.prev;
        const ieConditionalEndComment = child.firstChild;
        node.removeChild(ieConditionalStartComment);
        i--;
        const startSourceSpan = new ParseSourceSpan(
          ieConditionalStartComment.sourceSpan.start,
          ieConditionalEndComment.sourceSpan.end
        );
        const sourceSpan = new ParseSourceSpan(
          startSourceSpan.start,
          child.sourceSpan.end
        );
        child.condition = ieConditionalStartComment.condition;
        child.sourceSpan = sourceSpan;
        child.startSourceSpan = startSourceSpan;
        child.removeChild(ieConditionalEndComment);
      }
    }
  });
}
function mergeNodeIntoText(ast, shouldMerge, getValue) {
  ast.walk((node) => {
    if (node.children) {
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        if (child.type !== "text" && !shouldMerge(child)) {
          continue;
        }
        if (child.type !== "text") {
          child.type = "text";
          child.value = getValue(child);
        }
        const prevChild = child.prev;
        if (!prevChild || prevChild.type !== "text") {
          continue;
        }
        prevChild.value += child.value;
        prevChild.sourceSpan = new ParseSourceSpan(
          prevChild.sourceSpan.start,
          child.sourceSpan.end
        );
        node.removeChild(child);
        i--;
      }
    }
  });
}
function mergeCdataIntoText(ast) {
  return mergeNodeIntoText(
    ast,
    (node) => node.type === "cdata",
    (node) => `<![CDATA[${node.value}]]>`
  );
}
function mergeSimpleElementIntoText(ast) {
  const isSimpleElement = (node) => {
    var _a, _b;
    return node.type === "element" && node.attrs.length === 0 && node.children.length === 1 && node.firstChild.type === "text" && !html_whitespace_utils_default.hasWhitespaceCharacter(node.children[0].value) && !node.firstChild.hasLeadingSpaces && !node.firstChild.hasTrailingSpaces && node.isLeadingSpaceSensitive && !node.hasLeadingSpaces && node.isTrailingSpaceSensitive && !node.hasTrailingSpaces && ((_a = node.prev) == null ? void 0 : _a.type) === "text" && ((_b = node.next) == null ? void 0 : _b.type) === "text";
  };
  ast.walk((node) => {
    if (node.children) {
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        if (!isSimpleElement(child)) {
          continue;
        }
        const prevChild = child.prev;
        const nextChild = child.next;
        prevChild.value += `<${child.rawName}>` + child.firstChild.value + `</${child.rawName}>` + nextChild.value;
        prevChild.sourceSpan = new ParseSourceSpan(
          prevChild.sourceSpan.start,
          nextChild.sourceSpan.end
        );
        prevChild.isTrailingSpaceSensitive = nextChild.isTrailingSpaceSensitive;
        prevChild.hasTrailingSpaces = nextChild.hasTrailingSpaces;
        node.removeChild(child);
        i--;
        node.removeChild(nextChild);
      }
    }
  });
}
function extractInterpolation(ast, options9) {
  if (options9.parser === "html") {
    return;
  }
  const interpolationRegex = /{{(.+?)}}/s;
  ast.walk((node) => {
    if (!canHaveInterpolation(node)) {
      return;
    }
    for (const child of node.children) {
      if (child.type !== "text") {
        continue;
      }
      let startSourceSpan = child.sourceSpan.start;
      let endSourceSpan = null;
      const components = child.value.split(interpolationRegex);
      for (let i = 0; i < components.length; i++, startSourceSpan = endSourceSpan) {
        const value = components[i];
        if (i % 2 === 0) {
          endSourceSpan = startSourceSpan.moveBy(value.length);
          if (value.length > 0) {
            node.insertChildBefore(child, {
              type: "text",
              value,
              sourceSpan: new ParseSourceSpan(startSourceSpan, endSourceSpan)
            });
          }
          continue;
        }
        endSourceSpan = startSourceSpan.moveBy(value.length + 4);
        node.insertChildBefore(child, {
          type: "interpolation",
          sourceSpan: new ParseSourceSpan(startSourceSpan, endSourceSpan),
          children: value.length === 0 ? [] : [
            {
              type: "text",
              value,
              sourceSpan: new ParseSourceSpan(
                startSourceSpan.moveBy(2),
                endSourceSpan.moveBy(-2)
              )
            }
          ]
        });
      }
      node.removeChild(child);
    }
  });
}
function extractWhitespaces(ast) {
  ast.walk((node) => {
    if (!node.children) {
      return;
    }
    if (node.children.length === 0 || node.children.length === 1 && node.children[0].type === "text" && html_whitespace_utils_default.trim(node.children[0].value).length === 0) {
      node.hasDanglingSpaces = node.children.length > 0;
      node.children = [];
      return;
    }
    const isWhitespaceSensitive = isWhitespaceSensitiveNode(node);
    const isIndentationSensitive = isIndentationSensitiveNode(node);
    if (!isWhitespaceSensitive) {
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        if (child.type !== "text") {
          continue;
        }
        const { leadingWhitespace, text, trailingWhitespace } = getLeadingAndTrailingHtmlWhitespace(child.value);
        const prevChild = child.prev;
        const nextChild = child.next;
        if (!text) {
          node.removeChild(child);
          i--;
          if (leadingWhitespace || trailingWhitespace) {
            if (prevChild) {
              prevChild.hasTrailingSpaces = true;
            }
            if (nextChild) {
              nextChild.hasLeadingSpaces = true;
            }
          }
        } else {
          child.value = text;
          child.sourceSpan = new ParseSourceSpan(
            child.sourceSpan.start.moveBy(leadingWhitespace.length),
            child.sourceSpan.end.moveBy(-trailingWhitespace.length)
          );
          if (leadingWhitespace) {
            if (prevChild) {
              prevChild.hasTrailingSpaces = true;
            }
            child.hasLeadingSpaces = true;
          }
          if (trailingWhitespace) {
            child.hasTrailingSpaces = true;
            if (nextChild) {
              nextChild.hasLeadingSpaces = true;
            }
          }
        }
      }
    }
    node.isWhitespaceSensitive = isWhitespaceSensitive;
    node.isIndentationSensitive = isIndentationSensitive;
  });
}
function addIsSelfClosing(ast) {
  ast.walk((node) => {
    node.isSelfClosing = !node.children || node.type === "element" && (node.tagDefinition.isVoid || // self-closing
    node.endSourceSpan && node.startSourceSpan.start === node.endSourceSpan.start && node.startSourceSpan.end === node.endSourceSpan.end);
  });
}
function addHasHtmComponentClosingTag(ast, options9) {
  ast.walk((node) => {
    if (node.type !== "element") {
      return;
    }
    node.hasHtmComponentClosingTag = node.endSourceSpan && /^<\s*\/\s*\/\s*>$/.test(
      options9.originalText.slice(
        node.endSourceSpan.start.offset,
        node.endSourceSpan.end.offset
      )
    );
  });
}
function addCssDisplay(ast, options9) {
  ast.walk((node) => {
    node.cssDisplay = getNodeCssStyleDisplay(node, options9);
  });
}
function addIsSpaceSensitive(ast, options9) {
  ast.walk((node) => {
    const { children } = node;
    if (!children) {
      return;
    }
    if (children.length === 0) {
      node.isDanglingSpaceSensitive = isDanglingSpaceSensitiveNode(node);
      return;
    }
    for (const child of children) {
      child.isLeadingSpaceSensitive = isLeadingSpaceSensitiveNode(
        child,
        options9
      );
      child.isTrailingSpaceSensitive = isTrailingSpaceSensitiveNode(
        child,
        options9
      );
    }
    for (let index = 0; index < children.length; index++) {
      const child = children[index];
      child.isLeadingSpaceSensitive = index === 0 ? child.isLeadingSpaceSensitive : child.prev.isTrailingSpaceSensitive && child.isLeadingSpaceSensitive;
      child.isTrailingSpaceSensitive = index === children.length - 1 ? child.isTrailingSpaceSensitive : child.next.isLeadingSpaceSensitive && child.isTrailingSpaceSensitive;
    }
  });
}
function markTsScript(ast, options9) {
  if (options9.parser === "vue") {
    const vueScriptTag = ast.children.find(
      (child) => isVueScriptTag(child, options9)
    );
    if (!vueScriptTag) {
      return;
    }
    const { lang } = vueScriptTag.attrMap;
    if (lang === "ts" || lang === "typescript") {
      options9.__should_parse_vue_template_with_ts = true;
    }
  }
}
var print_preprocess_default2 = preprocess2;

// src/language-html/pragma.js
function insertPragma5(text) {
  return "<!-- @format -->\n\n" + text.replace(/^\s*\n/, "");
}

// src/language-html/loc.js
function locStart6(node) {
  return node.sourceSpan.start.offset;
}
function locEnd6(node) {
  return node.sourceSpan.end.offset;
}

// src/language-html/print/tag.js
import assert7 from "assert";
function printClosingTag(node, options9) {
  return [
    node.isSelfClosing ? "" : printClosingTagStart(node, options9),
    printClosingTagEnd(node, options9)
  ];
}
function printClosingTagStart(node, options9) {
  return node.lastChild && needsToBorrowParentClosingTagStartMarker(node.lastChild) ? "" : [
    printClosingTagPrefix(node, options9),
    printClosingTagStartMarker(node, options9)
  ];
}
function printClosingTagEnd(node, options9) {
  return (node.next ? needsToBorrowPrevClosingTagEndMarker(node.next) : needsToBorrowLastChildClosingTagEndMarker(node.parent)) ? "" : [
    printClosingTagEndMarker(node, options9),
    printClosingTagSuffix(node, options9)
  ];
}
function printClosingTagPrefix(node, options9) {
  return needsToBorrowLastChildClosingTagEndMarker(node) ? printClosingTagEndMarker(node.lastChild, options9) : "";
}
function printClosingTagSuffix(node, options9) {
  return needsToBorrowParentClosingTagStartMarker(node) ? printClosingTagStartMarker(node.parent, options9) : needsToBorrowNextOpeningTagStartMarker(node) ? printOpeningTagStartMarker(node.next) : "";
}
function printClosingTagStartMarker(node, options9) {
  assert7(!node.isSelfClosing);
  if (shouldNotPrintClosingTag(node, options9)) {
    return "";
  }
  switch (node.type) {
    case "ieConditionalComment":
      return "<!";
    case "element":
      if (node.hasHtmComponentClosingTag) {
        return "<//";
      }
    default:
      return `</${node.rawName}`;
  }
}
function printClosingTagEndMarker(node, options9) {
  if (shouldNotPrintClosingTag(node, options9)) {
    return "";
  }
  switch (node.type) {
    case "ieConditionalComment":
    case "ieConditionalEndComment":
      return "[endif]-->";
    case "ieConditionalStartComment":
      return "]><!-->";
    case "interpolation":
      return "}}";
    case "element":
      if (node.isSelfClosing) {
        return "/>";
      }
    default:
      return ">";
  }
}
function shouldNotPrintClosingTag(node, options9) {
  return !node.isSelfClosing && !node.endSourceSpan && (hasPrettierIgnore5(node) || shouldPreserveContent(node.parent, options9));
}
function needsToBorrowPrevClosingTagEndMarker(node) {
  return node.prev && node.prev.type !== "docType" && !isTextLikeNode(node.prev) && node.isLeadingSpaceSensitive && !node.hasLeadingSpaces;
}
function needsToBorrowLastChildClosingTagEndMarker(node) {
  var _a;
  return ((_a = node.lastChild) == null ? void 0 : _a.isTrailingSpaceSensitive) && !node.lastChild.hasTrailingSpaces && !isTextLikeNode(getLastDescendant(node.lastChild)) && !isPreLikeNode(node);
}
function needsToBorrowParentClosingTagStartMarker(node) {
  return !node.next && !node.hasTrailingSpaces && node.isTrailingSpaceSensitive && isTextLikeNode(getLastDescendant(node));
}
function needsToBorrowNextOpeningTagStartMarker(node) {
  return node.next && !isTextLikeNode(node.next) && isTextLikeNode(node) && node.isTrailingSpaceSensitive && !node.hasTrailingSpaces;
}
function getPrettierIgnoreAttributeCommentData(value) {
  const match = value.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/s);
  if (!match) {
    return false;
  }
  if (!match[1]) {
    return true;
  }
  return match[1].split(/\s+/);
}
function needsToBorrowParentOpeningTagEndMarker(node) {
  return !node.prev && node.isLeadingSpaceSensitive && !node.hasLeadingSpaces;
}
function printAttributes(path11, options9, print4) {
  var _a;
  const { node } = path11;
  if (!is_non_empty_array_default(node.attrs)) {
    return node.isSelfClosing ? (
      /**
       *     <br />
       *        ^
       */
      " "
    ) : "";
  }
  const ignoreAttributeData = ((_a = node.prev) == null ? void 0 : _a.type) === "comment" && getPrettierIgnoreAttributeCommentData(node.prev.value);
  const hasPrettierIgnoreAttribute = typeof ignoreAttributeData === "boolean" ? () => ignoreAttributeData : Array.isArray(ignoreAttributeData) ? (attribute) => ignoreAttributeData.includes(attribute.rawName) : () => false;
  const printedAttributes = path11.map(
    ({ node: attribute }) => hasPrettierIgnoreAttribute(attribute) ? replaceEndOfLine(
      options9.originalText.slice(locStart6(attribute), locEnd6(attribute))
    ) : print4(),
    "attrs"
  );
  const forceNotToBreakAttrContent = node.type === "element" && node.fullName === "script" && node.attrs.length === 1 && node.attrs[0].fullName === "src" && node.children.length === 0;
  const shouldPrintAttributePerLine = options9.singleAttributePerLine && node.attrs.length > 1 && !isVueSfcBlock(node, options9);
  const attributeLine = shouldPrintAttributePerLine ? hardline : line;
  const parts = [
    indent([
      forceNotToBreakAttrContent ? " " : line,
      join(attributeLine, printedAttributes)
    ])
  ];
  if (
    /**
     *     123<a
     *       attr
     *           ~
     *       >456
     */
    node.firstChild && needsToBorrowParentOpeningTagEndMarker(node.firstChild) || /**
     *     <span
     *       >123<meta
     *                ~
     *     /></span>
     */
    node.isSelfClosing && needsToBorrowLastChildClosingTagEndMarker(node.parent) || forceNotToBreakAttrContent
  ) {
    parts.push(node.isSelfClosing ? " " : "");
  } else {
    parts.push(
      options9.bracketSameLine ? node.isSelfClosing ? " " : "" : node.isSelfClosing ? line : softline
    );
  }
  return parts;
}
function printOpeningTagEnd(node) {
  return node.firstChild && needsToBorrowParentOpeningTagEndMarker(node.firstChild) ? "" : printOpeningTagEndMarker(node);
}
function printOpeningTag(path11, options9, print4) {
  const { node } = path11;
  return [
    printOpeningTagStart(node, options9),
    printAttributes(path11, options9, print4),
    node.isSelfClosing ? "" : printOpeningTagEnd(node)
  ];
}
function printOpeningTagStart(node, options9) {
  return node.prev && needsToBorrowNextOpeningTagStartMarker(node.prev) ? "" : [printOpeningTagPrefix(node, options9), printOpeningTagStartMarker(node)];
}
function printOpeningTagPrefix(node, options9) {
  return needsToBorrowParentOpeningTagEndMarker(node) ? printOpeningTagEndMarker(node.parent) : needsToBorrowPrevClosingTagEndMarker(node) ? printClosingTagEndMarker(node.prev, options9) : "";
}
function printOpeningTagStartMarker(node) {
  switch (node.type) {
    case "ieConditionalComment":
    case "ieConditionalStartComment":
      return `<!--[if ${node.condition}`;
    case "ieConditionalEndComment":
      return "<!--<!";
    case "interpolation":
      return "{{";
    case "docType":
      return node.value === "html" ? "<!doctype" : "<!DOCTYPE";
    case "element":
      if (node.condition) {
        return `<!--[if ${node.condition}]><!--><${node.rawName}`;
      }
    default:
      return `<${node.rawName}`;
  }
}
function printOpeningTagEndMarker(node) {
  assert7(!node.isSelfClosing);
  switch (node.type) {
    case "ieConditionalComment":
      return "]>";
    case "element":
      if (node.condition) {
        return "><!--<![endif]-->";
      }
    default:
      return ">";
  }
}

// node_modules/@prettier/parse-srcset/src/parse-srcset.js
function parseSrcset(input) {
  function isSpace(c2) {
    return c2 === " " || // space
    c2 === "	" || // horizontal tab
    c2 === "\n" || // new line
    c2 === "\f" || // form feed
    c2 === "\r";
  }
  function collectCharacters(regEx) {
    var chars, match = regEx.exec(input.substring(pos));
    if (match) {
      chars = match[0];
      pos += chars.length;
      return chars;
    }
  }
  var inputLength = input.length, regexLeadingSpaces = /^[ \t\n\r\u000c]+/, regexLeadingCommasOrSpaces = /^[, \t\n\r\u000c]+/, regexLeadingNotSpaces = /^[^ \t\n\r\u000c]+/, regexTrailingCommas = /[,]+$/, regexNonNegativeInteger = /^\d+$/, regexFloatingPoint = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, url, descriptors, currentDescriptor, state, c, pos = 0, candidates = [];
  while (true) {
    collectCharacters(regexLeadingCommasOrSpaces);
    if (pos >= inputLength) {
      return candidates;
    }
    url = collectCharacters(regexLeadingNotSpaces);
    descriptors = [];
    if (url.slice(-1) === ",") {
      url = url.replace(regexTrailingCommas, "");
      parseDescriptors();
    } else {
      tokenize();
    }
  }
  function tokenize() {
    collectCharacters(regexLeadingSpaces);
    currentDescriptor = "";
    state = "in descriptor";
    while (true) {
      c = input.charAt(pos);
      if (state === "in descriptor") {
        if (isSpace(c)) {
          if (currentDescriptor) {
            descriptors.push(currentDescriptor);
            currentDescriptor = "";
            state = "after descriptor";
          }
        } else if (c === ",") {
          pos += 1;
          if (currentDescriptor) {
            descriptors.push(currentDescriptor);
          }
          parseDescriptors();
          return;
        } else if (c === "(") {
          currentDescriptor = currentDescriptor + c;
          state = "in parens";
        } else if (c === "") {
          if (currentDescriptor) {
            descriptors.push(currentDescriptor);
          }
          parseDescriptors();
          return;
        } else {
          currentDescriptor = currentDescriptor + c;
        }
      } else if (state === "in parens") {
        if (c === ")") {
          currentDescriptor = currentDescriptor + c;
          state = "in descriptor";
        } else if (c === "") {
          descriptors.push(currentDescriptor);
          parseDescriptors();
          return;
        } else {
          currentDescriptor = currentDescriptor + c;
        }
      } else if (state === "after descriptor") {
        if (isSpace(c)) {
        } else if (c === "") {
          parseDescriptors();
          return;
        } else {
          state = "in descriptor";
          pos -= 1;
        }
      }
      pos += 1;
    }
  }
  function parseDescriptors() {
    var pError = false, w, d, h, i, candidate = {}, desc, lastChar, value, intVal, floatVal;
    for (i = 0; i < descriptors.length; i++) {
      desc = descriptors[i];
      lastChar = desc[desc.length - 1];
      value = desc.substring(0, desc.length - 1);
      intVal = parseInt(value, 10);
      floatVal = parseFloat(value);
      if (regexNonNegativeInteger.test(value) && lastChar === "w") {
        if (w || d) {
          pError = true;
        }
        if (intVal === 0) {
          pError = true;
        } else {
          w = intVal;
        }
      } else if (regexFloatingPoint.test(value) && lastChar === "x") {
        if (w || d || h) {
          pError = true;
        }
        if (floatVal < 0) {
          pError = true;
        } else {
          d = floatVal;
        }
      } else if (regexNonNegativeInteger.test(value) && lastChar === "h") {
        if (h || d) {
          pError = true;
        }
        if (intVal === 0) {
          pError = true;
        } else {
          h = intVal;
        }
      } else {
        pError = true;
      }
    }
    if (!pError) {
      candidate.url = url;
      if (w) {
        candidate.w = w;
      }
      if (d) {
        candidate.d = d;
      }
      if (h) {
        candidate.h = h;
      }
      candidates.push(candidate);
    } else {
      throw new SyntaxError("Invalid srcset descriptor found in '" + input + "' at '" + desc + "'.");
    }
  }
}
var parse_srcset_default = parseSrcset;

// src/language-html/syntax-attribute.js
function printImgSrcset(value) {
  const srcset = parse_srcset_default(value);
  const hasW = srcset.some(({ w }) => w);
  const hasH = srcset.some(({ h }) => h);
  const hasX = srcset.some(({ d }) => d);
  if (hasW + hasH + hasX > 1) {
    throw new Error("Mixed descriptor in srcset is not supported");
  }
  const key = hasW ? "w" : hasH ? "h" : "d";
  const unit = hasW ? "w" : hasH ? "h" : "x";
  const getMax = (values) => Math.max(...values);
  const urls = srcset.map((src) => src.url);
  const maxUrlLength = getMax(urls.map((url) => url.length));
  const descriptors = srcset.map((src) => src[key]).map((descriptor) => descriptor ? descriptor.toString() : "");
  const descriptorLeftLengths = descriptors.map((descriptor) => {
    const index = descriptor.indexOf(".");
    return index === -1 ? descriptor.length : index;
  });
  const maxDescriptorLeftLength = getMax(descriptorLeftLengths);
  return join(
    [",", line],
    urls.map((url, index) => {
      const parts = [url];
      const descriptor = descriptors[index];
      if (descriptor) {
        const urlPadding = maxUrlLength - url.length + 1;
        const descriptorPadding = maxDescriptorLeftLength - descriptorLeftLengths[index];
        const alignment = " ".repeat(urlPadding + descriptorPadding);
        parts.push(ifBreak(alignment, " "), descriptor + unit);
      }
      return parts;
    })
  );
}
function printClassNames(value) {
  return value.trim().split(/\s+/).join(" ");
}

// src/language-html/syntax-vue.js
async function printVueFor(value, attributeTextToDoc) {
  const {
    left,
    operator,
    right
  } = parseVueFor(value);
  return [group(await attributeTextToDoc(`function _(${left}) {}`, {
    parser: "babel",
    __isVueForBindingLeft: true
  })), " ", operator, " ", await attributeTextToDoc(right, {
    parser: "__js_expression"
  })];
}
function parseVueFor(value) {
  const forAliasRE = /(.*?)\s+(in|of)\s+(.*)/s;
  const forIteratorRE = /,([^,\]}]*)(?:,([^,\]}]*))?$/;
  const stripParensRE = /^\(|\)$/g;
  const inMatch = value.match(forAliasRE);
  if (!inMatch) {
    return;
  }
  const res = {};
  res.for = inMatch[3].trim();
  if (!res.for) {
    return;
  }
  const alias = string_replace_all_default(
    /* isOptionalObject*/
    false,
    inMatch[1].trim(),
    stripParensRE,
    ""
  );
  const iteratorMatch = alias.match(forIteratorRE);
  if (iteratorMatch) {
    res.alias = alias.replace(forIteratorRE, "");
    res.iterator1 = iteratorMatch[1].trim();
    if (iteratorMatch[2]) {
      res.iterator2 = iteratorMatch[2].trim();
    }
  } else {
    res.alias = alias;
  }
  const left = [res.alias, res.iterator1, res.iterator2];
  if (left.some((part, index) => !part && (index === 0 || left.slice(index + 1).some(Boolean)))) {
    return;
  }
  return {
    left: left.filter(Boolean).join(","),
    operator: inMatch[2],
    right: res.for
  };
}
function printVueBindings(value, attributeTextToDoc) {
  return attributeTextToDoc(`function _(${value}) {}`, {
    parser: "babel",
    __isVueBindings: true
  });
}
function isVueEventBindingExpression2(eventBindingValue) {
  const fnExpRE = /^(?:[\w$]+|\([^)]*\))\s*=>|^function\s*\(/;
  const simplePathRE = /^[$A-Z_a-z][\w$]*(?:\.[$A-Z_a-z][\w$]*|\['[^']*']|\["[^"]*"]|\[\d+]|\[[$A-Z_a-z][\w$]*])*$/;
  const value = eventBindingValue.trim();
  return fnExpRE.test(value) || simplePathRE.test(value);
}

// src/language-html/get-node-content.js
function getNodeContent(node, options9) {
  let start = node.startSourceSpan.end.offset;
  if (node.firstChild && needsToBorrowParentOpeningTagEndMarker(node.firstChild)) {
    start -= printOpeningTagEndMarker(node).length;
  }
  let end = node.endSourceSpan.start.offset;
  if (node.lastChild && needsToBorrowParentClosingTagStartMarker(node.lastChild)) {
    end += printClosingTagStartMarker(node, options9).length;
  } else if (needsToBorrowLastChildClosingTagEndMarker(node)) {
    end -= printClosingTagEndMarker(node.lastChild, options9).length;
  }
  return options9.originalText.slice(start, end);
}
var get_node_content_default = getNodeContent;

// src/language-html/embed.js
async function printEmbeddedAttributeValue(node, htmlTextToDoc, options9) {
  const isKeyMatched = (patterns) => new RegExp(patterns.join("|")).test(node.fullName);
  const getValue = () => unescapeQuoteEntities(node.value);
  let shouldHug = false;
  const __onHtmlBindingRoot = (root, options10) => {
    const rootNode = root.type === "NGRoot" ? root.node.type === "NGMicrosyntax" && root.node.body.length === 1 && root.node.body[0].type === "NGMicrosyntaxExpression" ? root.node.body[0].expression : root.node : root.type === "JsExpressionRoot" ? root.node : root;
    if (rootNode && (rootNode.type === "ObjectExpression" || rootNode.type === "ArrayExpression" || options10.parser === "__vue_expression" && (rootNode.type === "TemplateLiteral" || rootNode.type === "StringLiteral"))) {
      shouldHug = true;
    }
  };
  const printHug = (doc2) => group(doc2);
  const printExpand = (doc2, canHaveTrailingWhitespace = true) => group([indent([softline, doc2]), canHaveTrailingWhitespace ? softline : ""]);
  const printMaybeHug = (doc2) => shouldHug ? printHug(doc2) : printExpand(doc2);
  const attributeTextToDoc = (code, opts) => htmlTextToDoc(code, {
    __onHtmlBindingRoot,
    __embeddedInHtml: true,
    ...opts
  });
  if (node.fullName === "srcset" && (node.parent.fullName === "img" || node.parent.fullName === "source")) {
    return printExpand(printImgSrcset(getValue()));
  }
  if (node.fullName === "class" && !options9.parentParser) {
    const value = getValue();
    if (!value.includes("{{")) {
      return printClassNames(value);
    }
  }
  if (node.fullName === "style" && !options9.parentParser) {
    const value = getValue();
    if (!value.includes("{{")) {
      return printExpand(await attributeTextToDoc(value, {
        parser: "css",
        __isHTMLStyleAttribute: true
      }));
    }
  }
  if (options9.parser === "vue") {
    if (node.fullName === "v-for") {
      return printVueFor(getValue(), attributeTextToDoc);
    }
    if (isVueSlotAttribute(node) || isVueSfcBindingsAttribute(node, options9)) {
      return printVueBindings(getValue(), attributeTextToDoc);
    }
    const vueEventBindingPatterns = ["^@", "^v-on:"];
    const vueExpressionBindingPatterns = ["^:", "^v-bind:"];
    const jsExpressionBindingPatterns = ["^v-"];
    if (isKeyMatched(vueEventBindingPatterns)) {
      const value = getValue();
      const parser = isVueEventBindingExpression2(value) ? "__js_expression" : options9.__should_parse_vue_template_with_ts ? "__vue_ts_event_binding" : "__vue_event_binding";
      return printMaybeHug(await attributeTextToDoc(value, {
        parser
      }));
    }
    if (isKeyMatched(vueExpressionBindingPatterns)) {
      return printMaybeHug(await attributeTextToDoc(getValue(), {
        parser: "__vue_expression"
      }));
    }
    if (isKeyMatched(jsExpressionBindingPatterns)) {
      return printMaybeHug(await attributeTextToDoc(getValue(), {
        parser: "__js_expression"
      }));
    }
  }
  if (options9.parser === "angular") {
    const ngTextToDoc = (code, opts) => (
      // angular does not allow trailing comma
      attributeTextToDoc(code, {
        ...opts,
        trailingComma: "none"
      })
    );
    const ngDirectiveBindingPatterns = ["^\\*"];
    const ngStatementBindingPatterns = ["^\\(.+\\)$", "^on-"];
    const ngExpressionBindingPatterns = [
      "^\\[.+\\]$",
      "^bind(on)?-",
      // Unofficial rudimentary support for some of the most used directives of AngularJS 1.x
      "^ng-(if|show|hide|class|style)$"
    ];
    const ngI18nPatterns = ["^i18n(-.+)?$"];
    if (isKeyMatched(ngStatementBindingPatterns)) {
      return printMaybeHug(await ngTextToDoc(getValue(), {
        parser: "__ng_action"
      }));
    }
    if (isKeyMatched(ngExpressionBindingPatterns)) {
      return printMaybeHug(await ngTextToDoc(getValue(), {
        parser: "__ng_binding"
      }));
    }
    if (isKeyMatched(ngI18nPatterns)) {
      const value2 = getValue().trim();
      return printExpand(fill(getTextValueParts2(node, value2)), !value2.includes("@@"));
    }
    if (isKeyMatched(ngDirectiveBindingPatterns)) {
      return printMaybeHug(await ngTextToDoc(getValue(), {
        parser: "__ng_directive"
      }));
    }
    const interpolationRegex = /{{(.+?)}}/s;
    const value = getValue();
    if (interpolationRegex.test(value)) {
      const parts = [];
      for (const [index, part] of value.split(interpolationRegex).entries()) {
        if (index % 2 === 0) {
          parts.push(replaceEndOfLine(part));
        } else {
          try {
            parts.push(group(["{{", indent([line, await ngTextToDoc(part, {
              parser: "__ng_interpolation",
              __isInHtmlInterpolation: true
              // to avoid unexpected `}}`
            })]), line, "}}"]));
          } catch {
            parts.push("{{", replaceEndOfLine(part), "}}");
          }
        }
      }
      return group(parts);
    }
  }
  return null;
}
function embed4(path11, options9) {
  const {
    node
  } = path11;
  switch (node.type) {
    case "element":
      if (isScriptLikeTag(node) || node.type === "interpolation") {
        return;
      }
      if (!node.isSelfClosing && isVueNonHtmlBlock(node, options9)) {
        const parser = inferScriptParser(node, options9);
        if (!parser) {
          return;
        }
        return async (textToDoc2, print4) => {
          const content = get_node_content_default(node, options9);
          let isEmpty = /^\s*$/.test(content);
          let doc2 = "";
          if (!isEmpty) {
            doc2 = await textToDoc2(htmlTrimPreserveIndentation(content), {
              parser,
              __embeddedInHtml: true
            });
            isEmpty = doc2 === "";
          }
          return [printOpeningTagPrefix(node, options9), group(printOpeningTag(path11, options9, print4)), isEmpty ? "" : hardline, doc2, isEmpty ? "" : hardline, printClosingTag(node, options9), printClosingTagSuffix(node, options9)];
        };
      }
      break;
    case "text":
      if (isScriptLikeTag(node.parent)) {
        const parser = inferScriptParser(node.parent, options9);
        if (parser) {
          return async (textToDoc2) => {
            const value = parser === "markdown" ? dedentString(node.value.replace(/^[^\S\n]*\n/, "")) : node.value;
            const textToDocOptions = {
              parser,
              __embeddedInHtml: true
            };
            if (options9.parser === "html" && parser === "babel") {
              let sourceType = "script";
              const {
                attrMap
              } = node.parent;
              if (attrMap && (attrMap.type === "module" || attrMap.type === "text/babel" && attrMap["data-type"] === "module")) {
                sourceType = "module";
              }
              textToDocOptions.__babelSourceType = sourceType;
            }
            return [breakParent, printOpeningTagPrefix(node, options9), await textToDoc2(value, textToDocOptions, {
              stripTrailingHardline: true
            }), printClosingTagSuffix(node, options9)];
          };
        }
      } else if (node.parent.type === "interpolation") {
        return async (textToDoc2) => {
          const textToDocOptions = {
            __isInHtmlInterpolation: true,
            // to avoid unexpected `}}`
            __embeddedInHtml: true
          };
          if (options9.parser === "angular") {
            textToDocOptions.parser = "__ng_interpolation";
            textToDocOptions.trailingComma = "none";
          } else if (options9.parser === "vue") {
            textToDocOptions.parser = options9.__should_parse_vue_template_with_ts ? "__vue_ts_expression" : "__vue_expression";
          } else {
            textToDocOptions.parser = "__js_expression";
          }
          return [indent([line, await textToDoc2(node.value, textToDocOptions)]), node.parent.next && needsToBorrowPrevClosingTagEndMarker(node.parent.next) ? " " : line];
        };
      }
      break;
    case "attribute":
      if (!node.value) {
        break;
      }
      if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(options9.originalText.slice(node.valueSpan.start.offset, node.valueSpan.end.offset))) {
        return [node.rawName, "=", node.value];
      }
      if (options9.parser === "lwc") {
        const interpolationRegex = /^{.*}$/s;
        if (interpolationRegex.test(options9.originalText.slice(node.valueSpan.start.offset, node.valueSpan.end.offset))) {
          return [node.rawName, "=", node.value];
        }
      }
      return async (textToDoc2) => {
        const embeddedAttributeValueDoc = await printEmbeddedAttributeValue(node, (code, opts) => (
          // strictly prefer single quote to avoid unnecessary html entity escape
          textToDoc2(code, {
            __isInHtmlAttribute: true,
            __embeddedInHtml: true,
            ...opts
          })
        ), options9);
        if (embeddedAttributeValueDoc) {
          return [node.rawName, '="', group(mapDoc(embeddedAttributeValueDoc, (doc2) => typeof doc2 === "string" ? string_replace_all_default(
            /* isOptionalObject*/
            false,
            doc2,
            '"',
            "&quot;"
          ) : doc2)), '"'];
        }
      };
    case "front-matter":
      return (textToDoc2) => print_default(node, textToDoc2);
  }
}
var embed_default4 = embed4;

// src/language-html/print/children.js
function printChild(childPath, options9, print4) {
  const child = childPath.node;
  if (hasPrettierIgnore5(child)) {
    return [
      printOpeningTagPrefix(child, options9),
      replaceEndOfLine(
        options9.originalText.slice(
          locStart6(child) + (child.prev && needsToBorrowNextOpeningTagStartMarker(child.prev) ? printOpeningTagStartMarker(child).length : 0),
          locEnd6(child) - (child.next && needsToBorrowPrevClosingTagEndMarker(child.next) ? printClosingTagEndMarker(child, options9).length : 0)
        )
      ),
      printClosingTagSuffix(child, options9)
    ];
  }
  return print4();
}
function printBetweenLine(prevNode, nextNode) {
  return isTextLikeNode(prevNode) && isTextLikeNode(nextNode) ? prevNode.isTrailingSpaceSensitive ? prevNode.hasTrailingSpaces ? preferHardlineAsLeadingSpaces(nextNode) ? hardline : line : "" : preferHardlineAsLeadingSpaces(nextNode) ? hardline : softline : needsToBorrowNextOpeningTagStartMarker(prevNode) && (hasPrettierIgnore5(nextNode) || /**
   *     123<a
   *          ~
   *       ><b>
   */
  nextNode.firstChild || /**
   *     123<!--
   *            ~
   *     -->
   */
  nextNode.isSelfClosing || /**
   *     123<span
   *             ~
   *       attr
   */
  nextNode.type === "element" && nextNode.attrs.length > 0) || /**
   *     <img
   *       src="long"
   *                 ~
   *     />123
   */
  prevNode.type === "element" && prevNode.isSelfClosing && needsToBorrowPrevClosingTagEndMarker(nextNode) ? "" : !nextNode.isLeadingSpaceSensitive || preferHardlineAsLeadingSpaces(nextNode) || /**
   *       Want to write us a letter? Use our<a
   *         ><b><a>mailing address</a></b></a
   *                                          ~
   *       >.
   */
  needsToBorrowPrevClosingTagEndMarker(nextNode) && prevNode.lastChild && needsToBorrowParentClosingTagStartMarker(prevNode.lastChild) && prevNode.lastChild.lastChild && needsToBorrowParentClosingTagStartMarker(prevNode.lastChild.lastChild) ? hardline : nextNode.hasLeadingSpaces ? line : softline;
}
function printChildren3(path11, options9, print4) {
  const { node } = path11;
  if (forceBreakChildren(node)) {
    return [
      breakParent,
      ...path11.map((childPath) => {
        const childNode = childPath.node;
        const prevBetweenLine = !childNode.prev ? "" : printBetweenLine(childNode.prev, childNode);
        return [
          !prevBetweenLine ? "" : [
            prevBetweenLine,
            forceNextEmptyLine(childNode.prev) ? hardline : ""
          ],
          printChild(childPath, options9, print4)
        ];
      }, "children")
    ];
  }
  const groupIds = node.children.map(() => Symbol(""));
  return path11.map((childPath, childIndex) => {
    const childNode = childPath.node;
    if (isTextLikeNode(childNode)) {
      if (childNode.prev && isTextLikeNode(childNode.prev)) {
        const prevBetweenLine2 = printBetweenLine(childNode.prev, childNode);
        if (prevBetweenLine2) {
          if (forceNextEmptyLine(childNode.prev)) {
            return [hardline, hardline, printChild(childPath, options9, print4)];
          }
          return [prevBetweenLine2, printChild(childPath, options9, print4)];
        }
      }
      return printChild(childPath, options9, print4);
    }
    const prevParts = [];
    const leadingParts = [];
    const trailingParts = [];
    const nextParts = [];
    const prevBetweenLine = childNode.prev ? printBetweenLine(childNode.prev, childNode) : "";
    const nextBetweenLine = childNode.next ? printBetweenLine(childNode, childNode.next) : "";
    if (prevBetweenLine) {
      if (forceNextEmptyLine(childNode.prev)) {
        prevParts.push(hardline, hardline);
      } else if (prevBetweenLine === hardline) {
        prevParts.push(hardline);
      } else if (isTextLikeNode(childNode.prev)) {
        leadingParts.push(prevBetweenLine);
      } else {
        leadingParts.push(
          ifBreak("", softline, {
            groupId: groupIds[childIndex - 1]
          })
        );
      }
    }
    if (nextBetweenLine) {
      if (forceNextEmptyLine(childNode)) {
        if (isTextLikeNode(childNode.next)) {
          nextParts.push(hardline, hardline);
        }
      } else if (nextBetweenLine === hardline) {
        if (isTextLikeNode(childNode.next)) {
          nextParts.push(hardline);
        }
      } else {
        trailingParts.push(nextBetweenLine);
      }
    }
    return [
      ...prevParts,
      group([
        ...leadingParts,
        group([printChild(childPath, options9, print4), ...trailingParts], {
          id: groupIds[childIndex]
        })
      ]),
      ...nextParts
    ];
  }, "children");
}

// src/language-html/print/element.js
function printElement(path11, options9, print4) {
  const { node } = path11;
  if (shouldPreserveContent(node, options9)) {
    return [
      printOpeningTagPrefix(node, options9),
      group(printOpeningTag(path11, options9, print4)),
      replaceEndOfLine(get_node_content_default(node, options9)),
      ...printClosingTag(node, options9),
      printClosingTagSuffix(node, options9)
    ];
  }
  const shouldHugContent = node.children.length === 1 && node.firstChild.type === "interpolation" && node.firstChild.isLeadingSpaceSensitive && !node.firstChild.hasLeadingSpaces && node.lastChild.isTrailingSpaceSensitive && !node.lastChild.hasTrailingSpaces;
  const attrGroupId = Symbol("element-attr-group-id");
  const printTag = (doc2) => group([
    group(printOpeningTag(path11, options9, print4), { id: attrGroupId }),
    doc2,
    printClosingTag(node, options9)
  ]);
  const printChildrenDoc = (childrenDoc) => {
    if (shouldHugContent) {
      return indentIfBreak(childrenDoc, { groupId: attrGroupId });
    }
    if ((isScriptLikeTag(node) || isVueCustomBlock(node, options9)) && node.parent.type === "root" && options9.parser === "vue" && !options9.vueIndentScriptAndStyle) {
      return childrenDoc;
    }
    return indent(childrenDoc);
  };
  const printLineBeforeChildren = () => {
    if (shouldHugContent) {
      return ifBreak(softline, "", { groupId: attrGroupId });
    }
    if (node.firstChild.hasLeadingSpaces && node.firstChild.isLeadingSpaceSensitive) {
      return line;
    }
    if (node.firstChild.type === "text" && node.isWhitespaceSensitive && node.isIndentationSensitive) {
      return dedentToRoot(softline);
    }
    return softline;
  };
  const printLineAfterChildren = () => {
    const needsToBorrow = node.next ? needsToBorrowPrevClosingTagEndMarker(node.next) : needsToBorrowLastChildClosingTagEndMarker(node.parent);
    if (needsToBorrow) {
      if (node.lastChild.hasTrailingSpaces && node.lastChild.isTrailingSpaceSensitive) {
        return " ";
      }
      return "";
    }
    if (shouldHugContent) {
      return ifBreak(softline, "", { groupId: attrGroupId });
    }
    if (node.lastChild.hasTrailingSpaces && node.lastChild.isTrailingSpaceSensitive) {
      return line;
    }
    if ((node.lastChild.type === "comment" || node.lastChild.type === "text" && node.isWhitespaceSensitive && node.isIndentationSensitive) && new RegExp(
      `\\n[\\t ]{${options9.tabWidth * (path11.ancestors.length - 1)}}$`
    ).test(node.lastChild.value)) {
      return "";
    }
    return softline;
  };
  if (node.children.length === 0) {
    return printTag(
      node.hasDanglingSpaces && node.isDanglingSpaceSensitive ? line : ""
    );
  }
  return printTag([
    forceBreakContent(node) ? breakParent : "",
    printChildrenDoc([
      printLineBeforeChildren(),
      printChildren3(path11, options9, print4)
    ]),
    printLineAfterChildren()
  ]);
}

// src/language-html/visitor-keys.js
var visitorKeys3 = {
  "front-matter": [],
  root: ["children"],
  element: ["attrs", "children"],
  ieConditionalComment: ["children"],
  ieConditionalStartComment: [],
  ieConditionalEndComment: [],
  interpolation: ["children"],
  text: ["children"],
  docType: [],
  comment: [],
  attribute: [],
  cdata: []
};
var visitor_keys_default3 = visitorKeys3;

// src/language-html/get-visitor-keys.js
var getVisitorKeys6 = create_get_visitor_keys_default(visitor_keys_default3);
var get_visitor_keys_default6 = getVisitorKeys6;

// src/language-html/printer-html.js
function genericPrint5(path11, options9, print4) {
  const {
    node
  } = path11;
  switch (node.type) {
    case "front-matter":
      return replaceEndOfLine(node.raw);
    case "root":
      if (options9.__onHtmlRoot) {
        options9.__onHtmlRoot(node);
      }
      return [group(printChildren3(path11, options9, print4)), hardline];
    case "element":
    case "ieConditionalComment":
      return printElement(path11, options9, print4);
    case "ieConditionalStartComment":
    case "ieConditionalEndComment":
      return [printOpeningTagStart(node), printClosingTagEnd(node)];
    case "interpolation":
      return [printOpeningTagStart(node, options9), ...path11.map(print4, "children"), printClosingTagEnd(node, options9)];
    case "text": {
      if (node.parent.type === "interpolation") {
        const trailingNewlineRegex = /\n[^\S\n]*$/;
        const hasTrailingNewline = trailingNewlineRegex.test(node.value);
        const value = hasTrailingNewline ? node.value.replace(trailingNewlineRegex, "") : node.value;
        return [replaceEndOfLine(value), hasTrailingNewline ? hardline : ""];
      }
      const printed = cleanDoc([printOpeningTagPrefix(node, options9), ...getTextValueParts2(node), printClosingTagSuffix(node, options9)]);
      if (Array.isArray(printed)) {
        return fill(printed);
      }
      return printed;
    }
    case "docType":
      return [group([printOpeningTagStart(node, options9), " ", string_replace_all_default(
        /* isOptionalObject*/
        false,
        node.value.replace(/^html\b/i, "html"),
        /\s+/g,
        " "
      )]), printClosingTagEnd(node, options9)];
    case "comment":
      return [printOpeningTagPrefix(node, options9), replaceEndOfLine(options9.originalText.slice(locStart6(node), locEnd6(node))), printClosingTagSuffix(node, options9)];
    case "attribute": {
      if (node.value === null) {
        return node.rawName;
      }
      const value = unescapeQuoteEntities(node.value);
      const singleQuoteCount = countChars(value, "'");
      const doubleQuoteCount = countChars(value, '"');
      const quote = singleQuoteCount < doubleQuoteCount ? "'" : '"';
      return [node.rawName, "=", quote, replaceEndOfLine(quote === '"' ? string_replace_all_default(
        /* isOptionalObject*/
        false,
        value,
        '"',
        "&quot;"
      ) : string_replace_all_default(
        /* isOptionalObject*/
        false,
        value,
        "'",
        "&apos;"
      )), quote];
    }
    case "cdata":
    default:
      throw new unexpected_node_error_default(node, "HTML");
  }
}
var printer7 = {
  preprocess: print_preprocess_default2,
  print: genericPrint5,
  insertPragma: insertPragma5,
  massageAstNode: clean_default5,
  embed: embed_default4,
  getVisitorKeys: get_visitor_keys_default6
};
var printer_html_default = printer7;

// src/language-html/languages.evaluate.js
var languages_evaluate_default6 = [
  {
    "linguistLanguageId": 146,
    "name": "Angular",
    "type": "markup",
    "tmScope": "text.html.basic",
    "aceMode": "html",
    "codemirrorMode": "htmlmixed",
    "codemirrorMimeType": "text/html",
    "color": "#e34c26",
    "aliases": [
      "xhtml"
    ],
    "extensions": [
      ".component.html"
    ],
    "parsers": [
      "angular"
    ],
    "vscodeLanguageIds": [
      "html"
    ],
    "filenames": []
  },
  {
    "linguistLanguageId": 146,
    "name": "HTML",
    "type": "markup",
    "tmScope": "text.html.basic",
    "aceMode": "html",
    "codemirrorMode": "htmlmixed",
    "codemirrorMimeType": "text/html",
    "color": "#e34c26",
    "aliases": [
      "xhtml"
    ],
    "extensions": [
      ".html",
      ".hta",
      ".htm",
      ".html.hl",
      ".inc",
      ".xht",
      ".xhtml",
      ".mjml"
    ],
    "parsers": [
      "html"
    ],
    "vscodeLanguageIds": [
      "html"
    ]
  },
  {
    "linguistLanguageId": 146,
    "name": "Lightning Web Components",
    "type": "markup",
    "tmScope": "text.html.basic",
    "aceMode": "html",
    "codemirrorMode": "htmlmixed",
    "codemirrorMimeType": "text/html",
    "color": "#e34c26",
    "aliases": [
      "xhtml"
    ],
    "extensions": [],
    "parsers": [
      "lwc"
    ],
    "vscodeLanguageIds": [
      "html"
    ],
    "filenames": []
  },
  {
    "linguistLanguageId": 391,
    "name": "Vue",
    "type": "markup",
    "color": "#41b883",
    "extensions": [
      ".vue"
    ],
    "tmScope": "text.html.vue",
    "aceMode": "html",
    "parsers": [
      "vue"
    ],
    "vscodeLanguageIds": [
      "vue"
    ]
  }
];

// src/language-html/options.js
var CATEGORY_HTML = "HTML";
var options7 = {
  bracketSameLine: common_options_default.bracketSameLine,
  htmlWhitespaceSensitivity: {
    category: CATEGORY_HTML,
    type: "choice",
    default: "css",
    description: "How to handle whitespaces in HTML.",
    choices: [
      {
        value: "css",
        description: "Respect the default value of CSS display property."
      },
      {
        value: "strict",
        description: "Whitespaces are considered sensitive."
      },
      {
        value: "ignore",
        description: "Whitespaces are considered insensitive."
      }
    ]
  },
  singleAttributePerLine: common_options_default.singleAttributePerLine,
  vueIndentScriptAndStyle: {
    category: CATEGORY_HTML,
    type: "boolean",
    default: false,
    description: "Indent script and style tags in Vue files."
  }
};
var options_default5 = options7;

// src/language-html/index.js
var printers6 = {
  html: printer_html_default
};
var parsers12 = create_parsers_default(parsers_default6);

// src/language-yaml/index.js
var language_yaml_exports = {};
__export(language_yaml_exports, {
  languages: () => languages_evaluate_default7,
  options: () => options_default6,
  parsers: () => parsers14,
  printers: () => printers7
});

// src/language-yaml/parsers.js
var parsers13 = [
  {
    importPlugin: () => import("./plugins/yaml.mjs"),
    parserNames: ["yaml"]
  }
];
var parsers_default7 = parsers13;

// src/language-yaml/pragma.js
function isPragma(text) {
  return /^\s*@(?:prettier|format)\s*$/.test(text);
}
function insertPragma6(text) {
  return `# @format

${text}`;
}

// src/language-yaml/loc.js
function locStart7(node) {
  return node.position.start.offset;
}

// src/language-yaml/embed.js
function embed5(path11, options9) {
  const { node } = path11;
  if (node.type === "root" && options9.filepath && /(?:[/\\]|^)\.(?:prettier|stylelint|lintstaged)rc$/.test(options9.filepath)) {
    return async (textToDoc2) => {
      const doc2 = await textToDoc2(options9.originalText, { parser: "json" });
      return doc2 ? [doc2, hardline] : void 0;
    };
  }
}
embed5.getVisitorKeys = () => [];
var embed_default5 = embed5;

// src/language-yaml/utils.js
function isNode(value, types) {
  return typeof (value == null ? void 0 : value.type) === "string" && (!types || types.includes(value.type));
}
function mapNode(node, callback, parent) {
  return callback("children" in node ? {
    ...node,
    children: node.children.map((childNode) => mapNode(childNode, callback, node))
  } : node, parent);
}
function defineShortcut(x, key, getter) {
  Object.defineProperty(x, key, {
    get: getter,
    enumerable: false
  });
}
function isNextLineEmpty3(node, text) {
  let newlineCount = 0;
  const textLength = text.length;
  for (let i = node.position.end.offset - 1; i < textLength; i++) {
    const char = text[i];
    if (char === "\n") {
      newlineCount++;
    }
    if (newlineCount === 1 && /\S/.test(char)) {
      return false;
    }
    if (newlineCount === 2) {
      return true;
    }
  }
  return false;
}
function isLastDescendantNode(path11) {
  const {
    node
  } = path11;
  switch (node.type) {
    case "tag":
    case "anchor":
    case "comment":
      return false;
  }
  const pathStackLength = path11.stack.length;
  for (let i = 1; i < pathStackLength; i++) {
    const item = path11.stack[i];
    const parentItem = path11.stack[i - 1];
    if (Array.isArray(parentItem) && typeof item === "number" && item !== parentItem.length - 1) {
      return false;
    }
  }
  return true;
}
function getLastDescendantNode(node) {
  return is_non_empty_array_default(node.children) ? getLastDescendantNode(at_default(
    /* isOptionalObject*/
    false,
    node.children,
    -1
  )) : node;
}
function isPrettierIgnore3(comment) {
  return comment.value.trim() === "prettier-ignore";
}
function hasPrettierIgnore6(path11) {
  const {
    node
  } = path11;
  if (node.type === "documentBody") {
    const documentHead = path11.parent.head;
    return hasEndComments(documentHead) && isPrettierIgnore3(at_default(
      /* isOptionalObject*/
      false,
      documentHead.endComments,
      -1
    ));
  }
  return hasLeadingComments(node) && isPrettierIgnore3(at_default(
    /* isOptionalObject*/
    false,
    node.leadingComments,
    -1
  ));
}
function isEmptyNode(node) {
  return !is_non_empty_array_default(node.children) && !hasComments(node);
}
function hasComments(node) {
  return hasLeadingComments(node) || hasMiddleComments(node) || hasIndicatorComment(node) || hasTrailingComment(node) || hasEndComments(node);
}
function hasLeadingComments(node) {
  return is_non_empty_array_default(node == null ? void 0 : node.leadingComments);
}
function hasMiddleComments(node) {
  return is_non_empty_array_default(node == null ? void 0 : node.middleComments);
}
function hasIndicatorComment(node) {
  return node == null ? void 0 : node.indicatorComment;
}
function hasTrailingComment(node) {
  return node == null ? void 0 : node.trailingComment;
}
function hasEndComments(node) {
  return is_non_empty_array_default(node == null ? void 0 : node.endComments);
}
function splitWithSingleSpace(text) {
  const parts = [];
  let lastPart;
  for (const part of text.split(/( +)/)) {
    if (part !== " ") {
      if (lastPart === " ") {
        parts.push(part);
      } else {
        parts.push((parts.pop() || "") + part);
      }
    } else if (lastPart === void 0) {
      parts.unshift("");
    }
    lastPart = part;
  }
  if (lastPart === " ") {
    parts.push((parts.pop() || "") + " ");
  }
  if (parts[0] === "") {
    parts.shift();
    parts.unshift(" " + (parts.shift() || ""));
  }
  return parts;
}
function getFlowScalarLineContents(nodeType, content, options9) {
  const rawLineContents = content.split("\n").map((lineContent, index, lineContents) => index === 0 && index === lineContents.length - 1 ? lineContent : index !== 0 && index !== lineContents.length - 1 ? lineContent.trim() : index === 0 ? lineContent.trimEnd() : lineContent.trimStart());
  if (options9.proseWrap === "preserve") {
    return rawLineContents.map((lineContent) => lineContent.length === 0 ? [] : [lineContent]);
  }
  return rawLineContents.map((lineContent) => lineContent.length === 0 ? [] : splitWithSingleSpace(lineContent)).reduce((reduced, lineContentWords, index) => index !== 0 && rawLineContents[index - 1].length > 0 && lineContentWords.length > 0 && !// trailing backslash in quoteDouble should be preserved
  (nodeType === "quoteDouble" && at_default(
    /* isOptionalObject*/
    false,
    at_default(
      /* isOptionalObject*/
      false,
      reduced,
      -1
    ),
    -1
  ).endsWith("\\")) ? [...reduced.slice(0, -1), [...at_default(
    /* isOptionalObject*/
    false,
    reduced,
    -1
  ), ...lineContentWords]] : [...reduced, lineContentWords], []).map((lineContentWords) => options9.proseWrap === "never" ? [lineContentWords.join(" ")] : lineContentWords);
}
function getBlockValueLineContents(node, {
  parentIndent,
  isLastDescendant,
  options: options9
}) {
  const content = node.position.start.line === node.position.end.line ? "" : options9.originalText.slice(node.position.start.offset, node.position.end.offset).match(/^[^\n]*\n(.*)$/s)[1];
  let leadingSpaceCount;
  if (node.indent === null) {
    const matches = content.match(/^(?<leadingSpace> *)[^\n\r ]/m);
    leadingSpaceCount = matches ? matches.groups.leadingSpace.length : Number.POSITIVE_INFINITY;
  } else {
    leadingSpaceCount = node.indent - 1 + parentIndent;
  }
  const rawLineContents = content.split("\n").map((lineContent) => lineContent.slice(leadingSpaceCount));
  if (options9.proseWrap === "preserve" || node.type === "blockLiteral") {
    return removeUnnecessaryTrailingNewlines(rawLineContents.map((lineContent) => lineContent.length === 0 ? [] : [lineContent]));
  }
  return removeUnnecessaryTrailingNewlines(rawLineContents.map((lineContent) => lineContent.length === 0 ? [] : splitWithSingleSpace(lineContent)).reduce((reduced, lineContentWords, index) => index !== 0 && rawLineContents[index - 1].length > 0 && lineContentWords.length > 0 && !/^\s/.test(lineContentWords[0]) && !/^\s|\s$/.test(at_default(
    /* isOptionalObject*/
    false,
    reduced,
    -1
  )) ? [...reduced.slice(0, -1), [...at_default(
    /* isOptionalObject*/
    false,
    reduced,
    -1
  ), ...lineContentWords]] : [...reduced, lineContentWords], []).map((lineContentWords) => lineContentWords.reduce((reduced, word) => (
    // disallow trailing spaces
    reduced.length > 0 && /\s$/.test(at_default(
      /* isOptionalObject*/
      false,
      reduced,
      -1
    )) ? [...reduced.slice(0, -1), at_default(
      /* isOptionalObject*/
      false,
      reduced,
      -1
    ) + " " + word] : [...reduced, word]
  ), [])).map((lineContentWords) => options9.proseWrap === "never" ? [lineContentWords.join(" ")] : lineContentWords));
  function removeUnnecessaryTrailingNewlines(lineContents) {
    if (node.chomping === "keep") {
      return at_default(
        /* isOptionalObject*/
        false,
        lineContents,
        -1
      ).length === 0 ? lineContents.slice(0, -1) : lineContents;
    }
    let trailingNewlineCount = 0;
    for (let i = lineContents.length - 1; i >= 0; i--) {
      if (lineContents[i].length === 0) {
        trailingNewlineCount++;
      } else {
        break;
      }
    }
    return trailingNewlineCount === 0 ? lineContents : trailingNewlineCount >= 2 && !isLastDescendant ? (
      // next empty line
      lineContents.slice(0, -(trailingNewlineCount - 1))
    ) : lineContents.slice(0, -trailingNewlineCount);
  }
}
function isInlineNode(node) {
  if (!node) {
    return true;
  }
  switch (node.type) {
    case "plain":
    case "quoteDouble":
    case "quoteSingle":
    case "alias":
    case "flowMapping":
    case "flowSequence":
      return true;
    default:
      return false;
  }
}

// src/language-yaml/visitor-keys.js
var visitorKeys4 = Object.fromEntries(
  Object.entries({
    root: ["children"],
    document: ["head", "body", "children"],
    documentHead: ["children"],
    documentBody: ["children"],
    directive: [],
    alias: [],
    blockLiteral: [],
    blockFolded: ["children"],
    plain: ["children"],
    quoteSingle: [],
    quoteDouble: [],
    mapping: ["children"],
    mappingItem: ["key", "value", "children"],
    mappingKey: ["content", "children"],
    mappingValue: ["content", "children"],
    sequence: ["children"],
    sequenceItem: ["content", "children"],
    flowMapping: ["children"],
    flowMappingItem: ["key", "value", "children"],
    flowSequence: ["children"],
    flowSequenceItem: ["content", "children"],
    comment: [],
    tag: [],
    anchor: []
  }).map(([type, keys]) => [
    type,
    [
      ...keys,
      "anchor",
      "tag",
      "indicatorComment",
      "leadingComments",
      "middleComments",
      "trailingComment",
      "endComments"
    ]
  ])
);
var visitor_keys_default4 = visitorKeys4;

// src/language-yaml/get-visitor-keys.js
var getVisitorKeys7 = create_get_visitor_keys_default(visitor_keys_default4);
var get_visitor_keys_default7 = getVisitorKeys7;

// src/language-yaml/print-preprocess.js
function preprocess3(ast) {
  return mapNode(ast, defineShortcuts);
}
function defineShortcuts(node) {
  switch (node.type) {
    case "document":
      defineShortcut(node, "head", () => node.children[0]);
      defineShortcut(node, "body", () => node.children[1]);
      break;
    case "documentBody":
    case "sequenceItem":
    case "flowSequenceItem":
    case "mappingKey":
    case "mappingValue":
      defineShortcut(node, "content", () => node.children[0]);
      break;
    case "mappingItem":
    case "flowMappingItem":
      defineShortcut(node, "key", () => node.children[0]);
      defineShortcut(node, "value", () => node.children[1]);
      break;
  }
  return node;
}
var print_preprocess_default3 = preprocess3;

// src/language-yaml/print/misc.js
var printedEmptyLineCache = /* @__PURE__ */ new WeakMap();
function printNextEmptyLine(path11, originalText) {
  const { node, root } = path11;
  let isNextEmptyLinePrintedSet;
  if (printedEmptyLineCache.has(root)) {
    isNextEmptyLinePrintedSet = printedEmptyLineCache.get(root);
  } else {
    isNextEmptyLinePrintedSet = /* @__PURE__ */ new Set();
    printedEmptyLineCache.set(root, isNextEmptyLinePrintedSet);
  }
  if (!isNextEmptyLinePrintedSet.has(node.position.end.line)) {
    isNextEmptyLinePrintedSet.add(node.position.end.line);
    if (isNextLineEmpty3(node, originalText) && !shouldPrintEndComments(path11.parent)) {
      return softline;
    }
  }
  return "";
}
function shouldPrintEndComments(node) {
  return hasEndComments(node) && !isNode(node, [
    "documentHead",
    "documentBody",
    "flowMapping",
    "flowSequence"
  ]);
}
function alignWithSpaces(width, doc2) {
  return align(" ".repeat(width), doc2);
}

// src/language-yaml/print/flow-mapping-sequence.js
function printFlowMapping(path11, print4, options9) {
  const {
    node
  } = path11;
  const isMapping = node.type === "flowMapping";
  const openMarker = isMapping ? "{" : "[";
  const closeMarker = isMapping ? "}" : "]";
  let bracketSpacing = softline;
  if (isMapping && node.children.length > 0 && options9.bracketSpacing) {
    bracketSpacing = line;
  }
  const lastItem = at_default(
    /* isOptionalObject*/
    false,
    node.children,
    -1
  );
  const isLastItemEmptyMappingItem = (lastItem == null ? void 0 : lastItem.type) === "flowMappingItem" && isEmptyNode(lastItem.key) && isEmptyNode(lastItem.value);
  return [openMarker, alignWithSpaces(options9.tabWidth, [bracketSpacing, printChildren4(path11, print4, options9), options9.trailingComma === "none" ? "" : ifBreak(","), hasEndComments(node) ? [hardline, join(hardline, path11.map(print4, "endComments"))] : ""]), isLastItemEmptyMappingItem ? "" : bracketSpacing, closeMarker];
}
function printChildren4(path11, print4, options9) {
  return path11.map(({
    isLast,
    node,
    next
  }) => [print4(), isLast ? "" : [",", line, node.position.start.line !== next.position.start.line ? printNextEmptyLine(path11, options9.originalText) : ""]], "children");
}

// src/language-yaml/print/mapping-item.js
function printMappingItem(path11, print4, options9) {
  var _a;
  const { node, parent } = path11;
  const { key, value } = node;
  const isEmptyMappingKey = isEmptyNode(key);
  const isEmptyMappingValue = isEmptyNode(value);
  if (isEmptyMappingKey && isEmptyMappingValue) {
    return ": ";
  }
  const printedKey = print4("key");
  const spaceBeforeColon = needsSpaceInFrontOfMappingValue(node) ? " " : "";
  if (isEmptyMappingValue) {
    if (node.type === "flowMappingItem" && parent.type === "flowMapping") {
      return printedKey;
    }
    if (node.type === "mappingItem" && isAbsolutelyPrintedAsSingleLineNode(key.content, options9) && !hasTrailingComment(key.content) && ((_a = parent.tag) == null ? void 0 : _a.value) !== "tag:yaml.org,2002:set") {
      return [printedKey, spaceBeforeColon, ":"];
    }
    return ["? ", alignWithSpaces(2, printedKey)];
  }
  const printedValue = print4("value");
  if (isEmptyMappingKey) {
    return [": ", alignWithSpaces(2, printedValue)];
  }
  if (hasLeadingComments(value) || !isInlineNode(key.content)) {
    return [
      "? ",
      alignWithSpaces(2, printedKey),
      hardline,
      ...path11.map(() => [print4(), hardline], "value", "leadingComments"),
      ": ",
      alignWithSpaces(2, printedValue)
    ];
  }
  if (isSingleLineNode(key.content) && !hasLeadingComments(key.content) && !hasMiddleComments(key.content) && !hasTrailingComment(key.content) && !hasEndComments(key) && !hasLeadingComments(value.content) && !hasMiddleComments(value.content) && !hasEndComments(value) && isAbsolutelyPrintedAsSingleLineNode(value.content, options9)) {
    return [printedKey, spaceBeforeColon, ": ", printedValue];
  }
  const groupId = Symbol("mappingKey");
  const groupedKey = group([
    ifBreak("? "),
    group(alignWithSpaces(2, printedKey), { id: groupId })
  ]);
  const explicitMappingValue = [
    hardline,
    ": ",
    alignWithSpaces(2, printedValue)
  ];
  const implicitMappingValueParts = [spaceBeforeColon, ":"];
  if (hasLeadingComments(value.content) || hasEndComments(value) && value.content && !isNode(value.content, ["mapping", "sequence"]) || parent.type === "mapping" && hasTrailingComment(key.content) && isInlineNode(value.content) || isNode(value.content, ["mapping", "sequence"]) && value.content.tag === null && value.content.anchor === null) {
    implicitMappingValueParts.push(hardline);
  } else if (value.content) {
    implicitMappingValueParts.push(line);
  }
  implicitMappingValueParts.push(printedValue);
  const implicitMappingValue = alignWithSpaces(
    options9.tabWidth,
    implicitMappingValueParts
  );
  if (isAbsolutelyPrintedAsSingleLineNode(key.content, options9) && !hasLeadingComments(key.content) && !hasMiddleComments(key.content) && !hasEndComments(key)) {
    return conditionalGroup([[printedKey, implicitMappingValue]]);
  }
  return conditionalGroup([
    [
      groupedKey,
      ifBreak(explicitMappingValue, implicitMappingValue, { groupId })
    ]
  ]);
}
function isAbsolutelyPrintedAsSingleLineNode(node, options9) {
  if (!node) {
    return true;
  }
  switch (node.type) {
    case "plain":
    case "quoteSingle":
    case "quoteDouble":
      break;
    case "alias":
      return true;
    default:
      return false;
  }
  if (options9.proseWrap === "preserve") {
    return node.position.start.line === node.position.end.line;
  }
  if (
    // backslash-newline
    /\\$/m.test(
      options9.originalText.slice(
        node.position.start.offset,
        node.position.end.offset
      )
    )
  ) {
    return false;
  }
  switch (options9.proseWrap) {
    case "never":
      return !node.value.includes("\n");
    case "always":
      return !/[\n ]/.test(node.value);
    default:
      return false;
  }
}
function needsSpaceInFrontOfMappingValue(node) {
  var _a;
  return ((_a = node.key.content) == null ? void 0 : _a.type) === "alias";
}
function isSingleLineNode(node) {
  if (!node) {
    return true;
  }
  switch (node.type) {
    case "plain":
    case "quoteDouble":
    case "quoteSingle":
      return node.position.start.line === node.position.end.line;
    case "alias":
      return true;
    default:
      return false;
  }
}
var mapping_item_default = printMappingItem;

// src/language-yaml/print/block.js
function printBlock2(path11, print4, options9) {
  const { node } = path11;
  const parentIndent = path11.ancestors.filter(
    (node2) => node2.type === "sequence" || node2.type === "mapping"
  ).length;
  const isLastDescendant = isLastDescendantNode(path11);
  const parts = [node.type === "blockFolded" ? ">" : "|"];
  if (node.indent !== null) {
    parts.push(node.indent.toString());
  }
  if (node.chomping !== "clip") {
    parts.push(node.chomping === "keep" ? "+" : "-");
  }
  if (hasIndicatorComment(node)) {
    parts.push(" ", print4("indicatorComment"));
  }
  const lineContents = getBlockValueLineContents(node, {
    parentIndent,
    isLastDescendant,
    options: options9
  });
  const contentsParts = [];
  for (const [index, lineWords] of lineContents.entries()) {
    if (index === 0) {
      contentsParts.push(hardline);
    }
    contentsParts.push(fill(join(line, lineWords)));
    if (index !== lineContents.length - 1) {
      contentsParts.push(
        lineWords.length === 0 ? hardline : markAsRoot(literalline)
      );
    } else if (node.chomping === "keep" && isLastDescendant) {
      contentsParts.push(
        dedentToRoot(lineWords.length === 0 ? hardline : literalline)
      );
    }
  }
  if (node.indent === null) {
    parts.push(dedent(alignWithSpaces(options9.tabWidth, contentsParts)));
  } else {
    parts.push(
      dedentToRoot(
        alignWithSpaces(node.indent - 1 + parentIndent, contentsParts)
      )
    );
  }
  return parts;
}
var block_default = printBlock2;

// src/language-yaml/printer-yaml.js
function genericPrint6(path11, options9, print4) {
  const {
    node
  } = path11;
  const parts = [];
  if (node.type !== "mappingValue" && hasLeadingComments(node)) {
    parts.push([join(hardline, path11.map(print4, "leadingComments")), hardline]);
  }
  const {
    tag,
    anchor
  } = node;
  if (tag) {
    parts.push(print4("tag"));
  }
  if (tag && anchor) {
    parts.push(" ");
  }
  if (anchor) {
    parts.push(print4("anchor"));
  }
  let nextEmptyLine = "";
  if (isNode(node, ["mapping", "sequence", "comment", "directive", "mappingItem", "sequenceItem"]) && !isLastDescendantNode(path11)) {
    nextEmptyLine = printNextEmptyLine(path11, options9.originalText);
  }
  if (tag || anchor) {
    if (isNode(node, ["sequence", "mapping"]) && !hasMiddleComments(node)) {
      parts.push(hardline);
    } else {
      parts.push(" ");
    }
  }
  if (hasMiddleComments(node)) {
    parts.push([node.middleComments.length === 1 ? "" : hardline, join(hardline, path11.map(print4, "middleComments")), hardline]);
  }
  if (hasPrettierIgnore6(path11)) {
    parts.push(replaceEndOfLine(options9.originalText.slice(node.position.start.offset, node.position.end.offset).trimEnd()));
  } else {
    parts.push(group(printNode(path11, options9, print4)));
  }
  if (hasTrailingComment(node) && !isNode(node, ["document", "documentHead"])) {
    parts.push(lineSuffix([node.type === "mappingValue" && !node.content ? "" : " ", path11.parent.type === "mappingKey" && path11.getParentNode(2).type === "mapping" && isInlineNode(node) ? "" : breakParent, print4("trailingComment")]));
  }
  if (shouldPrintEndComments(node)) {
    parts.push(alignWithSpaces(node.type === "sequenceItem" ? 2 : 0, [hardline, join(hardline, path11.map(({
      node: node2
    }) => [is_previous_line_empty_default(options9.originalText, locStart7(node2)) ? hardline : "", print4()], "endComments"))]));
  }
  parts.push(nextEmptyLine);
  return parts;
}
function printNode(path11, options9, print4) {
  const {
    node
  } = path11;
  switch (node.type) {
    case "root": {
      const parts = [];
      path11.each(({
        node: document,
        next: nextDocument,
        isFirst
      }) => {
        if (!isFirst) {
          parts.push(hardline);
        }
        parts.push(print4());
        if (shouldPrintDocumentEndMarker(document, nextDocument)) {
          parts.push(hardline, "...");
          if (hasTrailingComment(document)) {
            parts.push(" ", print4("trailingComment"));
          }
        } else if (nextDocument && !hasTrailingComment(nextDocument.head)) {
          parts.push(hardline, "---");
        }
      }, "children");
      const lastDescendantNode = getLastDescendantNode(node);
      if (!isNode(lastDescendantNode, ["blockLiteral", "blockFolded"]) || lastDescendantNode.chomping !== "keep") {
        parts.push(hardline);
      }
      return parts;
    }
    case "document": {
      const parts = [];
      if (shouldPrintDocumentHeadEndMarker(path11, options9) === "head") {
        if (node.head.children.length > 0 || node.head.endComments.length > 0) {
          parts.push(print4("head"));
        }
        if (hasTrailingComment(node.head)) {
          parts.push(["---", " ", print4(["head", "trailingComment"])]);
        } else {
          parts.push("---");
        }
      }
      if (shouldPrintDocumentBody(node)) {
        parts.push(print4("body"));
      }
      return join(hardline, parts);
    }
    case "documentHead":
      return join(hardline, [...path11.map(print4, "children"), ...path11.map(print4, "endComments")]);
    case "documentBody": {
      const {
        children,
        endComments
      } = node;
      let separator = "";
      if (children.length > 0 && endComments.length > 0) {
        const lastDescendantNode = getLastDescendantNode(node);
        if (isNode(lastDescendantNode, ["blockFolded", "blockLiteral"])) {
          if (lastDescendantNode.chomping !== "keep") {
            separator = [hardline, hardline];
          }
        } else {
          separator = hardline;
        }
      }
      return [join(hardline, path11.map(print4, "children")), separator, join(hardline, path11.map(print4, "endComments"))];
    }
    case "directive":
      return ["%", join(" ", [node.name, ...node.parameters])];
    case "comment":
      return ["#", node.value];
    case "alias":
      return ["*", node.value];
    case "tag":
      return options9.originalText.slice(node.position.start.offset, node.position.end.offset);
    case "anchor":
      return ["&", node.value];
    case "plain":
      return printFlowScalarContent(node.type, options9.originalText.slice(node.position.start.offset, node.position.end.offset), options9);
    case "quoteDouble":
    case "quoteSingle": {
      const singleQuote = "'";
      const doubleQuote = '"';
      const raw = options9.originalText.slice(node.position.start.offset + 1, node.position.end.offset - 1);
      if (node.type === "quoteSingle" && raw.includes("\\") || node.type === "quoteDouble" && /\\[^"]/.test(raw)) {
        const originalQuote = node.type === "quoteDouble" ? doubleQuote : singleQuote;
        return [originalQuote, printFlowScalarContent(node.type, raw, options9), originalQuote];
      }
      if (raw.includes(doubleQuote)) {
        return [singleQuote, printFlowScalarContent(node.type, node.type === "quoteDouble" ? string_replace_all_default(
          /* isOptionalObject*/
          false,
          string_replace_all_default(
            /* isOptionalObject*/
            false,
            raw,
            '\\"',
            doubleQuote
          ),
          "'",
          singleQuote.repeat(2)
        ) : raw, options9), singleQuote];
      }
      if (raw.includes(singleQuote)) {
        return [doubleQuote, printFlowScalarContent(node.type, node.type === "quoteSingle" ? (
          // single quote needs to be escaped by 2 single quotes in quoteSingle
          string_replace_all_default(
            /* isOptionalObject*/
            false,
            raw,
            "''",
            singleQuote
          )
        ) : raw, options9), doubleQuote];
      }
      const quote = options9.singleQuote ? singleQuote : doubleQuote;
      return [quote, printFlowScalarContent(node.type, raw, options9), quote];
    }
    case "blockFolded":
    case "blockLiteral":
      return block_default(path11, print4, options9);
    case "mapping":
    case "sequence":
      return join(hardline, path11.map(print4, "children"));
    case "sequenceItem":
      return ["- ", alignWithSpaces(2, node.content ? print4("content") : "")];
    case "mappingKey":
    case "mappingValue":
      return !node.content ? "" : print4("content");
    case "mappingItem":
    case "flowMappingItem":
      return mapping_item_default(path11, print4, options9);
    case "flowMapping":
      return printFlowMapping(path11, print4, options9);
    case "flowSequence":
      return printFlowMapping(path11, print4, options9);
    case "flowSequenceItem":
      return print4("content");
    default:
      throw new unexpected_node_error_default(node, "YAML");
  }
}
function shouldPrintDocumentBody(document) {
  return document.body.children.length > 0 || hasEndComments(document.body);
}
function shouldPrintDocumentEndMarker(document, nextDocument) {
  return (
    /**
     *... # trailingComment
     */
    hasTrailingComment(document) || nextDocument && /**
     * ...
     * %DIRECTIVE
     * ---
     */
    (nextDocument.head.children.length > 0 || /**
     * ...
     * # endComment
     * ---
     */
    hasEndComments(nextDocument.head))
  );
}
function shouldPrintDocumentHeadEndMarker(path11, options9) {
  const document = path11.node;
  if (
    /**
     * ---
     * preserve the first document head end marker
     */
    path11.isFirst && /---(?:\s|$)/.test(options9.originalText.slice(locStart7(document), locStart7(document) + 4)) || /**
     * %DIRECTIVE
     * ---
     */
    document.head.children.length > 0 || /**
     * # end comment
     * ---
     */
    hasEndComments(document.head) || /**
     * --- # trailing comment
     */
    hasTrailingComment(document.head)
  ) {
    return "head";
  }
  const nextDocument = path11.next;
  if (shouldPrintDocumentEndMarker(document, nextDocument)) {
    return false;
  }
  return nextDocument ? "root" : false;
}
function printFlowScalarContent(nodeType, content, options9) {
  const lineContents = getFlowScalarLineContents(nodeType, content, options9);
  return join(hardline, lineContents.map((lineContentWords) => fill(join(line, lineContentWords))));
}
function clean7(node, newNode) {
  if (isNode(newNode)) {
    delete newNode.position;
    switch (newNode.type) {
      case "comment":
        if (isPragma(newNode.value)) {
          return null;
        }
        break;
      case "quoteDouble":
      case "quoteSingle":
        newNode.type = "quote";
        break;
    }
  }
}
var printer8 = {
  preprocess: print_preprocess_default3,
  embed: embed_default5,
  print: genericPrint6,
  massageAstNode: clean7,
  insertPragma: insertPragma6,
  getVisitorKeys: get_visitor_keys_default7
};
var printer_yaml_default = printer8;

// src/language-yaml/languages.evaluate.js
var languages_evaluate_default7 = [
  {
    "linguistLanguageId": 407,
    "name": "YAML",
    "type": "data",
    "color": "#cb171e",
    "tmScope": "source.yaml",
    "aliases": [
      "yml"
    ],
    "extensions": [
      ".yml",
      ".mir",
      ".reek",
      ".rviz",
      ".sublime-syntax",
      ".syntax",
      ".yaml",
      ".yaml-tmlanguage",
      ".yaml.sed",
      ".yml.mysql"
    ],
    "filenames": [
      ".clang-format",
      ".clang-tidy",
      ".gemrc",
      "CITATION.cff",
      "glide.lock",
      ".prettierrc",
      ".stylelintrc",
      ".lintstagedrc"
    ],
    "aceMode": "yaml",
    "codemirrorMode": "yaml",
    "codemirrorMimeType": "text/x-yaml",
    "parsers": [
      "yaml"
    ],
    "vscodeLanguageIds": [
      "yaml",
      "ansible",
      "home-assistant"
    ]
  }
];

// src/language-yaml/options.js
var options8 = {
  bracketSpacing: common_options_default.bracketSpacing,
  singleQuote: common_options_default.singleQuote,
  proseWrap: common_options_default.proseWrap
};
var options_default6 = options8;

// src/language-yaml/index.js
var printers7 = {
  yaml: printer_yaml_default
};
var parsers14 = create_parsers_default(parsers_default7);

// src/language-json/index.js
var language_json_exports = {};
__export(language_json_exports, {
  languages: () => languages_evaluate_default8,
  printers: () => printers8
});

// src/language-json/visitor-keys.js
var visitorKeys5 = {
  JsonRoot: ["node"],
  ArrayExpression: ["elements"],
  ObjectExpression: ["properties"],
  ObjectProperty: ["key", "value"],
  UnaryExpression: ["argument"],
  NullLiteral: [],
  BooleanLiteral: [],
  StringLiteral: [],
  NumericLiteral: [],
  Identifier: [],
  TemplateLiteral: ["quasis"],
  TemplateElement: []
};
var visitor_keys_default5 = visitorKeys5;

// src/language-json/get-visitor-keys.js
var getVisitorKeys8 = create_get_visitor_keys_default(visitor_keys_default5);
var get_visitor_keys_default8 = getVisitorKeys8;

// src/language-json/printer-estree-json.js
function genericPrint7(path11, options9, print4) {
  const { node } = path11;
  switch (node.type) {
    case "JsonRoot":
      return [print4("node"), hardline];
    case "ArrayExpression": {
      if (node.elements.length === 0) {
        return "[]";
      }
      const printed = path11.map(
        () => path11.node === null ? "null" : print4(),
        "elements"
      );
      return [
        "[",
        indent([hardline, join([",", hardline], printed)]),
        hardline,
        "]"
      ];
    }
    case "ObjectExpression":
      return node.properties.length === 0 ? "{}" : [
        "{",
        indent([
          hardline,
          join([",", hardline], path11.map(print4, "properties"))
        ]),
        hardline,
        "}"
      ];
    case "ObjectProperty":
      return [print4("key"), ": ", print4("value")];
    case "UnaryExpression":
      return [node.operator === "+" ? "" : node.operator, print4("argument")];
    case "NullLiteral":
      return "null";
    case "BooleanLiteral":
      return node.value ? "true" : "false";
    case "StringLiteral":
      return JSON.stringify(node.value);
    case "NumericLiteral":
      return isObjectKey(path11) ? JSON.stringify(String(node.value)) : JSON.stringify(node.value);
    case "Identifier":
      return isObjectKey(path11) ? JSON.stringify(node.name) : node.name;
    case "TemplateLiteral":
      return print4(["quasis", 0]);
    case "TemplateElement":
      return JSON.stringify(node.value.cooked);
    default:
      throw new unexpected_node_error_default(node, "JSON");
  }
}
function isObjectKey(path11) {
  return path11.key === "key" && path11.parent.type === "ObjectProperty";
}
var ignoredProperties5 = /* @__PURE__ */ new Set([
  "start",
  "end",
  "extra",
  "loc",
  "comments",
  "leadingComments",
  "trailingComments",
  "innerComments",
  "errors",
  "range",
  "tokens"
]);
function clean8(node, newNode) {
  const { type } = node;
  if (type === "ObjectProperty") {
    const { key } = node;
    if (key.type === "Identifier") {
      newNode.key = { type: "StringLiteral", value: key.name };
    } else if (key.type === "NumericLiteral") {
      newNode.key = { type: "StringLiteral", value: String(key.value) };
    }
    return;
  }
  if (type === "UnaryExpression" && node.operator === "+") {
    return newNode.argument;
  }
  if (type === "ArrayExpression") {
    for (const [index, element] of node.elements.entries()) {
      if (element === null) {
        newNode.elements.splice(index, 0, { type: "NullLiteral" });
      }
    }
    return;
  }
  if (type === "TemplateLiteral") {
    return { type: "StringLiteral", value: node.quasis[0].value.cooked };
  }
}
clean8.ignoredProperties = ignoredProperties5;
var printer9 = {
  print: genericPrint7,
  massageAstNode: clean8,
  getVisitorKeys: get_visitor_keys_default8
};
var printer_estree_json_default = printer9;

// src/language-json/languages.evaluate.js
var languages_evaluate_default8 = [
  {
    "linguistLanguageId": 174,
    "name": "JSON.stringify",
    "type": "data",
    "color": "#292929",
    "tmScope": "source.json",
    "aceMode": "json",
    "codemirrorMode": "javascript",
    "codemirrorMimeType": "application/json",
    "aliases": [
      "geojson",
      "jsonl",
      "topojson"
    ],
    "extensions": [
      ".importmap"
    ],
    "filenames": [
      "package.json",
      "package-lock.json",
      "composer.json"
    ],
    "parsers": [
      "json-stringify"
    ],
    "vscodeLanguageIds": [
      "json"
    ]
  },
  {
    "linguistLanguageId": 174,
    "name": "JSON",
    "type": "data",
    "color": "#292929",
    "tmScope": "source.json",
    "aceMode": "json",
    "codemirrorMode": "javascript",
    "codemirrorMimeType": "application/json",
    "aliases": [
      "geojson",
      "jsonl",
      "topojson"
    ],
    "extensions": [
      ".json",
      ".4DForm",
      ".4DProject",
      ".avsc",
      ".geojson",
      ".gltf",
      ".har",
      ".ice",
      ".JSON-tmLanguage",
      ".mcmeta",
      ".tfstate",
      ".tfstate.backup",
      ".topojson",
      ".webapp",
      ".webmanifest",
      ".yy",
      ".yyp"
    ],
    "filenames": [
      ".arcconfig",
      ".auto-changelog",
      ".c8rc",
      ".htmlhintrc",
      ".imgbotconfig",
      ".nycrc",
      ".tern-config",
      ".tern-project",
      ".watchmanconfig",
      "Pipfile.lock",
      "composer.lock",
      "mcmod.info"
    ],
    "parsers": [
      "json"
    ],
    "vscodeLanguageIds": [
      "json"
    ]
  },
  {
    "linguistLanguageId": 423,
    "name": "JSON with Comments",
    "type": "data",
    "color": "#292929",
    "group": "JSON",
    "tmScope": "source.js",
    "aceMode": "javascript",
    "codemirrorMode": "javascript",
    "codemirrorMimeType": "text/javascript",
    "aliases": [
      "jsonc"
    ],
    "extensions": [
      ".jsonc",
      ".code-snippets",
      ".sublime-build",
      ".sublime-commands",
      ".sublime-completions",
      ".sublime-keymap",
      ".sublime-macro",
      ".sublime-menu",
      ".sublime-mousemap",
      ".sublime-project",
      ".sublime-settings",
      ".sublime-theme",
      ".sublime-workspace",
      ".sublime_metrics",
      ".sublime_session"
    ],
    "filenames": [
      ".babelrc",
      ".devcontainer.json",
      ".eslintrc.json",
      ".jscsrc",
      ".jshintrc",
      ".jslintrc",
      "api-extractor.json",
      "devcontainer.json",
      "jsconfig.json",
      "language-configuration.json",
      "tsconfig.json",
      "tslint.json",
      ".eslintrc",
      ".swcrc"
    ],
    "parsers": [
      "json"
    ],
    "vscodeLanguageIds": [
      "jsonc"
    ]
  },
  {
    "linguistLanguageId": 175,
    "name": "JSON5",
    "type": "data",
    "color": "#267CB9",
    "extensions": [
      ".json5"
    ],
    "tmScope": "source.js",
    "aceMode": "javascript",
    "codemirrorMode": "javascript",
    "codemirrorMimeType": "application/json",
    "parsers": [
      "json5"
    ],
    "vscodeLanguageIds": [
      "json5"
    ]
  }
];

// src/language-json/index.js
var printers8 = {
  "estree-json": printer_estree_json_default
};

// src/utils/public.js
var public_exports = {};
__export(public_exports, {
  addDanglingComment: () => addDanglingComment,
  addLeadingComment: () => addLeadingComment,
  addTrailingComment: () => addTrailingComment,
  getAlignmentSize: () => get_alignment_size_default,
  getIndentSize: () => get_indent_size_default,
  getMaxContinuousCount: () => get_max_continuous_count_default,
  getNextNonSpaceNonCommentCharacter: () => get_next_non_space_non_comment_character_default,
  getNextNonSpaceNonCommentCharacterIndex: () => getNextNonSpaceNonCommentCharacterIndex2,
  getStringWidth: () => get_string_width_default,
  hasNewline: () => has_newline_default,
  hasNewlineInRange: () => has_newline_in_range_default,
  hasSpaces: () => has_spaces_default,
  isNextLineEmpty: () => isNextLineEmpty4,
  isNextLineEmptyAfterIndex: () => is_next_line_empty_default,
  isPreviousLineEmpty: () => isPreviousLineEmpty2,
  makeString: () => make_string_default,
  skip: () => skip,
  skipEverythingButNewLine: () => skipEverythingButNewLine,
  skipInlineComment: () => skip_inline_comment_default,
  skipNewline: () => skip_newline_default,
  skipSpaces: () => skipSpaces,
  skipToLineEnd: () => skipToLineEnd,
  skipTrailingComment: () => skip_trailing_comment_default,
  skipWhitespace: () => skipWhitespace
});

// src/utils/has-spaces.js
function hasSpaces(text, startIndex, options9 = {}) {
  const idx = skipSpaces(
    text,
    options9.backwards ? startIndex - 1 : startIndex,
    options9
  );
  return idx !== startIndex;
}
var has_spaces_default = hasSpaces;

// src/utils/public.js
function legacyGetNextNonSpaceNonCommentCharacterIndex(text, node, locEnd7) {
  return get_next_non_space_non_comment_character_index_default(
    text,
    locEnd7(node)
  );
}
function getNextNonSpaceNonCommentCharacterIndex2(text, startIndex) {
  return arguments.length === 2 || typeof startIndex === "number" ? get_next_non_space_non_comment_character_index_default(text, startIndex) : (
    // @ts-expect-error -- expected
    // eslint-disable-next-line prefer-rest-params
    legacyGetNextNonSpaceNonCommentCharacterIndex(...arguments)
  );
}
function legacyIsPreviousLineEmpty(text, node, locStart8) {
  return is_previous_line_empty_default(text, locStart8(node));
}
function isPreviousLineEmpty2(text, startIndex) {
  return arguments.length === 2 || typeof startIndex === "number" ? is_previous_line_empty_default(text, startIndex) : (
    // @ts-expect-error -- expected
    // eslint-disable-next-line prefer-rest-params
    legacyIsPreviousLineEmpty(...arguments)
  );
}
function legacyIsNextLineEmpty(text, node, locEnd7) {
  return is_next_line_empty_default(text, locEnd7(node));
}
function isNextLineEmpty4(text, startIndex) {
  return arguments.length === 2 || typeof startIndex === "number" ? is_next_line_empty_default(text, startIndex) : (
    // @ts-expect-error -- expected
    // eslint-disable-next-line prefer-rest-params
    legacyIsNextLineEmpty(...arguments)
  );
}

// src/index.js
import * as doc from "./doc.mjs";

// src/main/version.evaluate.cjs
var version_evaluate_default = "3.0.0-alpha.6";

// src/index.js
var builtinPlugins = Object.values(languages_exports);
function withPlugins(fn, optsArgIdx = 1) {
  return async (...args) => {
    const opts = args[optsArgIdx] || {};
    args[optsArgIdx] = {
      ...opts,
      plugins: [
        ...builtinPlugins,
        ...await memoizedLoad(opts.plugins, opts.pluginSearchDirs)
      ]
    };
    return fn(...args);
  };
}
var formatWithCursor2 = withPlugins(formatWithCursor);
async function format2(text, options9) {
  const { formatted } = await formatWithCursor2(text, {
    ...options9,
    cursorOffset: -1
  });
  return formatted;
}
async function check(text, options9) {
  return await format2(text, options9) === text;
}
async function clearCache3() {
  clearCache();
  clearCache2();
}
var getFileInfo2 = withPlugins(get_file_info_default);
var getSupportInfo2 = withPlugins(getSupportInfo, 0);
var sharedWithCli = {
  errors: errors_exports,
  coreOptions: core_options_evaluate_exports,
  createIsIgnoredFunction,
  formatOptionsHiddenDefaults,
  normalizeOptions: normalize_options_default,
  getSupportInfoWithoutPlugins: getSupportInfo,
  vnopts: import_vnopts2.default,
  fastGlob: import_fast_glob2.default,
  utils: {
    arrayify: arrayify_default,
    isNonEmptyArray: is_non_empty_array_default,
    partition: partition_default
  }
};
var debugApis = {
  parse: withPlugins(parse2),
  formatAST: withPlugins(formatAst),
  formatDoc: withPlugins(formatDoc),
  printToDoc: withPlugins(printToDoc),
  printDocToString: withPlugins(printDocToString2)
};
export {
  debugApis as __debug,
  sharedWithCli as __internal,
  check,
  clearCache3 as clearConfigCache,
  doc,
  format2 as format,
  formatWithCursor2 as formatWithCursor,
  getFileInfo2 as getFileInfo,
  getSupportInfo2 as getSupportInfo,
  resolveConfig,
  resolveConfigFile,
  public_exports as util,
  version_evaluate_default as version
};
